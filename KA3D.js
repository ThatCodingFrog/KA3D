var KA3D = (function (exports) {
	'use strict';

	function arrayNeedsUint32( array ) {

		// assumes larger values usually on last

		for ( let i = array.length - 1; i >= 0; -- i ) {

			if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

		}

		return false;

	}

	function createElementNS( name ) {

		return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

	}

	function createCanvasElement() {

		const canvas = createElementNS( 'canvas' );
		canvas.style.display = 'block';
		return canvas;

	}

	const _cache = {};

	function log( ...params ) {

		const message = 'THREE.' + params.shift();

		{

			console.log( message, ...params );

		}

	}

	function warn( ...params ) {

		const message = 'THREE.' + params.shift();

		{

			console.warn( message, ...params );

		}

	}

	function error( ...params ) {

		const message = 'THREE.' + params.shift();

		{

			console.error( message, ...params );

		}

	}

	function warnOnce( ...params ) {

		const message = params.join( ' ' );

		if ( message in _cache ) return;

		_cache[ message ] = true;

		warn( ...params );

	}

	function probeAsync( gl, sync, interval ) {

		return new Promise( function ( resolve, reject ) {

			function probe() {

				switch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {

					case gl.WAIT_FAILED:
						reject();
						break;

					case gl.TIMEOUT_EXPIRED:
						setTimeout( probe, interval );
						break;

					default:
						resolve();

				}

			}

			setTimeout( probe, interval );

		} );

	}

	const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];


	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI;

	/**
	 * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
	 * (universally unique identifier).
	 *
	 * @return {string} The UUID.
	 */
	function generateUUID() {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
				_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
				_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
				_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toLowerCase() here flattens concatenated strings to save heap memory space.
		return uuid.toLowerCase();

	}

	/**
	 * Clamps the given value between min and max.
	 *
	 * @param {number} value - The value to clamp.
	 * @param {number} min - The min value.
	 * @param {number} max - The max value.
	 * @return {number} The clamped value.
	 */
	function clamp( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	}

	/**
	 * Computes the Euclidean modulo of the given parameters that
	 * is `( ( n % m ) + m ) % m`.
	 *
	 * @param {number} n - The first parameter.
	 * @param {number} m - The second parameter.
	 * @return {number} The Euclidean modulo.
	 */
	function euclideanModulo( n, m ) {

		// https://en.wikipedia.org/wiki/Modulo_operation

		return ( ( n % m ) + m ) % m;

	}

	/**
	 * Returns a value linearly interpolated from two known points based on the given interval -
	 * `t = 0` will return `x` and `t = 1` will return `y`.
	 *
	 * @param {number} x - The start point
	 * @param {number} y - The end point.
	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	 * @return {number} The interpolated value.
	 */
	function lerp( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	}

	/**
	 * Denormalizes the given value according to the given typed array.
	 *
	 * @param {number} value - The value to denormalize.
	 * @param {TypedArray} array - The typed array that defines the data type of the value.
	 * @return {number} The denormalize (float) value in the range `[0,1]`.
	 */
	function denormalize( value, array ) {

		switch ( array.constructor ) {

			case Float32Array:

				return value;

			case Uint32Array:

				return value / 4294967295.0;

			case Uint16Array:

				return value / 65535.0;

			case Uint8Array:

				return value / 255.0;

			case Int32Array:

				return Math.max( value / 2147483647.0, -1 );

			case Int16Array:

				return Math.max( value / 32767.0, -1 );

			case Int8Array:

				return Math.max( value / 127.0, -1 );

			default:

				throw new Error( 'Invalid component type.' );

		}

	}

	/**
	 * Normalizes the given value according to the given typed array.
	 *
	 * @param {number} value - The float value in the range `[0,1]` to normalize.
	 * @param {TypedArray} array - The typed array that defines the data type of the value.
	 * @return {number} The normalize value.
	 */
	function normalize( value, array ) {

		switch ( array.constructor ) {

			case Float32Array:

				return value;

			case Uint32Array:

				return Math.round( value * 4294967295.0 );

			case Uint16Array:

				return Math.round( value * 65535.0 );

			case Uint8Array:

				return Math.round( value * 255.0 );

			case Int32Array:

				return Math.round( value * 2147483647.0 );

			case Int16Array:

				return Math.round( value * 32767.0 );

			case Int8Array:

				return Math.round( value * 127.0 );

			default:

				throw new Error( 'Invalid component type.' );

		}

	}

	/**
	 * Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.
	 *
	 * Iterating through a vector instance will yield its components `(x, y, z, w)` in
	 * the corresponding order.
	 *
	 * Note that three.js expects Quaternions to be normalized.
	 * ```js
	 * const quaternion = new THREE.Quaternion();
	 * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
	 *
	 * const vector = new THREE.Vector3( 1, 0, 0 );
	 * vector.applyQuaternion( quaternion );
	 * ```
	 */
	let Quaternion$1 = class Quaternion {

		/**
		 * Constructs a new quaternion.
		 *
		 * @param {number} [x=0] - The x value of this quaternion.
		 * @param {number} [y=0] - The y value of this quaternion.
		 * @param {number} [z=0] - The z value of this quaternion.
		 * @param {number} [w=1] - The w value of this quaternion.
		 */
		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isQuaternion = true;

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

		}

		/**
		 * Interpolates between two quaternions via SLERP. This implementation assumes the
		 * quaternion data are managed in flat arrays.
		 *
		 * @param {Array<number>} dst - The destination array.
		 * @param {number} dstOffset - An offset into the destination array.
		 * @param {Array<number>} src0 - The source array of the first quaternion.
		 * @param {number} srcOffset0 - An offset into the first source array.
		 * @param {Array<number>} src1 -  The source array of the second quaternion.
		 * @param {number} srcOffset1 - An offset into the second source array.
		 * @param {number} t - The interpolation factor in the range `[0,1]`.
		 * @see {@link Quaternion#slerp}
		 */
		static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			let x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ];

			let x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( t <= 0 ) {

				dst[ dstOffset + 0 ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;

				return;

			}

			if ( t >= 1 ) {

				dst[ dstOffset + 0 ] = x1;
				dst[ dstOffset + 1 ] = y1;
				dst[ dstOffset + 2 ] = z1;
				dst[ dstOffset + 3 ] = w1;

				return;

			}

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				let dot = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;

				if ( dot < 0 ) {

					x1 = - x1;
					y1 = - y1;
					z1 = - z1;
					w1 = - w1;

					dot = - dot;

				}

				let s = 1 - t;

				if ( dot < 0.9995 ) {

					// slerp

					const theta = Math.acos( dot );
					const sin = Math.sin( theta );

					s = Math.sin( s * theta ) / sin;
					t = Math.sin( t * theta ) / sin;

					x0 = x0 * s + x1 * t;
					y0 = y0 * s + y1 * t;
					z0 = z0 * s + z1 * t;
					w0 = w0 * s + w1 * t;

				} else {

					// for small angles, lerp then normalize

					x0 = x0 * s + x1 * t;
					y0 = y0 * s + y1 * t;
					z0 = z0 * s + z1 * t;
					w0 = w0 * s + w1 * t;

					const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

		/**
		 * Multiplies two quaternions. This implementation assumes the quaternion data are managed
		 * in flat arrays.
		 *
		 * @param {Array<number>} dst - The destination array.
		 * @param {number} dstOffset - An offset into the destination array.
		 * @param {Array<number>} src0 - The source array of the first quaternion.
		 * @param {number} srcOffset0 - An offset into the first source array.
		 * @param {Array<number>} src1 -  The source array of the second quaternion.
		 * @param {number} srcOffset1 - An offset into the second source array.
		 * @return {Array<number>} The destination array.
		 * @see {@link Quaternion#multiplyQuaternions}.
		 */
		static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

			const x0 = src0[ srcOffset0 ];
			const y0 = src0[ srcOffset0 + 1 ];
			const z0 = src0[ srcOffset0 + 2 ];
			const w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 ];
			const y1 = src1[ srcOffset1 + 1 ];
			const z1 = src1[ srcOffset1 + 2 ];
			const w1 = src1[ srcOffset1 + 3 ];

			dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

			return dst;

		}

		/**
		 * The x value of this quaternion.
		 *
		 * @type {number}
		 * @default 0
		 */
		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		/**
		 * The y value of this quaternion.
		 *
		 * @type {number}
		 * @default 0
		 */
		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		/**
		 * The z value of this quaternion.
		 *
		 * @type {number}
		 * @default 0
		 */
		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		/**
		 * The w value of this quaternion.
		 *
		 * @type {number}
		 * @default 1
		 */
		get w() {

			return this._w;

		}

		set w( value ) {

			this._w = value;
			this._onChangeCallback();

		}

		/**
		 * Sets the quaternion components.
		 *
		 * @param {number} x - The x value of this quaternion.
		 * @param {number} y - The y value of this quaternion.
		 * @param {number} z - The z value of this quaternion.
		 * @param {number} w - The w value of this quaternion.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		set( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		}

		/**
		 * Returns a new quaternion with copied values from this instance.
		 *
		 * @return {Quaternion} A clone of this instance.
		 */
		clone() {

			return new this.constructor( this._x, this._y, this._z, this._w );

		}

		/**
		 * Copies the values of the given quaternion to this instance.
		 *
		 * @param {Quaternion} quaternion - The quaternion to copy.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		copy( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		}

		/**
		 * Sets this quaternion from the rotation specified by the given
		 * Euler angles.
		 *
		 * @param {Euler} euler - The Euler angles.
		 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		setFromEuler( euler, update = true ) {

			const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;

			const c1 = cos( x / 2 );
			const c2 = cos( y / 2 );
			const c3 = cos( z / 2 );

			const s1 = sin( x / 2 );
			const s2 = sin( y / 2 );
			const s3 = sin( z / 2 );

			switch ( order ) {

				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					warn( 'Quaternion: .setFromEuler() encountered an unknown order: ' + order );

			}

			if ( update === true ) this._onChangeCallback();

			return this;

		}

		/**
		 * Sets this quaternion from the given axis and angle.
		 *
		 * @param {Vector3} axis - The normalized axis.
		 * @param {number} angle - The angle in radians.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		setFromAxisAngle( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			const halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		}

		/**
		 * Sets this quaternion from the given rotation matrix.
		 *
		 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
		 * @return {Quaternion} A reference to this quaternion.
		 */
		setFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33;

			if ( trace > 0 ) {

				const s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		}

		/**
		 * Sets this quaternion to the rotation required to rotate the direction vector
		 * `vFrom` to the direction vector `vTo`.
		 *
		 * @param {Vector3} vFrom - The first (normalized) direction vector.
		 * @param {Vector3} vTo - The second (normalized) direction vector.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		setFromUnitVectors( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			let r = vFrom.dot( vTo ) + 1;

			if ( r < 1e-8 ) { // the epsilon value has been discussed in #31286

				// vFrom and vTo point in opposite directions

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		}

		/**
		 * Returns the angle between this quaternion and the given one in radians.
		 *
		 * @param {Quaternion} q - The quaternion to compute the angle with.
		 * @return {number} The angle in radians.
		 */
		angleTo( q ) {

			return 2 * Math.acos( Math.abs( clamp( this.dot( q ), -1, 1 ) ) );

		}

		/**
		 * Rotates this quaternion by a given angular step to the given quaternion.
		 * The method ensures that the final quaternion will not overshoot `q`.
		 *
		 * @param {Quaternion} q - The target quaternion.
		 * @param {number} step - The angular step in radians.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		rotateTowards( q, step ) {

			const angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			const t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		}

		/**
		 * Sets this quaternion to the identity quaternion; that is, to the
		 * quaternion that represents "no rotation".
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */
		identity() {

			return this.set( 0, 0, 0, 1 );

		}

		/**
		 * Inverts this quaternion via {@link Quaternion#conjugate}. The
		 * quaternion is assumed to have unit length.
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */
		invert() {

			return this.conjugate();

		}

		/**
		 * Returns the rotational conjugate of this quaternion. The conjugate of a
		 * quaternion represents the same rotation in the opposite direction about
		 * the rotational axis.
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */
		conjugate() {

			this._x *= -1;
			this._y *= -1;
			this._z *= -1;

			this._onChangeCallback();

			return this;

		}

		/**
		 * Calculates the dot product of this quaternion and the given one.
		 *
		 * @param {Quaternion} v - The quaternion to compute the dot product with.
		 * @return {number} The result of the dot product.
		 */
		dot( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		}

		/**
		 * Computes the squared Euclidean length (straight-line length) of this quaternion,
		 * considered as a 4 dimensional vector. This can be useful if you are comparing the
		 * lengths of two quaternions, as this is a slightly more efficient calculation than
		 * {@link Quaternion#length}.
		 *
		 * @return {number} The squared Euclidean length.
		 */
		lengthSq() {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		}

		/**
		 * Computes the Euclidean length (straight-line length) of this quaternion,
		 * considered as a 4 dimensional vector.
		 *
		 * @return {number} The Euclidean length.
		 */
		length() {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		}

		/**
		 * Normalizes this quaternion - that is, calculated the quaternion that performs
		 * the same rotation as this one, but has a length equal to `1`.
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */
		normalize() {

			let l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		}

		/**
		 * Multiplies this quaternion by the given one.
		 *
		 * @param {Quaternion} q - The quaternion.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		multiply( q ) {

			return this.multiplyQuaternions( this, q );

		}

		/**
		 * Pre-multiplies this quaternion by the given one.
		 *
		 * @param {Quaternion} q - The quaternion.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		premultiply( q ) {

			return this.multiplyQuaternions( q, this );

		}

		/**
		 * Multiplies the given quaternions and stores the result in this instance.
		 *
		 * @param {Quaternion} a - The first quaternion.
		 * @param {Quaternion} b - The second quaternion.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		multiplyQuaternions( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		}

		/**
		 * Performs a spherical linear interpolation between quaternions.
		 *
		 * @param {Quaternion} qb - The target quaternion.
		 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		slerp( qb, t ) {

			if ( t <= 0 ) return this;

			if ( t >= 1 ) return this.copy( qb ); // copy calls _onChangeCallback()

			let x = qb._x, y = qb._y, z = qb._z, w = qb._w;

			let dot = this.dot( qb );

			if ( dot < 0 ) {

				x = - x;
				y = - y;
				z = - z;
				w = - w;

				dot = - dot;

			}

			let s = 1 - t;

			if ( dot < 0.9995 ) {

				// slerp

				const theta = Math.acos( dot );
				const sin = Math.sin( theta );

				s = Math.sin( s * theta ) / sin;
				t = Math.sin( t * theta ) / sin;

				this._x = this._x * s + x * t;
				this._y = this._y * s + y * t;
				this._z = this._z * s + z * t;
				this._w = this._w * s + w * t;

				this._onChangeCallback();

			} else {

				// for small angles, lerp then normalize

				this._x = this._x * s + x * t;
				this._y = this._y * s + y * t;
				this._z = this._z * s + z * t;
				this._w = this._w * s + w * t;

				this.normalize(); // normalize calls _onChangeCallback()

			}

			return this;

		}

		/**
		 * Performs a spherical linear interpolation between the given quaternions
		 * and stores the result in this quaternion.
		 *
		 * @param {Quaternion} qa - The source quaternion.
		 * @param {Quaternion} qb - The target quaternion.
		 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		slerpQuaternions( qa, qb, t ) {

			return this.copy( qa ).slerp( qb, t );

		}

		/**
		 * Sets this quaternion to a uniformly random, normalized quaternion.
		 *
		 * @return {Quaternion} A reference to this quaternion.
		 */
		random() {

			// Ken Shoemake
			// Uniform random rotations
			// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

			const theta1 = 2 * Math.PI * Math.random();
			const theta2 = 2 * Math.PI * Math.random();

			const x0 = Math.random();
			const r1 = Math.sqrt( 1 - x0 );
			const r2 = Math.sqrt( x0 );

			return this.set(
				r1 * Math.sin( theta1 ),
				r1 * Math.cos( theta1 ),
				r2 * Math.sin( theta2 ),
				r2 * Math.cos( theta2 ),
			);

		}

		/**
		 * Returns `true` if this quaternion is equal with the given one.
		 *
		 * @param {Quaternion} quaternion - The quaternion to test for equality.
		 * @return {boolean} Whether this quaternion is equal with the given one.
		 */
		equals( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		}

		/**
		 * Sets this quaternion's components from the given array.
		 *
		 * @param {Array<number>} array - An array holding the quaternion component values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		fromArray( array, offset = 0 ) {

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		}

		/**
		 * Writes the components of this quaternion to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The quaternion components.
		 */
		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		}

		/**
		 * Sets the components of this quaternion from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
		 * @param {number} index - The index into the attribute.
		 * @return {Quaternion} A reference to this quaternion.
		 */
		fromBufferAttribute( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			this._onChangeCallback();

			return this;

		}

		/**
		 * This methods defines the serialization result of this class. Returns the
		 * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
		 *
		 * @return {Array<number>} The serialized quaternion.
		 */
		toJSON() {

			return this.toArray();

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

		*[ Symbol.iterator ]() {

			yield this._x;
			yield this._y;
			yield this._z;
			yield this._w;

		}

	};

	/**
	 * Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
	 * (labeled x, y and z), which can be used to represent a number of things, such as:
	 *
	 * - A point in 3D space.
	 * - A direction and length in 3D space. In three.js the length will
	 * always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
	 * and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
	 * - Any arbitrary ordered triplet of numbers.
	 *
	 * There are other things a 3D vector can be used to represent, such as
	 * momentum vectors and so on, however these are the most
	 * common uses in three.js.
	 *
	 * Iterating through a vector instance will yield its components `(x, y, z)` in
	 * the corresponding order.
	 * ```js
	 * const a = new THREE.Vector3( 0, 1, 0 );
	 *
	 * //no arguments; will be initialised to (0, 0, 0)
	 * const b = new THREE.Vector3( );
	 *
	 * const d = a.distanceTo( b );
	 * ```
	 */
	class Vector3 {

		/**
		 * Constructs a new 3D vector.
		 *
		 * @param {number} [x=0] - The x value of this vector.
		 * @param {number} [y=0] - The y value of this vector.
		 * @param {number} [z=0] - The z value of this vector.
		 */
		constructor( x = 0, y = 0, z = 0 ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			Vector3.prototype.isVector3 = true;

			/**
			 * The x value of this vector.
			 *
			 * @type {number}
			 */
			this.x = x;

			/**
			 * The y value of this vector.
			 *
			 * @type {number}
			 */
			this.y = y;

			/**
			 * The z value of this vector.
			 *
			 * @type {number}
			 */
			this.z = z;

		}

		/**
		 * Sets the vector components.
		 *
		 * @param {number} x - The value of the x component.
		 * @param {number} y - The value of the y component.
		 * @param {number} z - The value of the z component.
		 * @return {Vector3} A reference to this vector.
		 */
		set( x, y, z ) {

			if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		}

		/**
		 * Sets the vector components to the same value.
		 *
		 * @param {number} scalar - The value to set for all vector components.
		 * @return {Vector3} A reference to this vector.
		 */
		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		}

		/**
		 * Sets the vector's x component to the given value
		 *
		 * @param {number} x - The value to set.
		 * @return {Vector3} A reference to this vector.
		 */
		setX( x ) {

			this.x = x;

			return this;

		}

		/**
		 * Sets the vector's y component to the given value
		 *
		 * @param {number} y - The value to set.
		 * @return {Vector3} A reference to this vector.
		 */
		setY( y ) {

			this.y = y;

			return this;

		}

		/**
		 * Sets the vector's z component to the given value
		 *
		 * @param {number} z - The value to set.
		 * @return {Vector3} A reference to this vector.
		 */
		setZ( z ) {

			this.z = z;

			return this;

		}

		/**
		 * Allows to set a vector component with an index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
		 * @param {number} value - The value to set.
		 * @return {Vector3} A reference to this vector.
		 */
		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		/**
		 * Returns the value of the vector component which matches the given index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
		 * @return {number} A vector component value.
		 */
		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		/**
		 * Returns a new vector with copied values from this instance.
		 *
		 * @return {Vector3} A clone of this instance.
		 */
		clone() {

			return new this.constructor( this.x, this.y, this.z );

		}

		/**
		 * Copies the values of the given vector to this instance.
		 *
		 * @param {Vector3} v - The vector to copy.
		 * @return {Vector3} A reference to this vector.
		 */
		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		}

		/**
		 * Adds the given vector to this instance.
		 *
		 * @param {Vector3} v - The vector to add.
		 * @return {Vector3} A reference to this vector.
		 */
		add( v ) {

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		}

		/**
		 * Adds the given scalar value to all components of this instance.
		 *
		 * @param {number} s - The scalar to add.
		 * @return {Vector3} A reference to this vector.
		 */
		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		}

		/**
		 * Adds the given vectors and stores the result in this instance.
		 *
		 * @param {Vector3} a - The first vector.
		 * @param {Vector3} b - The second vector.
		 * @return {Vector3} A reference to this vector.
		 */
		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		}

		/**
		 * Adds the given vector scaled by the given factor to this instance.
		 *
		 * @param {Vector3|Vector4} v - The vector.
		 * @param {number} s - The factor that scales `v`.
		 * @return {Vector3} A reference to this vector.
		 */
		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		}

		/**
		 * Subtracts the given vector from this instance.
		 *
		 * @param {Vector3} v - The vector to subtract.
		 * @return {Vector3} A reference to this vector.
		 */
		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		}

		/**
		 * Subtracts the given scalar value from all components of this instance.
		 *
		 * @param {number} s - The scalar to subtract.
		 * @return {Vector3} A reference to this vector.
		 */
		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		}

		/**
		 * Subtracts the given vectors and stores the result in this instance.
		 *
		 * @param {Vector3} a - The first vector.
		 * @param {Vector3} b - The second vector.
		 * @return {Vector3} A reference to this vector.
		 */
		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		}

		/**
		 * Multiplies the given vector with this instance.
		 *
		 * @param {Vector3} v - The vector to multiply.
		 * @return {Vector3} A reference to this vector.
		 */
		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		}

		/**
		 * Multiplies the given scalar value with all components of this instance.
		 *
		 * @param {number} scalar - The scalar to multiply.
		 * @return {Vector3} A reference to this vector.
		 */
		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		}

		/**
		 * Multiplies the given vectors and stores the result in this instance.
		 *
		 * @param {Vector3} a - The first vector.
		 * @param {Vector3} b - The second vector.
		 * @return {Vector3} A reference to this vector.
		 */
		multiplyVectors( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		}

		/**
		 * Applies the given Euler rotation to this vector.
		 *
		 * @param {Euler} euler - The Euler angles.
		 * @return {Vector3} A reference to this vector.
		 */
		applyEuler( euler ) {

			return this.applyQuaternion( _quaternion$2.setFromEuler( euler ) );

		}

		/**
		 * Applies a rotation specified by an axis and an angle to this vector.
		 *
		 * @param {Vector3} axis - A normalized vector representing the rotation axis.
		 * @param {number} angle - The angle in radians.
		 * @return {Vector3} A reference to this vector.
		 */
		applyAxisAngle( axis, angle ) {

			return this.applyQuaternion( _quaternion$2.setFromAxisAngle( axis, angle ) );

		}

		/**
		 * Multiplies this vector with the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The 3x3 matrix.
		 * @return {Vector3} A reference to this vector.
		 */
		applyMatrix3( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		}

		/**
		 * Multiplies this vector by the given normal matrix and normalizes
		 * the result.
		 *
		 * @param {Matrix3} m - The normal matrix.
		 * @return {Vector3} A reference to this vector.
		 */
		applyNormalMatrix( m ) {

			return this.applyMatrix3( m ).normalize();

		}

		/**
		 * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
		 * divides by perspective.
		 *
		 * @param {Matrix4} m - The matrix to apply.
		 * @return {Vector3} A reference to this vector.
		 */
		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		}

		/**
		 * Applies the given Quaternion to this vector.
		 *
		 * @param {Quaternion} q - The Quaternion.
		 * @return {Vector3} A reference to this vector.
		 */
		applyQuaternion( q ) {

			// quaternion q is assumed to have unit length

			const vx = this.x, vy = this.y, vz = this.z;
			const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// t = 2 * cross( q.xyz, v );
			const tx = 2 * ( qy * vz - qz * vy );
			const ty = 2 * ( qz * vx - qx * vz );
			const tz = 2 * ( qx * vy - qy * vx );

			// v + q.w * t + cross( q.xyz, t );
			this.x = vx + qw * tx + qy * tz - qz * ty;
			this.y = vy + qw * ty + qz * tx - qx * tz;
			this.z = vz + qw * tz + qx * ty - qy * tx;

			return this;

		}

		/**
		 * Projects this vector from world space into the camera's normalized
		 * device coordinate (NDC) space.
		 *
		 * @param {Camera} camera - The camera.
		 * @return {Vector3} A reference to this vector.
		 */
		project( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		}

		/**
		 * Unprojects this vector from the camera's normalized device coordinate (NDC)
		 * space into world space.
		 *
		 * @param {Camera} camera - The camera.
		 * @return {Vector3} A reference to this vector.
		 */
		unproject( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		}

		/**
		 * Transforms the direction of this vector by a matrix (the upper left 3 x 3
		 * subset of the given 4x4 matrix and then normalizes the result.
		 *
		 * @param {Matrix4} m - The matrix.
		 * @return {Vector3} A reference to this vector.
		 */
		transformDirection( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		}

		/**
		 * Divides this instance by the given vector.
		 *
		 * @param {Vector3} v - The vector to divide.
		 * @return {Vector3} A reference to this vector.
		 */
		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		}

		/**
		 * Divides this vector by the given scalar.
		 *
		 * @param {number} scalar - The scalar to divide.
		 * @return {Vector3} A reference to this vector.
		 */
		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		/**
		 * If this vector's x, y or z value is greater than the given vector's x, y or z
		 * value, replace that value with the corresponding min value.
		 *
		 * @param {Vector3} v - The vector.
		 * @return {Vector3} A reference to this vector.
		 */
		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		}

		/**
		 * If this vector's x, y or z value is less than the given vector's x, y or z
		 * value, replace that value with the corresponding max value.
		 *
		 * @param {Vector3} v - The vector.
		 * @return {Vector3} A reference to this vector.
		 */
		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		}

		/**
		 * If this vector's x, y or z value is greater than the max vector's x, y or z
		 * value, it is replaced by the corresponding value.
		 * If this vector's x, y or z value is less than the min vector's x, y or z value,
		 * it is replaced by the corresponding value.
		 *
		 * @param {Vector3} min - The minimum x, y and z values.
		 * @param {Vector3} max - The maximum x, y and z values in the desired range.
		 * @return {Vector3} A reference to this vector.
		 */
		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = clamp( this.x, min.x, max.x );
			this.y = clamp( this.y, min.y, max.y );
			this.z = clamp( this.z, min.z, max.z );

			return this;

		}

		/**
		 * If this vector's x, y or z values are greater than the max value, they are
		 * replaced by the max value.
		 * If this vector's x, y or z values are less than the min value, they are
		 * replaced by the min value.
		 *
		 * @param {number} minVal - The minimum value the components will be clamped to.
		 * @param {number} maxVal - The maximum value the components will be clamped to.
		 * @return {Vector3} A reference to this vector.
		 */
		clampScalar( minVal, maxVal ) {

			this.x = clamp( this.x, minVal, maxVal );
			this.y = clamp( this.y, minVal, maxVal );
			this.z = clamp( this.z, minVal, maxVal );

			return this;

		}

		/**
		 * If this vector's length is greater than the max value, it is replaced by
		 * the max value.
		 * If this vector's length is less than the min value, it is replaced by the
		 * min value.
		 *
		 * @param {number} min - The minimum value the vector length will be clamped to.
		 * @param {number} max - The maximum value the vector length will be clamped to.
		 * @return {Vector3} A reference to this vector.
		 */
		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

		}

		/**
		 * The components of this vector are rounded down to the nearest integer value.
		 *
		 * @return {Vector3} A reference to this vector.
		 */
		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		}

		/**
		 * The components of this vector are rounded up to the nearest integer value.
		 *
		 * @return {Vector3} A reference to this vector.
		 */
		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		}

		/**
		 * The components of this vector are rounded to the nearest integer value
		 *
		 * @return {Vector3} A reference to this vector.
		 */
		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		}

		/**
		 * The components of this vector are rounded towards zero (up if negative,
		 * down if positive) to an integer value.
		 *
		 * @return {Vector3} A reference to this vector.
		 */
		roundToZero() {

			this.x = Math.trunc( this.x );
			this.y = Math.trunc( this.y );
			this.z = Math.trunc( this.z );

			return this;

		}

		/**
		 * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
		 *
		 * @return {Vector3} A reference to this vector.
		 */
		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		}

		/**
		 * Calculates the dot product of the given vector with this instance.
		 *
		 * @param {Vector3} v - The vector to compute the dot product with.
		 * @return {number} The result of the dot product.
		 */
		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		}

		// TODO lengthSquared?

		/**
		 * Computes the square of the Euclidean length (straight-line length) from
		 * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
		 * compare the length squared instead as it is slightly more efficient to calculate.
		 *
		 * @return {number} The square length of this vector.
		 */
		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		}

		/**
		 * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
		 *
		 * @return {number} The length of this vector.
		 */
		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		}

		/**
		 * Computes the Manhattan length of this vector.
		 *
		 * @return {number} The length of this vector.
		 */
		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		}

		/**
		 * Converts this vector to a unit vector - that is, sets it equal to a vector
		 * with the same direction as this one, but with a vector length of `1`.
		 *
		 * @return {Vector3} A reference to this vector.
		 */
		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		/**
		 * Sets this vector to a vector with the same direction as this one, but
		 * with the specified length.
		 *
		 * @param {number} length - The new length of this vector.
		 * @return {Vector3} A reference to this vector.
		 */
		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		/**
		 * Linearly interpolates between the given vector and this instance, where
		 * alpha is the percent distance along the line - alpha = 0 will be this
		 * vector, and alpha = 1 will be the given one.
		 *
		 * @param {Vector3} v - The vector to interpolate towards.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector3} A reference to this vector.
		 */
		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		}

		/**
		 * Linearly interpolates between the given vectors, where alpha is the percent
		 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
		 * be the second one. The result is stored in this instance.
		 *
		 * @param {Vector3} v1 - The first vector.
		 * @param {Vector3} v2 - The second vector.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector3} A reference to this vector.
		 */
		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;

			return this;

		}

		/**
		 * Calculates the cross product of the given vector with this instance.
		 *
		 * @param {Vector3} v - The vector to compute the cross product with.
		 * @return {Vector3} The result of the cross product.
		 */
		cross( v ) {

			return this.crossVectors( this, v );

		}

		/**
		 * Calculates the cross product of the given vectors and stores the result
		 * in this instance.
		 *
		 * @param {Vector3} a - The first vector.
		 * @param {Vector3} b - The second vector.
		 * @return {Vector3} A reference to this vector.
		 */
		crossVectors( a, b ) {

			const ax = a.x, ay = a.y, az = a.z;
			const bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		}

		/**
		 * Projects this vector onto the given one.
		 *
		 * @param {Vector3} v - The vector to project to.
		 * @return {Vector3} A reference to this vector.
		 */
		projectOnVector( v ) {

			const denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			const scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		}

		/**
		 * Projects this vector onto a plane by subtracting this
		 * vector projected onto the plane's normal from this vector.
		 *
		 * @param {Vector3} planeNormal - The plane normal.
		 * @return {Vector3} A reference to this vector.
		 */
		projectOnPlane( planeNormal ) {

			_vector$5.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector$5 );

		}

		/**
		 * Reflects this vector off a plane orthogonal to the given normal vector.
		 *
		 * @param {Vector3} normal - The (normalized) normal vector.
		 * @return {Vector3} A reference to this vector.
		 */
		reflect( normal ) {

			return this.sub( _vector$5.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}
		/**
		 * Returns the angle between the given vector and this instance in radians.
		 *
		 * @param {Vector3} v - The vector to compute the angle with.
		 * @return {number} The angle in radians.
		 */
		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( clamp( theta, -1, 1 ) );

		}

		/**
		 * Computes the distance from the given vector to this instance.
		 *
		 * @param {Vector3} v - The vector to compute the distance to.
		 * @return {number} The distance.
		 */
		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		/**
		 * Computes the squared distance from the given vector to this instance.
		 * If you are just comparing the distance with another distance, you should compare
		 * the distance squared instead as it is slightly more efficient to calculate.
		 *
		 * @param {Vector3} v - The vector to compute the squared distance to.
		 * @return {number} The squared distance.
		 */
		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		}

		/**
		 * Computes the Manhattan distance from the given vector to this instance.
		 *
		 * @param {Vector3} v - The vector to compute the Manhattan distance to.
		 * @return {number} The Manhattan distance.
		 */
		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		}

		/**
		 * Sets the vector components from the given spherical coordinates.
		 *
		 * @param {Spherical} s - The spherical coordinates.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromSpherical( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		}

		/**
		 * Sets the vector components from the given spherical coordinates.
		 *
		 * @param {number} radius - The radius.
		 * @param {number} phi - The phi angle in radians.
		 * @param {number} theta - The theta angle in radians.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromSphericalCoords( radius, phi, theta ) {

			const sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		}

		/**
		 * Sets the vector components from the given cylindrical coordinates.
		 *
		 * @param {Cylindrical} c - The cylindrical coordinates.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromCylindrical( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		}

		/**
		 * Sets the vector components from the given cylindrical coordinates.
		 *
		 * @param {number} radius - The radius.
		 * @param {number} theta - The theta angle in radians.
		 * @param {number} y - The y value.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromCylindricalCoords( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		}

		/**
		 * Sets the vector components to the position elements of the
		 * given transformation matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromMatrixPosition( m ) {

			const e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		}

		/**
		 * Sets the vector components to the scale elements of the
		 * given transformation matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromMatrixScale( m ) {

			const sx = this.setFromMatrixColumn( m, 0 ).length();
			const sy = this.setFromMatrixColumn( m, 1 ).length();
			const sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		}

		/**
		 * Sets the vector components from the specified matrix column.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @param {number} index - The column index.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromMatrixColumn( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		}

		/**
		 * Sets the vector components from the specified matrix column.
		 *
		 * @param {Matrix3} m - The 3x3 matrix.
		 * @param {number} index - The column index.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromMatrix3Column( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		}

		/**
		 * Sets the vector components from the given Euler angles.
		 *
		 * @param {Euler} e - The Euler angles to set.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromEuler( e ) {

			this.x = e._x;
			this.y = e._y;
			this.z = e._z;

			return this;

		}

		/**
		 * Sets the vector components from the RGB components of the
		 * given color.
		 *
		 * @param {Color} c - The color to set.
		 * @return {Vector3} A reference to this vector.
		 */
		setFromColor( c ) {

			this.x = c.r;
			this.y = c.g;
			this.z = c.b;

			return this;

		}

		/**
		 * Returns `true` if this vector is equal with the given one.
		 *
		 * @param {Vector3} v - The vector to test for equality.
		 * @return {boolean} Whether this vector is equal with the given one.
		 */
		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		}

		/**
		 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
		 * and z value to be `array[ offset + 2 ]`.
		 *
		 * @param {Array<number>} array - An array holding the vector component values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Vector3} A reference to this vector.
		 */
		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		}

		/**
		 * Writes the components of this vector to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the vector components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The vector components.
		 */
		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		}

		/**
		 * Sets the components of this vector from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
		 * @param {number} index - The index into the attribute.
		 * @return {Vector3} A reference to this vector.
		 */
		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

		/**
		 * Sets each component of this vector to a pseudo-random value between `0` and
		 * `1`, excluding `1`.
		 *
		 * @return {Vector3} A reference to this vector.
		 */
		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();

			return this;

		}

		/**
		 * Sets this vector to a uniformly random point on a unit sphere.
		 *
		 * @return {Vector3} A reference to this vector.
		 */
		randomDirection() {

			// https://mathworld.wolfram.com/SpherePointPicking.html

			const theta = Math.random() * Math.PI * 2;
			const u = Math.random() * 2 - 1;
			const c = Math.sqrt( 1 - u * u );

			this.x = c * Math.cos( theta );
			this.y = u;
			this.z = c * Math.sin( theta );

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;

		}

	}

	const _vector$5 = /*@__PURE__*/ new Vector3();
	const _quaternion$2 = /*@__PURE__*/ new Quaternion$1();

	const REVISION = '181dev';

	/**
	 * Disables face culling.
	 *
	 * @type {number}
	 * @constant
	 */
	const CullFaceNone = 0;

	/**
	 * Culls back faces.
	 *
	 * @type {number}
	 * @constant
	 */
	const CullFaceBack = 1;

	/**
	 * Culls front faces.
	 *
	 * @type {number}
	 * @constant
	 */
	const CullFaceFront = 2;

	/**
	 * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm.
	 *
	 * @type {number}
	 * @constant
	 */
	const PCFShadowMap = 1;

	/**
	 * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm with
	 * better soft shadows especially when using low-resolution shadow maps.
	 *
	 * @type {number}
	 * @constant
	 */
	const PCFSoftShadowMap = 2;

	/**
	 * Filters shadow maps using the Variance Shadow Map (VSM) algorithm.
	 * When using VSMShadowMap all shadow receivers will also cast shadows.
	 *
	 * @type {number}
	 * @constant
	 */
	const VSMShadowMap = 3;

	/**
	 * Only front faces are rendered.
	 *
	 * @type {number}
	 * @constant
	 */
	const FrontSide = 0;

	/**
	 * Only back faces are rendered.
	 *
	 * @type {number}
	 * @constant
	 */
	const BackSide = 1;

	/**
	 * Both front and back faces are rendered.
	 *
	 * @type {number}
	 * @constant
	 */
	const DoubleSide = 2;

	/**
	 * No blending is performed which effectively disables
	 * alpha transparency.
	 *
	 * @type {number}
	 * @constant
	 */
	const NoBlending = 0;

	/**
	 * The default blending.
	 *
	 * @type {number}
	 * @constant
	 */
	const NormalBlending = 1;

	/**
	 * Represents additive blending.
	 *
	 * @type {number}
	 * @constant
	 */
	const AdditiveBlending = 2;

	/**
	 * Represents subtractive blending.
	 *
	 * @type {number}
	 * @constant
	 */
	const SubtractiveBlending = 3;

	/**
	 * Represents multiply blending.
	 *
	 * @type {number}
	 * @constant
	 */
	const MultiplyBlending = 4;

	/**
	 * Represents custom blending.
	 *
	 * @type {number}
	 * @constant
	 */
	const CustomBlending = 5;

	/**
	 * A `source + destination` blending equation.
	 *
	 * @type {number}
	 * @constant
	 */
	const AddEquation = 100;

	/**
	 * A `source - destination` blending equation.
	 *
	 * @type {number}
	 * @constant
	 */
	const SubtractEquation = 101;

	/**
	 * A `destination - source` blending equation.
	 *
	 * @type {number}
	 * @constant
	 */
	const ReverseSubtractEquation = 102;

	/**
	 * A blend equation that uses the minimum of source and destination.
	 *
	 * @type {number}
	 * @constant
	 */
	const MinEquation = 103;

	/**
	 * A blend equation that uses the maximum of source and destination.
	 *
	 * @type {number}
	 * @constant
	 */
	const MaxEquation = 104;

	/**
	 * Multiplies all colors by `0`.
	 *
	 * @type {number}
	 * @constant
	 */
	const ZeroFactor = 200;

	/**
	 * Multiplies all colors by `1`.
	 *
	 * @type {number}
	 * @constant
	 */
	const OneFactor = 201;

	/**
	 * Multiplies all colors by the source colors.
	 *
	 * @type {number}
	 * @constant
	 */
	const SrcColorFactor = 202;

	/**
	 * Multiplies all colors by `1` minus each source color.
	 *
	 * @type {number}
	 * @constant
	 */
	const OneMinusSrcColorFactor = 203;

	/**
	 * Multiplies all colors by the source alpha value.
	 *
	 * @type {number}
	 * @constant
	 */
	const SrcAlphaFactor = 204;

	/**
	 * Multiplies all colors by 1 minus the source alpha value.
	 *
	 * @type {number}
	 * @constant
	 */
	const OneMinusSrcAlphaFactor = 205;

	/**
	 * Multiplies all colors by the destination alpha value.
	 *
	 * @type {number}
	 * @constant
	 */
	const DstAlphaFactor = 206;

	/**
	 * Multiplies all colors by `1` minus the destination alpha value.
	 *
	 * @type {number}
	 * @constant
	 */
	const OneMinusDstAlphaFactor = 207;

	/**
	 * Multiplies all colors by the destination color.
	 *
	 * @type {number}
	 * @constant
	 */
	const DstColorFactor = 208;

	/**
	 * Multiplies all colors by `1` minus each destination color.
	 *
	 * @type {number}
	 * @constant
	 */
	const OneMinusDstColorFactor = 209;

	/**
	 * Multiplies the RGB colors by the smaller of either the source alpha
	 * value or the value of `1` minus the destination alpha value. The alpha
	 * value is multiplied by `1`.
	 *
	 * @type {number}
	 * @constant
	 */
	const SrcAlphaSaturateFactor = 210;

	/**
	 * Multiplies all colors by a constant color.
	 *
	 * @type {number}
	 * @constant
	 */
	const ConstantColorFactor = 211;

	/**
	 * Multiplies all colors by `1` minus a constant color.
	 *
	 * @type {number}
	 * @constant
	 */
	const OneMinusConstantColorFactor = 212;

	/**
	 * Multiplies all colors by a constant alpha value.
	 *
	 * @type {number}
	 * @constant
	 */
	const ConstantAlphaFactor = 213;

	/**
	 * Multiplies all colors by 1 minus a constant alpha value.
	 *
	 * @type {number}
	 * @constant
	 */
	const OneMinusConstantAlphaFactor = 214;

	/**
	 * Never pass.
	 *
	 * @type {number}
	 * @constant
	 */
	const NeverDepth = 0;

	/**
	 * Always pass.
	 *
	 * @type {number}
	 * @constant
	 */
	const AlwaysDepth = 1;

	/**
	 * Pass if the incoming value is less than the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */
	const LessDepth = 2;

	/**
	 * Pass if the incoming value is less than or equal to the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */
	const LessEqualDepth = 3;

	/**
	 * Pass if the incoming value equals the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */
	const EqualDepth = 4;

	/**
	 * Pass if the incoming value is greater than or equal to the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */
	const GreaterEqualDepth = 5;

	/**
	 * Pass if the incoming value is greater than the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */
	const GreaterDepth = 6;

	/**
	 * Pass if the incoming value is not equal to the depth buffer value.
	 *
	 * @type {number}
	 * @constant
	 */
	const NotEqualDepth = 7;

	/**
	 * Multiplies the environment map color with the surface color.
	 *
	 * @type {number}
	 * @constant
	 */
	const MultiplyOperation = 0;

	/**
	 * Uses reflectivity to blend between the two colors.
	 *
	 * @type {number}
	 * @constant
	 */
	const MixOperation = 1;

	/**
	 * Adds the two colors.
	 *
	 * @type {number}
	 * @constant
	 */
	const AddOperation = 2;

	/**
	 * No tone mapping is applied.
	 *
	 * @type {number}
	 * @constant
	 */
	const NoToneMapping = 0;

	/**
	 * Linear tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */
	const LinearToneMapping = 1;

	/**
	 * Reinhard tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */
	const ReinhardToneMapping = 2;

	/**
	 * Cineon tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */
	const CineonToneMapping = 3;

	/**
	 * ACES Filmic tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */
	const ACESFilmicToneMapping = 4;

	/**
	 * Custom tone mapping.
	 *
	 * Expects a custom implementation by modifying shader code of the material's fragment shader.
	 *
	 * @type {number}
	 * @constant
	 */
	const CustomToneMapping = 5;

	/**
	 * AgX tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */
	const AgXToneMapping = 6;

	/**
	 * Neutral tone mapping.
	 *
	 * Implementation based on the Khronos 3D Commerce Group standard tone mapping.
	 *
	 * @type {number}
	 * @constant
	 */
	const NeutralToneMapping = 7;

	/**
	 * Maps textures using the geometry's UV coordinates.
	 *
	 * @type {number}
	 * @constant
	 */
	const UVMapping = 300;

	/**
	 * Reflection mapping for cube textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const CubeReflectionMapping = 301;

	/**
	 * Refraction mapping for cube textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const CubeRefractionMapping = 302;

	/**
	 * Reflection mapping for equirectangular textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const EquirectangularReflectionMapping = 303;

	/**
	 * Refraction mapping for equirectangular textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const EquirectangularRefractionMapping = 304;

	/**
	 * Reflection mapping for PMREM textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const CubeUVReflectionMapping = 306;

	/**
	 * The texture will simply repeat to infinity.
	 *
	 * @type {number}
	 * @constant
	 */
	const RepeatWrapping = 1000;

	/**
	 * The last pixel of the texture stretches to the edge of the mesh.
	 *
	 * @type {number}
	 * @constant
	 */
	const ClampToEdgeWrapping = 1001;

	/**
	 * The texture will repeats to infinity, mirroring on each repeat.
	 *
	 * @type {number}
	 * @constant
	 */
	const MirroredRepeatWrapping = 1002;

	/**
	 * Returns the value of the texture element that is nearest (in Manhattan distance)
	 * to the specified texture coordinates.
	 *
	 * @type {number}
	 * @constant
	 */
	const NearestFilter = 1003;

	/**
	 * Chooses the mipmap that most closely matches the size of the pixel being textured
	 * and uses the `NearestFilter` criterion (the texel nearest to the center of the pixel)
	 * to produce a texture value.
	 *
	 * @type {number}
	 * @constant
	 */
	const NearestMipmapNearestFilter = 1004;

	/**
	 * Chooses the two mipmaps that most closely match the size of the pixel being textured and
	 * uses the `NearestFilter` criterion to produce a texture value from each mipmap.
	 * The final texture value is a weighted average of those two values.
	 *
	 * @type {number}
	 * @constant
	 */
	const NearestMipmapLinearFilter = 1005;

	/**
	 * Returns the weighted average of the four texture elements that are closest to the specified
	 * texture coordinates, and can include items wrapped or repeated from other parts of a texture,
	 * depending on the values of `wrapS` and `wrapT`, and on the exact mapping.
	 *
	 * @type {number}
	 * @constant
	 */
	const LinearFilter = 1006;

	/**
	 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses
	 * the `LinearFilter` criterion (a weighted average of the four texels that are closest to the
	 * center of the pixel) to produce a texture value.
	 *
	 * @type {number}
	 * @constant
	 */
	const LinearMipmapNearestFilter = 1007;

	/**
	 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses
	 * the `LinearFilter` criterion to produce a texture value from each mipmap. The final texture value
	 * is a weighted average of those two values.
	 *
	 * @type {number}
	 * @constant
	 */
	const LinearMipmapLinearFilter = 1008;

	/**
	 * An unsigned byte data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const UnsignedByteType = 1009;

	/**
	 * A byte data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const ByteType = 1010;

	/**
	 * A short data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const ShortType = 1011;

	/**
	 * An unsigned short data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const UnsignedShortType = 1012;

	/**
	 * An int data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const IntType = 1013;

	/**
	 * An unsigned int data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const UnsignedIntType = 1014;

	/**
	 * A float data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const FloatType = 1015;

	/**
	 * A half float data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const HalfFloatType = 1016;

	/**
	 * An unsigned short 4_4_4_4 (packed) data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const UnsignedShort4444Type = 1017;

	/**
	 * An unsigned short 5_5_5_1 (packed) data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const UnsignedShort5551Type = 1018;

	/**
	 * An unsigned int 24_8 data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const UnsignedInt248Type = 1020;

	/**
	 * An unsigned int 5_9_9_9 (packed) data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const UnsignedInt5999Type = 35902;

	/**
	 * An unsigned int 10_11_11 (packed) data type for textures.
	 *
	 * @type {number}
	 * @constant
	 */
	const UnsignedInt101111Type = 35899;

	/**
	 * Discards the red, green and blue components and reads just the alpha component.
	 *
	 * @type {number}
	 * @constant
	 */
	const AlphaFormat = 1021;

	/**
	 * Discards the alpha component and reads the red, green and blue component.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBFormat = 1022;

	/**
	 * Reads the red, green, blue and alpha components.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBAFormat = 1023;

	/**
	 * Reads each element as a single depth value, converts it to floating point, and clamps to the range `[0,1]`.
	 *
	 * @type {number}
	 * @constant
	 */
	const DepthFormat = 1026;

	/**
	 * Reads each element is a pair of depth and stencil values. The depth component of the pair is interpreted as
	 * in `DepthFormat`. The stencil component is interpreted based on the depth + stencil internal format.
	 *
	 * @type {number}
	 * @constant
	 */
	const DepthStencilFormat = 1027;

	/**
	 * Discards the green, blue and alpha components and reads just the red component.
	 *
	 * @type {number}
	 * @constant
	 */
	const RedFormat = 1028;

	/**
	 * Discards the green, blue and alpha components and reads just the red component. The texels are read as integers instead of floating point.
	 *
	 * @type {number}
	 * @constant
	 */
	const RedIntegerFormat = 1029;

	/**
	 * Discards the alpha, and blue components and reads the red, and green components.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGFormat = 1030;

	/**
	 * Discards the alpha, and blue components and reads the red, and green components. The texels are read as integers instead of floating point.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGIntegerFormat = 1031;

	/**
	 * Reads the red, green, blue and alpha components. The texels are read as integers instead of floating point.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBAIntegerFormat = 1033;

	/**
	 * A DXT1-compressed image in an RGB image format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGB_S3TC_DXT1_Format = 33776;

	/**
	 * A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_S3TC_DXT1_Format = 33777;

	/**
	 * A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_S3TC_DXT3_Format = 33778;

	/**
	 * A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3
	 * compression in how the alpha compression is done.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_S3TC_DXT5_Format = 33779;

	/**
	 * PVRTC RGB compression in 4-bit mode. One block for each 44 pixels.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGB_PVRTC_4BPPV1_Format = 35840;

	/**
	 * PVRTC RGB compression in 2-bit mode. One block for each 84 pixels.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGB_PVRTC_2BPPV1_Format = 35841;

	/**
	 * PVRTC RGBA compression in 4-bit mode. One block for each 44 pixels.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_PVRTC_4BPPV1_Format = 35842;

	/**
	 * PVRTC RGBA compression in 2-bit mode. One block for each 84 pixels.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_PVRTC_2BPPV1_Format = 35843;

	/**
	 * ETC1 RGB format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGB_ETC1_Format = 36196;

	/**
	 * ETC2 RGB format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGB_ETC2_Format = 37492;

	/**
	 * ETC2 RGBA format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ETC2_EAC_Format = 37496;

	/**
	 * ASTC RGBA 4x4 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_4x4_Format = 37808;

	/**
	 * ASTC RGBA 5x4 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_5x4_Format = 37809;

	/**
	 * ASTC RGBA 5x5 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_5x5_Format = 37810;

	/**
	 * ASTC RGBA 6x5 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_6x5_Format = 37811;

	/**
	 * ASTC RGBA 6x6 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_6x6_Format = 37812;

	/**
	 * ASTC RGBA 8x5 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_8x5_Format = 37813;

	/**
	 * ASTC RGBA 8x6 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_8x6_Format = 37814;

	/**
	 * ASTC RGBA 8x8 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_8x8_Format = 37815;

	/**
	 * ASTC RGBA 10x5 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_10x5_Format = 37816;

	/**
	 * ASTC RGBA 10x6 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_10x6_Format = 37817;

	/**
	 * ASTC RGBA 10x8 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_10x8_Format = 37818;

	/**
	 * ASTC RGBA 10x10 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_10x10_Format = 37819;

	/**
	 * ASTC RGBA 12x10 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_12x10_Format = 37820;

	/**
	 * ASTC RGBA 12x12 format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_ASTC_12x12_Format = 37821;

	/**
	 * BPTC RGBA format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBA_BPTC_Format = 36492;

	/**
	 * BPTC Signed RGB format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGB_BPTC_SIGNED_Format = 36494;

	/**
	 * BPTC Unsigned RGB format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGB_BPTC_UNSIGNED_Format = 36495;

	/**
	 * RGTC1 Red format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RED_RGTC1_Format = 36283;

	/**
	 * RGTC1 Signed Red format.
	 *
	 * @type {number}
	 * @constant
	 */
	const SIGNED_RED_RGTC1_Format = 36284;

	/**
	 * RGTC2 Red Green format.
	 *
	 * @type {number}
	 * @constant
	 */
	const RED_GREEN_RGTC2_Format = 36285;

	/**
	 * RGTC2 Signed Red Green format.
	 *
	 * @type {number}
	 * @constant
	 */
	const SIGNED_RED_GREEN_RGTC2_Format = 36286;

	/**
	 * Basic depth packing.
	 *
	 * @type {number}
	 * @constant
	 */
	const BasicDepthPacking = 3200;

	/**
	 * A depth value is packed into 32 bit RGBA.
	 *
	 * @type {number}
	 * @constant
	 */
	const RGBADepthPacking = 3201;

	/**
	 * Normal information is relative to the underlying surface.
	 *
	 * @type {number}
	 * @constant
	 */
	const TangentSpaceNormalMap = 0;

	/**
	 * Normal information is relative to the object orientation.
	 *
	 * @type {number}
	 * @constant
	 */
	const ObjectSpaceNormalMap = 1;

	// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

	/**
	 * No color space.
	 *
	 * @type {string}
	 * @constant
	 */
	const NoColorSpace = '';

	/**
	 * sRGB color space.
	 *
	 * @type {string}
	 * @constant
	 */
	const SRGBColorSpace = 'srgb';

	/**
	 * sRGB-linear color space.
	 *
	 * @type {string}
	 * @constant
	 */
	const LinearSRGBColorSpace = 'srgb-linear';

	/**
	 * Linear transfer function.
	 *
	 * @type {string}
	 * @constant
	 */
	const LinearTransfer = 'linear';

	/**
	 * sRGB transfer function.
	 *
	 * @type {string}
	 * @constant
	 */
	const SRGBTransfer = 'srgb';

	/**
	 * Keeps the current value.
	 *
	 * @type {number}
	 * @constant
	 */
	const KeepStencilOp = 7680;

	/**
	 * Will always return true.
	 *
	 * @type {number}
	 * @constant
	 */
	const AlwaysStencilFunc = 519;

	/**
	 * Never pass.
	 *
	 * @type {number}
	 * @constant
	 */
	const NeverCompare = 512;

	/**
	 * Pass if the incoming value is less than the texture value.
	 *
	 * @type {number}
	 * @constant
	 */
	const LessCompare = 513;

	/**
	 * Pass if the incoming value equals the texture value.
	 *
	 * @type {number}
	 * @constant
	 */
	const EqualCompare = 514;

	/**
	 * Pass if the incoming value is less than or equal to the texture value.
	 *
	 * @type {number}
	 * @constant
	 */
	const LessEqualCompare = 515;

	/**
	 * Pass if the incoming value is greater than the texture value.
	 *
	 * @type {number}
	 * @constant
	 */
	const GreaterCompare = 516;

	/**
	 * Pass if the incoming value is not equal to the texture value.
	 *
	 * @type {number}
	 * @constant
	 */
	const NotEqualCompare = 517;

	/**
	 * Pass if the incoming value is greater than or equal to the texture value.
	 *
	 * @type {number}
	 * @constant
	 */
	const GreaterEqualCompare = 518;

	/**
	 * Always pass.
	 *
	 * @type {number}
	 * @constant
	 */
	const AlwaysCompare = 519;

	/**
	 * The contents are intended to be specified once by the application, and used many
	 * times as the source for drawing and image specification commands.
	 *
	 * @type {number}
	 * @constant
	 */
	const StaticDrawUsage = 35044;

	/**
	 * GLSL 3 shader code.
	 *
	 * @type {string}
	 * @constant
	 */
	const GLSL3 = '300 es';

	/**
	 * WebGL coordinate system.
	 *
	 * @type {number}
	 * @constant
	 */
	const WebGLCoordinateSystem = 2000;

	/**
	 * WebGPU coordinate system.
	 *
	 * @type {number}
	 * @constant
	 */
	const WebGPUCoordinateSystem = 2001;

	/**
	 * This type represents mouse buttons and interaction types in context of controls.
	 *
	 * @typedef {Object} ConstantsMouse
	 * @property {number} MIDDLE - The left mouse button.
	 * @property {number} LEFT - The middle mouse button.
	 * @property {number} RIGHT - The right mouse button.
	 * @property {number} ROTATE - A rotate interaction.
	 * @property {number} DOLLY - A dolly interaction.
	 * @property {number} PAN - A pan interaction.
	 **/

	/**
	 * This type represents touch interaction types in context of controls.
	 *
	 * @typedef {Object} ConstantsTouch
	 * @property {number} ROTATE - A rotate interaction.
	 * @property {number} PAN - A pan interaction.
	 * @property {number} DOLLY_PAN - The dolly-pan interaction.
	 * @property {number} DOLLY_ROTATE - A dolly-rotate interaction.
	 **/

	/**
	 * This type represents the different timestamp query types.
	 *
	 * @typedef {Object} ConstantsTimestampQuery
	 * @property {string} COMPUTE - A `compute` timestamp query.
	 * @property {string} RENDER - A `render` timestamp query.
	 **/

	/**
	 * Represents the different interpolation sampling types.
	 *
	 * @typedef {Object} ConstantsInterpolationSamplingType
	 * @property {string} PERSPECTIVE - Perspective-correct interpolation.
	 * @property {string} LINEAR - Linear interpolation.
	 * @property {string} FLAT - Flat interpolation.
	 */

	/**
	 * Represents the different interpolation sampling modes.
	 *
	 * @typedef {Object} ConstantsInterpolationSamplingMode
	 * @property {string} NORMAL - Normal sampling mode.
	 * @property {string} CENTROID - Centroid sampling mode.
	 * @property {string} SAMPLE - Sample-specific sampling mode.
	 * @property {string} FIRST - Flat interpolation using the first vertex.
	 * @property {string} EITHER - Flat interpolation using either vertex.
	 */

	/**
	 * Represents a 4x4 matrix.
	 *
	 * The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
	 * For an introduction to transformation matrices as used in WebGL, check out [this tutorial]{@link https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices}
	 *
	 * This allows a 3D vector representing a point in 3D space to undergo
	 * transformations such as translation, rotation, shear, scale, reflection,
	 * orthogonal or perspective projection and so on, by being multiplied by the
	 * matrix. This is known as `applying` the matrix to the vector.
	 *
	 * A Note on Row-Major and Column-Major Ordering:
	 *
	 * The constructor and {@link Matrix3#set} method take arguments in
	 * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
	 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
	 * This means that calling:
	 * ```js
	 * const m = new THREE.Matrix4();
	 * m.set( 11, 12, 13, 14,
	 *        21, 22, 23, 24,
	 *        31, 32, 33, 34,
	 *        41, 42, 43, 44 );
	 * ```
	 * will result in the elements array containing:
	 * ```js
	 * m.elements = [ 11, 21, 31, 41,
	 *                12, 22, 32, 42,
	 *                13, 23, 33, 43,
	 *                14, 24, 34, 44 ];
	 * ```
	 * and internally all calculations are performed using column-major ordering.
	 * However, as the actual ordering makes no difference mathematically and
	 * most people are used to thinking about matrices in row-major order, the
	 * three.js documentation shows matrices in row-major order. Just bear in
	 * mind that if you are reading the source code, you'll have to take the
	 * transpose of any matrices outlined here to make sense of the calculations.
	 */
	class Matrix4 {

		/**
		 * Constructs a new 4x4 matrix. The arguments are supposed to be
		 * in row-major order. If no arguments are provided, the constructor
		 * initializes the matrix as an identity matrix.
		 *
		 * @param {number} [n11] - 1-1 matrix element.
		 * @param {number} [n12] - 1-2 matrix element.
		 * @param {number} [n13] - 1-3 matrix element.
		 * @param {number} [n14] - 1-4 matrix element.
		 * @param {number} [n21] - 2-1 matrix element.
		 * @param {number} [n22] - 2-2 matrix element.
		 * @param {number} [n23] - 2-3 matrix element.
		 * @param {number} [n24] - 2-4 matrix element.
		 * @param {number} [n31] - 3-1 matrix element.
		 * @param {number} [n32] - 3-2 matrix element.
		 * @param {number} [n33] - 3-3 matrix element.
		 * @param {number} [n34] - 3-4 matrix element.
		 * @param {number} [n41] - 4-1 matrix element.
		 * @param {number} [n42] - 4-2 matrix element.
		 * @param {number} [n43] - 4-3 matrix element.
		 * @param {number} [n44] - 4-4 matrix element.
		 */
		constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			Matrix4.prototype.isMatrix4 = true;

			/**
			 * A column-major list of matrix values.
			 *
			 * @type {Array<number>}
			 */
			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( n11 !== undefined ) {

				this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

			}

		}

		/**
		 * Sets the elements of the matrix.The arguments are supposed to be
		 * in row-major order.
		 *
		 * @param {number} [n11] - 1-1 matrix element.
		 * @param {number} [n12] - 1-2 matrix element.
		 * @param {number} [n13] - 1-3 matrix element.
		 * @param {number} [n14] - 1-4 matrix element.
		 * @param {number} [n21] - 2-1 matrix element.
		 * @param {number} [n22] - 2-2 matrix element.
		 * @param {number} [n23] - 2-3 matrix element.
		 * @param {number} [n24] - 2-4 matrix element.
		 * @param {number} [n31] - 3-1 matrix element.
		 * @param {number} [n32] - 3-2 matrix element.
		 * @param {number} [n33] - 3-3 matrix element.
		 * @param {number} [n34] - 3-4 matrix element.
		 * @param {number} [n41] - 4-1 matrix element.
		 * @param {number} [n42] - 4-2 matrix element.
		 * @param {number} [n43] - 4-3 matrix element.
		 * @param {number} [n44] - 4-4 matrix element.
		 * @return {Matrix4} A reference to this matrix.
		 */
		set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		}

		/**
		 * Sets this matrix to the 4x4 identity matrix.
		 *
		 * @return {Matrix4} A reference to this matrix.
		 */
		identity() {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		/**
		 * Returns a matrix with copied values from this instance.
		 *
		 * @return {Matrix4} A clone of this instance.
		 */
		clone() {

			return new Matrix4().fromArray( this.elements );

		}

		/**
		 * Copies the values of the given matrix to this instance.
		 *
		 * @param {Matrix4} m - The matrix to copy.
		 * @return {Matrix4} A reference to this matrix.
		 */
		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		}

		/**
		 * Copies the translation component of the given matrix
		 * into this matrix's translation component.
		 *
		 * @param {Matrix4} m - The matrix to copy the translation component.
		 * @return {Matrix4} A reference to this matrix.
		 */
		copyPosition( m ) {

			const te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		}

		/**
		 * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The 3x3 matrix.
		 * @return {Matrix4} A reference to this matrix.
		 */
		setFromMatrix3( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ], 0,
				me[ 1 ], me[ 4 ], me[ 7 ], 0,
				me[ 2 ], me[ 5 ], me[ 8 ], 0,
				0, 0, 0, 1

			);

			return this;

		}

		/**
		 * Extracts the basis of this matrix into the three axis vectors provided.
		 *
		 * @param {Vector3} xAxis - The basis's x axis.
		 * @param {Vector3} yAxis - The basis's y axis.
		 * @param {Vector3} zAxis - The basis's z axis.
		 * @return {Matrix4} A reference to this matrix.
		 */
		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		}

		/**
		 * Sets the given basis vectors to this matrix.
		 *
		 * @param {Vector3} xAxis - The basis's x axis.
		 * @param {Vector3} yAxis - The basis's y axis.
		 * @param {Vector3} zAxis - The basis's z axis.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeBasis( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		}

		/**
		 * Extracts the rotation component of the given matrix
		 * into this matrix's rotation component.
		 *
		 * Note: This method does not support reflection matrices.
		 *
		 * @param {Matrix4} m - The matrix.
		 * @return {Matrix4} A reference to this matrix.
		 */
		extractRotation( m ) {

			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$4.setFromMatrixColumn( m, 0 ).length();
			const scaleY = 1 / _v1$4.setFromMatrixColumn( m, 1 ).length();
			const scaleZ = 1 / _v1$4.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		/**
		 * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
		 * the rotation specified by the given Euler angles. The rest of
		 * the matrix is set to the identity. Depending on the {@link Euler#order},
		 * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
		 * for a complete list.
		 *
		 * @param {Euler} euler - The Euler angles.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeRotationFromEuler( euler ) {

			const te = this.elements;

			const x = euler.x, y = euler.y, z = euler.z;
			const a = Math.cos( x ), b = Math.sin( x );
			const c = Math.cos( y ), d = Math.sin( y );
			const e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		/**
		 * Sets the rotation component of this matrix to the rotation specified by
		 * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
		 * The rest of the matrix is set to the identity.
		 *
		 * @param {Quaternion} q - The Quaternion.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeRotationFromQuaternion( q ) {

			return this.compose( _zero, q, _one );

		}

		/**
		 * Sets the rotation component of the transformation matrix, looking from `eye` towards
		 * `target`, and oriented by the up-direction.
		 *
		 * @param {Vector3} eye - The eye vector.
		 * @param {Vector3} target - The target vector.
		 * @param {Vector3} up - The up vector.
		 * @return {Matrix4} A reference to this matrix.
		 */
		lookAt( eye, target, up ) {

			const te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		}

		/**
		 * Post-multiplies this matrix by the given 4x4 matrix.
		 *
		 * @param {Matrix4} m - The matrix to multiply with.
		 * @return {Matrix4} A reference to this matrix.
		 */
		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		/**
		 * Pre-multiplies this matrix by the given 4x4 matrix.
		 *
		 * @param {Matrix4} m - The matrix to multiply with.
		 * @return {Matrix4} A reference to this matrix.
		 */
		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		/**
		 * Multiples the given 4x4 matrices and stores the result
		 * in this matrix.
		 *
		 * @param {Matrix4} a - The first matrix.
		 * @param {Matrix4} b - The second matrix.
		 * @return {Matrix4} A reference to this matrix.
		 */
		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		}

		/**
		 * Multiplies every component of the matrix by the given scalar.
		 *
		 * @param {number} s - The scalar.
		 * @return {Matrix4} A reference to this matrix.
		 */
		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		}

		/**
		 * Computes and returns the determinant of this matrix.
		 *
		 * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
		 *
		 * @return {number} The determinant.
		 */
		determinant() {

			const te = this.elements;

			const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		}

		/**
		 * Transposes this matrix in place.
		 *
		 * @return {Matrix4} A reference to this matrix.
		 */
		transpose() {

			const te = this.elements;
			let tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		}

		/**
		 * Sets the position component for this matrix from the given vector,
		 * without affecting the rest of the matrix.
		 *
		 * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
		 * @param {number} y - The y component of the vector.
		 * @param {number} z - The z component of the vector.
		 * @return {Matrix4} A reference to this matrix.
		 */
		setPosition( x, y, z ) {

			const te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		}

		/**
		 * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
		 * You can not invert with a determinant of zero. If you attempt this, the method produces
		 * a zero matrix instead.
		 *
		 * @return {Matrix4} A reference to this matrix.
		 */
		invert() {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
				n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
				n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
				n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		}

		/**
		 * Multiplies the columns of this matrix by the given vector.
		 *
		 * @param {Vector3} v - The scale vector.
		 * @return {Matrix4} A reference to this matrix.
		 */
		scale( v ) {

			const te = this.elements;
			const x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		}

		/**
		 * Gets the maximum scale value of the three axes.
		 *
		 * @return {number} The maximum scale.
		 */
		getMaxScaleOnAxis() {

			const te = this.elements;

			const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		}

		/**
		 * Sets this matrix as a translation transform from the given vector.
		 *
		 * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
		 * @param {number} y - The amount to translate in the Y axis.
		 * @param {number} z - The amount to translate in the z axis.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeTranslation( x, y, z ) {

			if ( x.isVector3 ) {

				this.set(

					1, 0, 0, x.x,
					0, 1, 0, x.y,
					0, 0, 1, x.z,
					0, 0, 0, 1

				);

			} else {

				this.set(

					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1

				);

			}

			return this;

		}

		/**
		 * Sets this matrix as a rotational transformation around the X axis by
		 * the given angle.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeRotationX( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		/**
		 * Sets this matrix as a rotational transformation around the Y axis by
		 * the given angle.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeRotationY( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		}

		/**
		 * Sets this matrix as a rotational transformation around the Z axis by
		 * the given angle.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeRotationZ( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		/**
		 * Sets this matrix as a rotational transformation around the given axis by
		 * the given angle.
		 *
		 * This is a somewhat controversial but mathematically sound alternative to
		 * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
		 *
		 * @param {Vector3} axis - The normalized rotation axis.
		 * @param {number} angle - The rotation in radians.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeRotationAxis( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			const c = Math.cos( angle );
			const s = Math.sin( angle );
			const t = 1 - c;
			const x = axis.x, y = axis.y, z = axis.z;
			const tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		/**
		 * Sets this matrix as a scale transformation.
		 *
		 * @param {number} x - The amount to scale in the X axis.
		 * @param {number} y - The amount to scale in the Y axis.
		 * @param {number} z - The amount to scale in the Z axis.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeScale( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		}

		/**
		 * Sets this matrix as a shear transformation.
		 *
		 * @param {number} xy - The amount to shear X by Y.
		 * @param {number} xz - The amount to shear X by Z.
		 * @param {number} yx - The amount to shear Y by X.
		 * @param {number} yz - The amount to shear Y by Z.
		 * @param {number} zx - The amount to shear Z by X.
		 * @param {number} zy - The amount to shear Z by Y.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeShear( xy, xz, yx, yz, zx, zy ) {

			this.set(

				1, yx, zx, 0,
				xy, 1, zy, 0,
				xz, yz, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		/**
		 * Sets this matrix to the transformation composed of the given position,
		 * rotation (Quaternion) and scale.
		 *
		 * @param {Vector3} position - The position vector.
		 * @param {Quaternion} quaternion - The rotation as a Quaternion.
		 * @param {Vector3} scale - The scale vector.
		 * @return {Matrix4} A reference to this matrix.
		 */
		compose( position, quaternion, scale ) {

			const te = this.elements;

			const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			const x2 = x + x,	y2 = y + y, z2 = z + z;
			const xx = x * x2, xy = x * y2, xz = x * z2;
			const yy = y * y2, yz = y * z2, zz = z * z2;
			const wx = w * x2, wy = w * y2, wz = w * z2;

			const sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		}

		/**
		 * Decomposes this matrix into its position, rotation and scale components
		 * and provides the result in the given objects.
		 *
		 * Note: Not all matrices are decomposable in this way. For example, if an
		 * object has a non-uniformly scaled parent, then the object's world matrix
		 * may not be decomposable, and this method may not be appropriate.
		 *
		 * @param {Vector3} position - The position vector.
		 * @param {Quaternion} quaternion - The rotation as a Quaternion.
		 * @param {Vector3} scale - The scale vector.
		 * @return {Matrix4} A reference to this matrix.
		 */
		decompose( position, quaternion, scale ) {

			const te = this.elements;

			let sx = _v1$4.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			const sy = _v1$4.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			const sz = _v1$4.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			const det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1$4.copy( this );

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;

			_m1$4.elements[ 0 ] *= invSX;
			_m1$4.elements[ 1 ] *= invSX;
			_m1$4.elements[ 2 ] *= invSX;

			_m1$4.elements[ 4 ] *= invSY;
			_m1$4.elements[ 5 ] *= invSY;
			_m1$4.elements[ 6 ] *= invSY;

			_m1$4.elements[ 8 ] *= invSZ;
			_m1$4.elements[ 9 ] *= invSZ;
			_m1$4.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1$4 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		}

		/**
		 * Creates a perspective projection matrix. This is used internally by
		 * {@link PerspectiveCamera#updateProjectionMatrix}.

		 * @param {number} left - Left boundary of the viewing frustum at the near plane.
		 * @param {number} right - Right boundary of the viewing frustum at the near plane.
		 * @param {number} top - Top boundary of the viewing frustum at the near plane.
		 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
		 * @param {number} near - The distance from the camera to the near plane.
		 * @param {number} far - The distance from the camera to the far plane.
		 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
		 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {

			const te = this.elements;

			const x = 2 * near / ( right - left );
			const y = 2 * near / ( top - bottom );

			const a = ( right + left ) / ( right - left );
			const b = ( top + bottom ) / ( top - bottom );

			let c, d;

			if ( reversedDepth ) {

				c = near / ( far - near );
				d = ( far * near ) / ( far - near );

			} else {

				if ( coordinateSystem === WebGLCoordinateSystem ) {

					c = - ( far + near ) / ( far - near );
					d = ( -2 * far * near ) / ( far - near );

				} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

					c = - far / ( far - near );
					d = ( - far * near ) / ( far - near );

				} else {

					throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

				}

			}

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = -1;	te[ 15 ] = 0;

			return this;

		}

		/**
		 * Creates a orthographic projection matrix. This is used internally by
		 * {@link OrthographicCamera#updateProjectionMatrix}.

		 * @param {number} left - Left boundary of the viewing frustum at the near plane.
		 * @param {number} right - Right boundary of the viewing frustum at the near plane.
		 * @param {number} top - Top boundary of the viewing frustum at the near plane.
		 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
		 * @param {number} near - The distance from the camera to the near plane.
		 * @param {number} far - The distance from the camera to the far plane.
		 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
		 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
		 * @return {Matrix4} A reference to this matrix.
		 */
		makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {

			const te = this.elements;

			const x = 2 / ( right - left );
			const y = 2 / ( top - bottom );

			const a = - ( right + left ) / ( right - left );
			const b = - ( top + bottom ) / ( top - bottom );

			let c, d;

			if ( reversedDepth ) {

				c = 1 / ( far - near );
				d = far / ( far - near );

			} else {

				if ( coordinateSystem === WebGLCoordinateSystem ) {

					c = -2 / ( far - near );
					d = - ( far + near ) / ( far - near );

				} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

					c = -1 / ( far - near );
					d = - near / ( far - near );

				} else {

					throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

				}

			}

			te[ 0 ] = x;		te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = a;
			te[ 1 ] = 0; 		te[ 5 ] = y;		te[ 9 ] = 0; 		te[ 13 ] = b;
			te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = c;		te[ 14 ] = d;
			te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

			return this;

		}

		/**
		 * Returns `true` if this matrix is equal with the given one.
		 *
		 * @param {Matrix4} matrix - The matrix to test for equality.
		 * @return {boolean} Whether this matrix is equal with the given one.
		 */
		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		/**
		 * Sets the elements of the matrix from the given array.
		 *
		 * @param {Array<number>} array - The matrix elements in column-major order.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Matrix4} A reference to this matrix.
		 */
		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		/**
		 * Writes the elements of this matrix to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The matrix elements in column-major order.
		 */
		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	}

	const _v1$4 = /*@__PURE__*/ new Vector3();
	const _m1$4 = /*@__PURE__*/ new Matrix4();
	const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
	const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
	const _x = /*@__PURE__*/ new Vector3();
	const _y = /*@__PURE__*/ new Vector3();
	const _z = /*@__PURE__*/ new Vector3();

	/**
	 * This modules allows to dispatch event objects on custom JavaScript objects.
	 *
	 * Main repository: [eventdispatcher.js]{@link https://github.com/mrdoob/eventdispatcher.js/}
	 *
	 * Code Example:
	 * ```js
	 * class Car extends EventDispatcher {
	 * 	start() {
	 *		this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
	 *	}
	 *};
	 *
	 * // Using events with the custom object
	 * const car = new Car();
	 * car.addEventListener( 'start', function ( event ) {
	 * 	alert( event.message );
	 * } );
	 *
	 * car.start();
	 * ```
	 */
	class EventDispatcher {

		/**
		 * Adds the given event listener to the given event type.
		 *
		 * @param {string} type - The type of event to listen to.
		 * @param {Function} listener - The function that gets called when the event is fired.
		 */
		addEventListener( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			const listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === -1 ) {

				listeners[ type ].push( listener );

			}

		}

		/**
		 * Returns `true` if the given event listener has been added to the given event type.
		 *
		 * @param {string} type - The type of event.
		 * @param {Function} listener - The listener to check.
		 * @return {boolean} Whether the given event listener has been added to the given event type.
		 */
		hasEventListener( type, listener ) {

			const listeners = this._listeners;

			if ( listeners === undefined ) return false;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1;

		}

		/**
		 * Removes the given event listener from the given event type.
		 *
		 * @param {string} type - The type of event.
		 * @param {Function} listener - The listener to remove.
		 */
		removeEventListener( type, listener ) {

			const listeners = this._listeners;

			if ( listeners === undefined ) return;

			const listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				const index = listenerArray.indexOf( listener );

				if ( index !== -1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		}

		/**
		 * Dispatches an event object.
		 *
		 * @param {Object} event - The event that gets fired.
		 */
		dispatchEvent( event ) {

			const listeners = this._listeners;

			if ( listeners === undefined ) return;

			const listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				// Make a copy, in case listeners are removed while iterating.
				const array = listenerArray.slice( 0 );

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

				event.target = null;

			}

		}

	}

	const _matrix = /*@__PURE__*/ new Matrix4();
	const _quaternion$1 = /*@__PURE__*/ new Quaternion$1();

	/**
	 * A class representing Euler angles.
	 *
	 * Euler angles describe a rotational transformation by rotating an object on
	 * its various axes in specified amounts per axis, and a specified axis
	 * order.
	 *
	 * Iterating through an instance will yield its components (x, y, z,
	 * order) in the corresponding order.
	 *
	 * ```js
	 * const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
	 * const b = new THREE.Vector3( 1, 0, 1 );
	 * b.applyEuler(a);
	 * ```
	 */
	class Euler {

		/**
		 * Constructs a new euler instance.
		 *
		 * @param {number} [x=0] - The angle of the x axis in radians.
		 * @param {number} [y=0] - The angle of the y axis in radians.
		 * @param {number} [z=0] - The angle of the z axis in radians.
		 * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
		 */
		constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isEuler = true;

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

		}

		/**
		 * The angle of the x axis in radians.
		 *
		 * @type {number}
		 * @default 0
		 */
		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		/**
		 * The angle of the y axis in radians.
		 *
		 * @type {number}
		 * @default 0
		 */
		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		/**
		 * The angle of the z axis in radians.
		 *
		 * @type {number}
		 * @default 0
		 */
		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		/**
		 * A string representing the order that the rotations are applied.
		 *
		 * @type {string}
		 * @default 'XYZ'
		 */
		get order() {

			return this._order;

		}

		set order( value ) {

			this._order = value;
			this._onChangeCallback();

		}

		/**
		 * Sets the Euler components.
		 *
		 * @param {number} x - The angle of the x axis in radians.
		 * @param {number} y - The angle of the y axis in radians.
		 * @param {number} z - The angle of the z axis in radians.
		 * @param {string} [order] - A string representing the order that the rotations are applied.
		 * @return {Euler} A reference to this Euler instance.
		 */
		set( x, y, z, order = this._order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

			this._onChangeCallback();

			return this;

		}

		/**
		 * Returns a new Euler instance with copied values from this instance.
		 *
		 * @return {Euler} A clone of this instance.
		 */
		clone() {

			return new this.constructor( this._x, this._y, this._z, this._order );

		}

		/**
		 * Copies the values of the given Euler instance to this instance.
		 *
		 * @param {Euler} euler - The Euler instance to copy.
		 * @return {Euler} A reference to this Euler instance.
		 */
		copy( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		}

		/**
		 * Sets the angles of this Euler instance from a pure rotation matrix.
		 *
		 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
		 * @param {string} [order] - A string representing the order that the rotations are applied.
		 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
		 * @return {Euler} A reference to this Euler instance.
		 */
		setFromRotationMatrix( m, order = this._order, update = true ) {

			const te = m.elements;
			const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			switch ( order ) {

				case 'XYZ':

					this._y = Math.asin( clamp( m13, -1, 1 ) );

					if ( Math.abs( m13 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

					break;

				case 'YXZ':

					this._x = Math.asin( - clamp( m23, -1, 1 ) );

					if ( Math.abs( m23 ) < 0.9999999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

					break;

				case 'ZXY':

					this._x = Math.asin( clamp( m32, -1, 1 ) );

					if ( Math.abs( m32 ) < 0.9999999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

					break;

				case 'ZYX':

					this._y = Math.asin( - clamp( m31, -1, 1 ) );

					if ( Math.abs( m31 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

					break;

				case 'YZX':

					this._z = Math.asin( clamp( m21, -1, 1 ) );

					if ( Math.abs( m21 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

					break;

				case 'XZY':

					this._z = Math.asin( - clamp( m12, -1, 1 ) );

					if ( Math.abs( m12 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

					break;

				default:

					warn( 'Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

			}

			this._order = order;

			if ( update === true ) this._onChangeCallback();

			return this;

		}

		/**
		 * Sets the angles of this Euler instance from a normalized quaternion.
		 *
		 * @param {Quaternion} q - A normalized Quaternion.
		 * @param {string} [order] - A string representing the order that the rotations are applied.
		 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
		 * @return {Euler} A reference to this Euler instance.
		 */
		setFromQuaternion( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		}

		/**
		 * Sets the angles of this Euler instance from the given vector.
		 *
		 * @param {Vector3} v - The vector.
		 * @param {string} [order] - A string representing the order that the rotations are applied.
		 * @return {Euler} A reference to this Euler instance.
		 */
		setFromVector3( v, order = this._order ) {

			return this.set( v.x, v.y, v.z, order );

		}

		/**
		 * Resets the euler angle with a new order by creating a quaternion from this
		 * euler angle and then setting this euler angle with the quaternion and the
		 * new order.
		 *
		 * Warning: This discards revolution information.
		 *
		 * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
		 * @return {Euler} A reference to this Euler instance.
		 */
		reorder( newOrder ) {

			_quaternion$1.setFromEuler( this );

			return this.setFromQuaternion( _quaternion$1, newOrder );

		}

		/**
		 * Returns `true` if this Euler instance is equal with the given one.
		 *
		 * @param {Euler} euler - The Euler instance to test for equality.
		 * @return {boolean} Whether this Euler instance is equal with the given one.
		 */
		equals( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		}

		/**
		 * Sets this Euler instance's components to values from the given array. The first three
		 * entries of the array are assign to the x,y and z components. An optional fourth entry
		 * defines the Euler order.
		 *
		 * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
		 * @return {Euler} A reference to this Euler instance.
		 */
		fromArray( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		}

		/**
		 * Writes the components of this Euler instance to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number,number,number,string>} The Euler components.
		 */
		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

		*[ Symbol.iterator ]() {

			yield this._x;
			yield this._y;
			yield this._z;
			yield this._order;

		}

	}

	/**
	 * The default Euler angle order.
	 *
	 * @static
	 * @type {string}
	 * @default 'XYZ'
	 */
	Euler.DEFAULT_ORDER = 'XYZ';

	/**
	 * A layers object assigns an 3D object to 1 or more of 32
	 * layers numbered `0` to `31` - internally the layers are stored as a
	 * bit mask], and by default all 3D objects are a member of layer `0`.
	 *
	 * This can be used to control visibility - an object must share a layer with
	 * a camera to be visible when that camera's view is
	 * rendered.
	 *
	 * All classes that inherit from {@link Object3D} have an `layers` property which
	 * is an instance of this class.
	 */
	class Layers {

		/**
		 * Constructs a new layers instance, with membership
		 * initially set to layer `0`.
		 */
		constructor() {

			/**
			 * A bit mask storing which of the 32 layers this layers object is currently
			 * a member of.
			 *
			 * @type {number}
			 */
			this.mask = 1 | 0;

		}

		/**
		 * Sets membership to the given layer, and remove membership all other layers.
		 *
		 * @param {number} layer - The layer to set.
		 */
		set( layer ) {

			this.mask = ( 1 << layer | 0 ) >>> 0;

		}

		/**
		 * Adds membership of the given layer.
		 *
		 * @param {number} layer - The layer to enable.
		 */
		enable( layer ) {

			this.mask |= 1 << layer | 0;

		}

		/**
		 * Adds membership to all layers.
		 */
		enableAll() {

			this.mask = 0xffffffff | 0;

		}

		/**
		 * Toggles the membership of the given layer.
		 *
		 * @param {number} layer - The layer to toggle.
		 */
		toggle( layer ) {

			this.mask ^= 1 << layer | 0;

		}

		/**
		 * Removes membership of the given layer.
		 *
		 * @param {number} layer - The layer to enable.
		 */
		disable( layer ) {

			this.mask &= ~ ( 1 << layer | 0 );

		}

		/**
		 * Removes the membership from all layers.
		 */
		disableAll() {

			this.mask = 0;

		}

		/**
		 * Returns `true` if this and the given layers object have at least one
		 * layer in common.
		 *
		 * @param {Layers} layers - The layers to test.
		 * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
		 */
		test( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

		/**
		 * Returns `true` if the given layer is enabled.
		 *
		 * @param {number} layer - The layer to test.
		 * @return {boolean } Whether the given layer is enabled or not.
		 */
		isEnabled( layer ) {

			return ( this.mask & ( 1 << layer | 0 ) ) !== 0;

		}

	}

	/**
	 * Represents a 3x3 matrix.
	 *
	 * A Note on Row-Major and Column-Major Ordering:
	 *
	 * The constructor and {@link Matrix3#set} method take arguments in
	 * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
	 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
	 * This means that calling:
	 * ```js
	 * const m = new THREE.Matrix();
	 * m.set( 11, 12, 13,
	 *        21, 22, 23,
	 *        31, 32, 33 );
	 * ```
	 * will result in the elements array containing:
	 * ```js
	 * m.elements = [ 11, 21, 31,
	 *                12, 22, 32,
	 *                13, 23, 33 ];
	 * ```
	 * and internally all calculations are performed using column-major ordering.
	 * However, as the actual ordering makes no difference mathematically and
	 * most people are used to thinking about matrices in row-major order, the
	 * three.js documentation shows matrices in row-major order. Just bear in
	 * mind that if you are reading the source code, you'll have to take the
	 * transpose of any matrices outlined here to make sense of the calculations.
	 */
	class Matrix3 {

		/**
		 * Constructs a new 3x3 matrix. The arguments are supposed to be
		 * in row-major order. If no arguments are provided, the constructor
		 * initializes the matrix as an identity matrix.
		 *
		 * @param {number} [n11] - 1-1 matrix element.
		 * @param {number} [n12] - 1-2 matrix element.
		 * @param {number} [n13] - 1-3 matrix element.
		 * @param {number} [n21] - 2-1 matrix element.
		 * @param {number} [n22] - 2-2 matrix element.
		 * @param {number} [n23] - 2-3 matrix element.
		 * @param {number} [n31] - 3-1 matrix element.
		 * @param {number} [n32] - 3-2 matrix element.
		 * @param {number} [n33] - 3-3 matrix element.
		 */
		constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			Matrix3.prototype.isMatrix3 = true;

			/**
			 * A column-major list of matrix values.
			 *
			 * @type {Array<number>}
			 */
			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( n11 !== undefined ) {

				this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

			}

		}

		/**
		 * Sets the elements of the matrix.The arguments are supposed to be
		 * in row-major order.
		 *
		 * @param {number} [n11] - 1-1 matrix element.
		 * @param {number} [n12] - 1-2 matrix element.
		 * @param {number} [n13] - 1-3 matrix element.
		 * @param {number} [n21] - 2-1 matrix element.
		 * @param {number} [n22] - 2-2 matrix element.
		 * @param {number} [n23] - 2-3 matrix element.
		 * @param {number} [n31] - 3-1 matrix element.
		 * @param {number} [n32] - 3-2 matrix element.
		 * @param {number} [n33] - 3-3 matrix element.
		 * @return {Matrix3} A reference to this matrix.
		 */
		set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		}

		/**
		 * Sets this matrix to the 3x3 identity matrix.
		 *
		 * @return {Matrix3} A reference to this matrix.
		 */
		identity() {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		}

		/**
		 * Copies the values of the given matrix to this instance.
		 *
		 * @param {Matrix3} m - The matrix to copy.
		 * @return {Matrix3} A reference to this matrix.
		 */
		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		}

		/**
		 * Extracts the basis of this matrix into the three axis vectors provided.
		 *
		 * @param {Vector3} xAxis - The basis's x axis.
		 * @param {Vector3} yAxis - The basis's y axis.
		 * @param {Vector3} zAxis - The basis's z axis.
		 * @return {Matrix3} A reference to this matrix.
		 */
		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		}

		/**
		 * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Matrix3} A reference to this matrix.
		 */
		setFromMatrix4( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		}

		/**
		 * Post-multiplies this matrix by the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The matrix to multiply with.
		 * @return {Matrix3} A reference to this matrix.
		 */
		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		/**
		 * Pre-multiplies this matrix by the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The matrix to multiply with.
		 * @return {Matrix3} A reference to this matrix.
		 */
		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		/**
		 * Multiples the given 3x3 matrices and stores the result
		 * in this matrix.
		 *
		 * @param {Matrix3} a - The first matrix.
		 * @param {Matrix3} b - The second matrix.
		 * @return {Matrix3} A reference to this matrix.
		 */
		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		}

		/**
		 * Multiplies every component of the matrix by the given scalar.
		 *
		 * @param {number} s - The scalar.
		 * @return {Matrix3} A reference to this matrix.
		 */
		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		}

		/**
		 * Computes and returns the determinant of this matrix.
		 *
		 * @return {number} The determinant.
		 */
		determinant() {

			const te = this.elements;

			const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		}

		/**
		 * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
		 * You can not invert with a determinant of zero. If you attempt this, the method produces
		 * a zero matrix instead.
		 *
		 * @return {Matrix3} A reference to this matrix.
		 */
		invert() {

			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
				n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
				n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		}

		/**
		 * Transposes this matrix in place.
		 *
		 * @return {Matrix3} A reference to this matrix.
		 */
		transpose() {

			let tmp;
			const m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		}

		/**
		 * Computes the normal matrix which is the inverse transpose of the upper
		 * left 3x3 portion of the given 4x4 matrix.
		 *
		 * @param {Matrix4} matrix4 - The 4x4 matrix.
		 * @return {Matrix3} A reference to this matrix.
		 */
		getNormalMatrix( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).invert().transpose();

		}

		/**
		 * Transposes this matrix into the supplied array, and returns itself unchanged.
		 *
		 * @param {Array<number>} r - An array to store the transposed matrix elements.
		 * @return {Matrix3} A reference to this matrix.
		 */
		transposeIntoArray( r ) {

			const m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		}

		/**
		 * Sets the UV transform matrix from offset, repeat, rotation, and center.
		 *
		 * @param {number} tx - Offset x.
		 * @param {number} ty - Offset y.
		 * @param {number} sx - Repeat x.
		 * @param {number} sy - Repeat y.
		 * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
		 * @param {number} cx - Center x of rotation.
		 * @param {number} cy - Center y of rotation
		 * @return {Matrix3} A reference to this matrix.
		 */
		setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

			const c = Math.cos( rotation );
			const s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

			return this;

		}

		/**
		 * Scales this matrix with the given scalar values.
		 *
		 * @param {number} sx - The amount to scale in the X axis.
		 * @param {number} sy - The amount to scale in the Y axis.
		 * @return {Matrix3} A reference to this matrix.
		 */
		scale( sx, sy ) {

			this.premultiply( _m3.makeScale( sx, sy ) );

			return this;

		}

		/**
		 * Rotates this matrix by the given angle.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix3} A reference to this matrix.
		 */
		rotate( theta ) {

			this.premultiply( _m3.makeRotation( - theta ) );

			return this;

		}

		/**
		 * Translates this matrix by the given scalar values.
		 *
		 * @param {number} tx - The amount to translate in the X axis.
		 * @param {number} ty - The amount to translate in the Y axis.
		 * @return {Matrix3} A reference to this matrix.
		 */
		translate( tx, ty ) {

			this.premultiply( _m3.makeTranslation( tx, ty ) );

			return this;

		}

		// for 2D Transforms

		/**
		 * Sets this matrix as a 2D translation transform.
		 *
		 * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
		 * @param {number} y - The amount to translate in the Y axis.
		 * @return {Matrix3} A reference to this matrix.
		 */
		makeTranslation( x, y ) {

			if ( x.isVector2 ) {

				this.set(

					1, 0, x.x,
					0, 1, x.y,
					0, 0, 1

				);

			} else {

				this.set(

					1, 0, x,
					0, 1, y,
					0, 0, 1

				);

			}

			return this;

		}

		/**
		 * Sets this matrix as a 2D rotational transformation.
		 *
		 * @param {number} theta - The rotation in radians.
		 * @return {Matrix3} A reference to this matrix.
		 */
		makeRotation( theta ) {

			// counterclockwise

			const c = Math.cos( theta );
			const s = Math.sin( theta );

			this.set(

				c, - s, 0,
				s, c, 0,
				0, 0, 1

			);

			return this;

		}

		/**
		 * Sets this matrix as a 2D scale transform.
		 *
		 * @param {number} x - The amount to scale in the X axis.
		 * @param {number} y - The amount to scale in the Y axis.
		 * @return {Matrix3} A reference to this matrix.
		 */
		makeScale( x, y ) {

			this.set(

				x, 0, 0,
				0, y, 0,
				0, 0, 1

			);

			return this;

		}

		/**
		 * Returns `true` if this matrix is equal with the given one.
		 *
		 * @param {Matrix3} matrix - The matrix to test for equality.
		 * @return {boolean} Whether this matrix is equal with the given one.
		 */
		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		/**
		 * Sets the elements of the matrix from the given array.
		 *
		 * @param {Array<number>} array - The matrix elements in column-major order.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Matrix3} A reference to this matrix.
		 */
		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		/**
		 * Writes the elements of this matrix to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The matrix elements in column-major order.
		 */
		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

		/**
		 * Returns a matrix with copied values from this instance.
		 *
		 * @return {Matrix3} A clone of this instance.
		 */
		clone() {

			return new this.constructor().fromArray( this.elements );

		}

	}

	const _m3 = /*@__PURE__*/ new Matrix3();

	let _object3DId = 0;

	const _v1$3 = /*@__PURE__*/ new Vector3();
	const _q1 = /*@__PURE__*/ new Quaternion$1();
	const _m1$3 = /*@__PURE__*/ new Matrix4();
	const _target = /*@__PURE__*/ new Vector3();

	const _position = /*@__PURE__*/ new Vector3();
	const _scale = /*@__PURE__*/ new Vector3();
	const _quaternion = /*@__PURE__*/ new Quaternion$1();

	const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
	const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
	const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

	/**
	 * Fires when the object has been added to its parent object.
	 *
	 * @event Object3D#added
	 * @type {Object}
	 */
	const _addedEvent = { type: 'added' };

	/**
	 * Fires when the object has been removed from its parent object.
	 *
	 * @event Object3D#removed
	 * @type {Object}
	 */
	const _removedEvent = { type: 'removed' };

	/**
	 * Fires when a new child object has been added.
	 *
	 * @event Object3D#childadded
	 * @type {Object}
	 */
	const _childaddedEvent = { type: 'childadded', child: null };

	/**
	 * Fires when a child object has been removed.
	 *
	 * @event Object3D#childremoved
	 * @type {Object}
	 */
	const _childremovedEvent = { type: 'childremoved', child: null };

	/**
	 * This is the base class for most objects in three.js and provides a set of
	 * properties and methods for manipulating objects in 3D space.
	 *
	 * @augments EventDispatcher
	 */
	class Object3D extends EventDispatcher {

		/**
		 * Constructs a new 3D object.
		 */
		constructor() {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isObject3D = true;

			/**
			 * The ID of the 3D object.
			 *
			 * @name Object3D#id
			 * @type {number}
			 * @readonly
			 */
			Object.defineProperty( this, 'id', { value: _object3DId ++ } );

			/**
			 * The UUID of the 3D object.
			 *
			 * @type {string}
			 * @readonly
			 */
			this.uuid = generateUUID();

			/**
			 * The name of the 3D object.
			 *
			 * @type {string}
			 */
			this.name = '';

			/**
			 * The type property is used for detecting the object type
			 * in context of serialization/deserialization.
			 *
			 * @type {string}
			 * @readonly
			 */
			this.type = 'Object3D';

			/**
			 * A reference to the parent object.
			 *
			 * @type {?Object3D}
			 * @default null
			 */
			this.parent = null;

			/**
			 * An array holding the child 3D objects of this instance.
			 *
			 * @type {Array<Object3D>}
			 */
			this.children = [];

			/**
			 * Defines the `up` direction of the 3D object which influences
			 * the orientation via methods like {@link Object3D#lookAt}.
			 *
			 * The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.
			 *
			 * @type {Vector3}
			 */
			this.up = Object3D.DEFAULT_UP.clone();

			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion$1();
			const scale = new Vector3( 1, 1, 1 );

			function onRotationChange() {

				quaternion.setFromEuler( rotation, false );

			}

			function onQuaternionChange() {

				rotation.setFromQuaternion( quaternion, undefined, false );

			}

			rotation._onChange( onRotationChange );
			quaternion._onChange( onQuaternionChange );

			Object.defineProperties( this, {
				/**
				 * Represents the object's local position.
				 *
				 * @name Object3D#position
				 * @type {Vector3}
				 * @default (0,0,0)
				 */
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				/**
				 * Represents the object's local rotation as Euler angles, in radians.
				 *
				 * @name Object3D#rotation
				 * @type {Euler}
				 * @default (0,0,0)
				 */
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				/**
				 * Represents the object's local rotation as Quaternions.
				 *
				 * @name Object3D#quaternion
				 * @type {Quaternion}
				 */
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				/**
				 * Represents the object's local scale.
				 *
				 * @name Object3D#scale
				 * @type {Vector3}
				 * @default (1,1,1)
				 */
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				/**
				 * Represents the object's model-view matrix.
				 *
				 * @name Object3D#modelViewMatrix
				 * @type {Matrix4}
				 */
				modelViewMatrix: {
					value: new Matrix4()
				},
				/**
				 * Represents the object's normal matrix.
				 *
				 * @name Object3D#normalMatrix
				 * @type {Matrix3}
				 */
				normalMatrix: {
					value: new Matrix3()
				}
			} );

			/**
			 * Represents the object's transformation matrix in local space.
			 *
			 * @type {Matrix4}
			 */
			this.matrix = new Matrix4();

			/**
			 * Represents the object's transformation matrix in world space.
			 * If the 3D object has no parent, then it's identical to the local transformation matrix
			 *
			 * @type {Matrix4}
			 */
			this.matrixWorld = new Matrix4();

			/**
			 * When set to `true`, the engine automatically computes the local matrix from position,
			 * rotation and scale every frame.
			 *
			 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

			/**
			 * When set to `true`, the engine automatically computes the world matrix from the current local
			 * matrix and the object's transformation hierarchy.
			 *
			 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

			/**
			 * When set to `true`, it calculates the world matrix in that frame and resets this property
			 * to `false`.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.matrixWorldNeedsUpdate = false;

			/**
			 * The layer membership of the 3D object. The 3D object is only visible if it has
			 * at least one layer in common with the camera in use. This property can also be
			 * used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster}.
			 *
			 * @type {Layers}
			 */
			this.layers = new Layers();

			/**
			 * When set to `true`, the 3D object gets rendered.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.visible = true;

			/**
			 * When set to `true`, the 3D object gets rendered into shadow maps.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.castShadow = false;

			/**
			 * When set to `true`, the 3D object is affected by shadows in the scene.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.receiveShadow = false;

			/**
			 * When set to `true`, the 3D object is honored by view frustum culling.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.frustumCulled = true;

			/**
			 * This value allows the default rendering order of scene graph objects to be
			 * overridden although opaque and transparent objects remain sorted independently.
			 * When this property is set for an instance of {@link Group},all descendants
			 * objects will be sorted and rendered together. Sorting is from lowest to highest
			 * render order.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.renderOrder = 0;

			/**
			 * An array holding the animation clips of the 3D object.
			 *
			 * @type {Array<AnimationClip>}
			 */
			this.animations = [];

			/**
			 * Custom depth material to be used when rendering to the depth map. Can only be used
			 * in context of meshes. When shadow-casting with a {@link DirectionalLight} or {@link SpotLight},
			 * if you are modifying vertex positions in the vertex shader you must specify a custom depth
			 * material for proper shadows.
			 *
			 * Only relevant in context of {@link WebGLRenderer}.
			 *
			 * @type {(Material|undefined)}
			 * @default undefined
			 */
			this.customDepthMaterial = undefined;

			/**
			 * Same as {@link Object3D#customDepthMaterial}, but used with {@link PointLight}.
			 *
			 * Only relevant in context of {@link WebGLRenderer}.
			 *
			 * @type {(Material|undefined)}
			 * @default undefined
			 */
			this.customDistanceMaterial = undefined;

			/**
			 * An object that can be used to store custom data about the 3D object. It
			 * should not hold references to functions as these will not be cloned.
			 *
			 * @type {Object}
			 */
			this.userData = {};

		}

		/**
		 * A callback that is executed immediately before a 3D object is rendered to a shadow map.
		 *
		 * @param {Renderer|WebGLRenderer} renderer - The renderer.
		 * @param {Object3D} object - The 3D object.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {Camera} shadowCamera - The shadow camera.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Material} depthMaterial - The depth material.
		 * @param {Object} group - The geometry group data.
		 */
		onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

		/**
		 * A callback that is executed immediately after a 3D object is rendered to a shadow map.
		 *
		 * @param {Renderer|WebGLRenderer} renderer - The renderer.
		 * @param {Object3D} object - The 3D object.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {Camera} shadowCamera - The shadow camera.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Material} depthMaterial - The depth material.
		 * @param {Object} group - The geometry group data.
		 */
		onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

		/**
		 * A callback that is executed immediately before a 3D object is rendered.
		 *
		 * @param {Renderer|WebGLRenderer} renderer - The renderer.
		 * @param {Object3D} object - The 3D object.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Material} material - The 3D object's material.
		 * @param {Object} group - The geometry group data.
		 */
		onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		/**
		 * A callback that is executed immediately after a 3D object is rendered.
		 *
		 * @param {Renderer|WebGLRenderer} renderer - The renderer.
		 * @param {Object3D} object - The 3D object.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Material} material - The 3D object's material.
		 * @param {Object} group - The geometry group data.
		 */
		onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		/**
		 * Applies the given transformation matrix to the object and updates the object's position,
		 * rotation and scale.
		 *
		 * @param {Matrix4} matrix - The transformation matrix.
		 */
		applyMatrix4( matrix ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			this.matrix.premultiply( matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		}

		/**
		 * Applies a rotation represented by given the quaternion to the 3D object.
		 *
		 * @param {Quaternion} q - The quaternion.
		 * @return {Object3D} A reference to this instance.
		 */
		applyQuaternion( q ) {

			this.quaternion.premultiply( q );

			return this;

		}

		/**
		 * Sets the given rotation represented as an axis/angle couple to the 3D object.
		 *
		 * @param {Vector3} axis - The (normalized) axis vector.
		 * @param {number} angle - The angle in radians.
		 */
		setRotationFromAxisAngle( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		}

		/**
		 * Sets the given rotation represented as Euler angles to the 3D object.
		 *
		 * @param {Euler} euler - The Euler angles.
		 */
		setRotationFromEuler( euler ) {

			this.quaternion.setFromEuler( euler, true );

		}

		/**
		 * Sets the given rotation represented as rotation matrix to the 3D object.
		 *
		 * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
		 * a pure rotation matrix (i.e, unscaled).
		 */
		setRotationFromMatrix( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		}

		/**
		 * Sets the given rotation represented as a Quaternion to the 3D object.
		 *
		 * @param {Quaternion} q - The Quaternion
		 */
		setRotationFromQuaternion( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		}

		/**
		 * Rotates the 3D object along an axis in local space.
		 *
		 * @param {Vector3} axis - The (normalized) axis vector.
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */
		rotateOnAxis( axis, angle ) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( _q1 );

			return this;

		}

		/**
		 * Rotates the 3D object along an axis in world space.
		 *
		 * @param {Vector3} axis - The (normalized) axis vector.
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */
		rotateOnWorldAxis( axis, angle ) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( _q1 );

			return this;

		}

		/**
		 * Rotates the 3D object around its X axis in local space.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */
		rotateX( angle ) {

			return this.rotateOnAxis( _xAxis, angle );

		}

		/**
		 * Rotates the 3D object around its Y axis in local space.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */
		rotateY( angle ) {

			return this.rotateOnAxis( _yAxis, angle );

		}

		/**
		 * Rotates the 3D object around its Z axis in local space.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {Object3D} A reference to this instance.
		 */
		rotateZ( angle ) {

			return this.rotateOnAxis( _zAxis, angle );

		}

		/**
		 * Translate the 3D object by a distance along the given axis in local space.
		 *
		 * @param {Vector3} axis - The (normalized) axis vector.
		 * @param {number} distance - The distance in world units.
		 * @return {Object3D} A reference to this instance.
		 */
		translateOnAxis( axis, distance ) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$3.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( _v1$3.multiplyScalar( distance ) );

			return this;

		}

		/**
		 * Translate the 3D object by a distance along its X-axis in local space.
		 *
		 * @param {number} distance - The distance in world units.
		 * @return {Object3D} A reference to this instance.
		 */
		translateX( distance ) {

			return this.translateOnAxis( _xAxis, distance );

		}

		/**
		 * Translate the 3D object by a distance along its Y-axis in local space.
		 *
		 * @param {number} distance - The distance in world units.
		 * @return {Object3D} A reference to this instance.
		 */
		translateY( distance ) {

			return this.translateOnAxis( _yAxis, distance );

		}

		/**
		 * Translate the 3D object by a distance along its Z-axis in local space.
		 *
		 * @param {number} distance - The distance in world units.
		 * @return {Object3D} A reference to this instance.
		 */
		translateZ( distance ) {

			return this.translateOnAxis( _zAxis, distance );

		}

		/**
		 * Converts the given vector from this 3D object's local space to world space.
		 *
		 * @param {Vector3} vector - The vector to convert.
		 * @return {Vector3} The converted vector.
		 */
		localToWorld( vector ) {

			this.updateWorldMatrix( true, false );

			return vector.applyMatrix4( this.matrixWorld );

		}

		/**
		 * Converts the given vector from this 3D object's word space to local space.
		 *
		 * @param {Vector3} vector - The vector to convert.
		 * @return {Vector3} The converted vector.
		 */
		worldToLocal( vector ) {

			this.updateWorldMatrix( true, false );

			return vector.applyMatrix4( _m1$3.copy( this.matrixWorld ).invert() );

		}

		/**
		 * Rotates the object to face a point in world space.
		 *
		 * This method does not support objects having non-uniformly-scaled parent(s).
		 *
		 * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
		 * @param {number} [y] - The y coordinate in world space.
		 * @param {number} [z] - The z coordinate in world space.
		 */
		lookAt( x, y, z ) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if ( x.isVector3 ) {

				_target.copy( x );

			} else {

				_target.set( x, y, z );

			}

			const parent = this.parent;

			this.updateWorldMatrix( true, false );

			_position.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || this.isLight ) {

				_m1$3.lookAt( _position, _target, this.up );

			} else {

				_m1$3.lookAt( _target, _position, this.up );

			}

			this.quaternion.setFromRotationMatrix( _m1$3 );

			if ( parent ) {

				_m1$3.extractRotation( parent.matrixWorld );
				_q1.setFromRotationMatrix( _m1$3 );
				this.quaternion.premultiply( _q1.invert() );

			}

		}

		/**
		 * Adds the given 3D object as a child to this 3D object. An arbitrary number of
		 * objects may be added. Any current parent on an object passed in here will be
		 * removed, since an object can have at most one parent.
		 *
		 * @fires Object3D#added
		 * @fires Object3D#childadded
		 * @param {Object3D} object - The 3D object to add.
		 * @return {Object3D} A reference to this instance.
		 */
		add( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				error( 'Object3D.add: object can\'t be added as a child of itself.', object );
				return this;

			}

			if ( object && object.isObject3D ) {

				object.removeFromParent();
				object.parent = this;
				this.children.push( object );

				object.dispatchEvent( _addedEvent );

				_childaddedEvent.child = object;
				this.dispatchEvent( _childaddedEvent );
				_childaddedEvent.child = null;

			} else {

				error( 'Object3D.add: object not an instance of THREE.Object3D.', object );

			}

			return this;

		}

		/**
		 * Removes the given 3D object as child from this 3D object.
		 * An arbitrary number of objects may be removed.
		 *
		 * @fires Object3D#removed
		 * @fires Object3D#childremoved
		 * @param {Object3D} object - The 3D object to remove.
		 * @return {Object3D} A reference to this instance.
		 */
		remove( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			const index = this.children.indexOf( object );

			if ( index !== -1 ) {

				object.parent = null;
				this.children.splice( index, 1 );

				object.dispatchEvent( _removedEvent );

				_childremovedEvent.child = object;
				this.dispatchEvent( _childremovedEvent );
				_childremovedEvent.child = null;

			}

			return this;

		}

		/**
		 * Removes this 3D object from its current parent.
		 *
		 * @fires Object3D#removed
		 * @fires Object3D#childremoved
		 * @return {Object3D} A reference to this instance.
		 */
		removeFromParent() {

			const parent = this.parent;

			if ( parent !== null ) {

				parent.remove( this );

			}

			return this;

		}

		/**
		 * Removes all child objects.
		 *
		 * @fires Object3D#removed
		 * @fires Object3D#childremoved
		 * @return {Object3D} A reference to this instance.
		 */
		clear() {

			return this.remove( ... this.children );

		}

		/**
		 * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
		 * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
		 *
		 * @fires Object3D#added
		 * @fires Object3D#childadded
		 * @param {Object3D} object - The 3D object to attach.
		 * @return {Object3D} A reference to this instance.
		 */
		attach( object ) {

			// adds object as a child of this, while maintaining the object's world transform

			// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

			this.updateWorldMatrix( true, false );

			_m1$3.copy( this.matrixWorld ).invert();

			if ( object.parent !== null ) {

				object.parent.updateWorldMatrix( true, false );

				_m1$3.multiply( object.parent.matrixWorld );

			}

			object.applyMatrix4( _m1$3 );

			object.removeFromParent();
			object.parent = this;
			this.children.push( object );

			object.updateWorldMatrix( false, true );

			object.dispatchEvent( _addedEvent );

			_childaddedEvent.child = object;
			this.dispatchEvent( _childaddedEvent );
			_childaddedEvent.child = null;

			return this;

		}

		/**
		 * Searches through the 3D object and its children, starting with the 3D object
		 * itself, and returns the first with a matching ID.
		 *
		 * @param {number} id - The id.
		 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
		 */
		getObjectById( id ) {

			return this.getObjectByProperty( 'id', id );

		}

		/**
		 * Searches through the 3D object and its children, starting with the 3D object
		 * itself, and returns the first with a matching name.
		 *
		 * @param {string} name - The name.
		 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
		 */
		getObjectByName( name ) {

			return this.getObjectByProperty( 'name', name );

		}

		/**
		 * Searches through the 3D object and its children, starting with the 3D object
		 * itself, and returns the first with a matching property value.
		 *
		 * @param {string} name - The name of the property.
		 * @param {any} value - The value.
		 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
		 */
		getObjectByProperty( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( let i = 0, l = this.children.length; i < l; i ++ ) {

				const child = this.children[ i ];
				const object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		}

		/**
		 * Searches through the 3D object and its children, starting with the 3D object
		 * itself, and returns all 3D objects with a matching property value.
		 *
		 * @param {string} name - The name of the property.
		 * @param {any} value - The value.
		 * @param {Array<Object3D>} result - The method stores the result in this array.
		 * @return {Array<Object3D>} The found 3D objects.
		 */
		getObjectsByProperty( name, value, result = [] ) {

			if ( this[ name ] === value ) result.push( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].getObjectsByProperty( name, value, result );

			}

			return result;

		}

		/**
		 * Returns a vector representing the position of the 3D object in world space.
		 *
		 * @param {Vector3} target - The target vector the result is stored to.
		 * @return {Vector3} The 3D object's position in world space.
		 */
		getWorldPosition( target ) {

			this.updateWorldMatrix( true, false );

			return target.setFromMatrixPosition( this.matrixWorld );

		}

		/**
		 * Returns a Quaternion representing the position of the 3D object in world space.
		 *
		 * @param {Quaternion} target - The target Quaternion the result is stored to.
		 * @return {Quaternion} The 3D object's rotation in world space.
		 */
		getWorldQuaternion( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position, target, _scale );

			return target;

		}

		/**
		 * Returns a vector representing the scale of the 3D object in world space.
		 *
		 * @param {Vector3} target - The target vector the result is stored to.
		 * @return {Vector3} The 3D object's scale in world space.
		 */
		getWorldScale( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position, _quaternion, target );

			return target;

		}

		/**
		 * Returns a vector representing the ("look") direction of the 3D object in world space.
		 *
		 * @param {Vector3} target - The target vector the result is stored to.
		 * @return {Vector3} The 3D object's direction in world space.
		 */
		getWorldDirection( target ) {

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		}

		/**
		 * Abstract method to get intersections between a casted ray and this
		 * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
		 * implement this method in order to use raycasting.
		 *
		 * @abstract
		 * @param {Raycaster} raycaster - The raycaster.
		 * @param {Array<Object>} intersects - An array holding the result of the method.
		 */
		raycast( /* raycaster, intersects */ ) {}

		/**
		 * Executes the callback on this 3D object and all descendants.
		 *
		 * Note: Modifying the scene graph inside the callback is discouraged.
		 *
		 * @param {Function} callback - A callback function that allows to process the current 3D object.
		 */
		traverse( callback ) {

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		}

		/**
		 * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
		 * Descendants of invisible 3D objects are not traversed.
		 *
		 * Note: Modifying the scene graph inside the callback is discouraged.
		 *
		 * @param {Function} callback - A callback function that allows to process the current 3D object.
		 */
		traverseVisible( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		}

		/**
		 * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
		 *
		 * Note: Modifying the scene graph inside the callback is discouraged.
		 *
		 * @param {Function} callback - A callback function that allows to process the current 3D object.
		 */
		traverseAncestors( callback ) {

			const parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		}

		/**
		 * Updates the transformation matrix in local space by computing it from the current
		 * position, rotation and scale values.
		 */
		updateMatrix() {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		}

		/**
		 * Updates the transformation matrix in world space of this 3D objects and its descendants.
		 *
		 * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
		 * local space. The computation of the local and world matrix can be controlled with the
		 * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
		 * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
		 *
		 * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
		 * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
		 */
		updateMatrixWorld( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.matrixWorldAutoUpdate === true ) {

					if ( this.parent === null ) {

						this.matrixWorld.copy( this.matrix );

					} else {

						this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

					}

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// make sure descendants are updated if required

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				child.updateMatrixWorld( force );

			}

		}

		/**
		 * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
		 * update of ancestor and descendant nodes.
		 *
		 * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
		 * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
		 */
		updateWorldMatrix( updateParents, updateChildren ) {

			const parent = this.parent;

			if ( updateParents === true && parent !== null ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldAutoUpdate === true ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

			}

			// make sure descendants are updated

			if ( updateChildren === true ) {

				const children = this.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					const child = children[ i ];

					child.updateWorldMatrix( false, true );

				}

			}

		}

		/**
		 * Serializes the 3D object into JSON.
		 *
		 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
		 * @return {Object} A JSON object representing the serialized 3D object.
		 * @see {@link ObjectLoader#parse}
		 */
		toJSON( meta ) {

			// meta is a string when called from JSON.stringify
			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			const output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {},
					nodes: {}
				};

				output.metadata = {
					version: 4.7,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			const object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			object.up = this.up.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			// object specific properties

			if ( this.isInstancedMesh ) {

				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

			}

			if ( this.isBatchedMesh ) {

				object.type = 'BatchedMesh';
				object.perObjectFrustumCulled = this.perObjectFrustumCulled;
				object.sortObjects = this.sortObjects;

				object.drawRanges = this._drawRanges;
				object.reservedRanges = this._reservedRanges;

				object.geometryInfo = this._geometryInfo.map( info => ( {
					...info,
					boundingBox: info.boundingBox ? info.boundingBox.toJSON() : undefined,
					boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : undefined
				} ) );
				object.instanceInfo = this._instanceInfo.map( info => ( { ...info } ) );

				object.availableInstanceIds = this._availableInstanceIds.slice();
				object.availableGeometryIds = this._availableGeometryIds.slice();

				object.nextIndexStart = this._nextIndexStart;
				object.nextVertexStart = this._nextVertexStart;
				object.geometryCount = this._geometryCount;

				object.maxInstanceCount = this._maxInstanceCount;
				object.maxVertexCount = this._maxVertexCount;
				object.maxIndexCount = this._maxIndexCount;

				object.geometryInitialized = this._geometryInitialized;

				object.matricesTexture = this._matricesTexture.toJSON( meta );

				object.indirectTexture = this._indirectTexture.toJSON( meta );

				if ( this._colorsTexture !== null ) {

					object.colorsTexture = this._colorsTexture.toJSON( meta );

				}

				if ( this.boundingSphere !== null ) {

					object.boundingSphere = this.boundingSphere.toJSON();

				}

				if ( this.boundingBox !== null ) {

					object.boundingBox = this.boundingBox.toJSON();

				}

			}

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isScene ) {

				if ( this.background ) {

					if ( this.background.isColor ) {

						object.background = this.background.toJSON();

					} else if ( this.background.isTexture ) {

						object.background = this.background.toJSON( meta ).uuid;

					}

				}

				if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

					object.environment = this.environment.toJSON( meta ).uuid;

				}

			} else if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				const parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					const shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( let i = 0, l = shapes.length; i < l; i ++ ) {

							const shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.isSkinnedMesh ) {

				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if ( this.skeleton !== undefined ) {

					serialize( meta.skeletons, this.skeleton );

					object.skeleton = this.skeleton.uuid;

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					const uuids = [];

					for ( let i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( let i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			//

			if ( this.animations.length > 0 ) {

				object.animations = [];

				for ( let i = 0; i < this.animations.length; i ++ ) {

					const animation = this.animations[ i ];

					object.animations.push( serialize( meta.animations, animation ) );

				}

			}

			if ( isRootObject ) {

				const geometries = extractFromCache( meta.geometries );
				const materials = extractFromCache( meta.materials );
				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );
				const shapes = extractFromCache( meta.shapes );
				const skeletons = extractFromCache( meta.skeletons );
				const animations = extractFromCache( meta.animations );
				const nodes = extractFromCache( meta.nodes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;
				if ( skeletons.length > 0 ) output.skeletons = skeletons;
				if ( animations.length > 0 ) output.animations = animations;
				if ( nodes.length > 0 ) output.nodes = nodes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				const values = [];
				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

		}

		/**
		 * Returns a new 3D object with copied values from this instance.
		 *
		 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
		 * @return {Object3D} A clone of this instance.
		 */
		clone( recursive ) {

			return new this.constructor().copy( this, recursive );

		}

		/**
		 * Copies the values of the given 3D object to this instance.
		 *
		 * @param {Object3D} source - The 3D object to copy.
		 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
		 * @return {Object3D} A reference to this instance.
		 */
		copy( source, recursive = true ) {

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.rotation.order = source.rotation.order;
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;

			this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.animations = source.animations.slice();

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( let i = 0; i < source.children.length; i ++ ) {

					const child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	}

	/**
	 * The default up direction for objects, also used as the default
	 * position for {@link DirectionalLight} and {@link HemisphereLight}.
	 *
	 * @static
	 * @type {Vector3}
	 * @default (0,1,0)
	 */
	Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );

	/**
	 * The default setting for {@link Object3D#matrixAutoUpdate} for
	 * newly created 3D objects.
	 *
	 * @static
	 * @type {boolean}
	 * @default true
	 */
	Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;

	/**
	 * The default setting for {@link Object3D#matrixWorldAutoUpdate} for
	 * newly created 3D objects.
	 *
	 * @static
	 * @type {boolean}
	 * @default true
	 */
	Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

	/**
	 * Scenes allow you to set up what is to be rendered and where by three.js.
	 * This is where you place 3D objects like meshes, lines or lights.
	 *
	 * @augments Object3D
	 */
	class Scene extends Object3D {

		/**
		 * Constructs a new scene.
		 */
		constructor() {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isScene = true;

			this.type = 'Scene';

			/**
			 * Defines the background of the scene. Valid inputs are:
			 *
			 * - A color for defining a uniform colored background.
			 * - A texture for defining a (flat) textured background.
			 * - Cube textures or equirectangular textures for defining a skybox.
			 *
			 * @type {?(Color|Texture)}
			 * @default null
			 */
			this.background = null;

			/**
			 * Sets the environment map for all physical materials in the scene. However,
			 * it's not possible to overwrite an existing texture assigned to the `envMap`
			 * material property.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.environment = null;

			/**
			 * A fog instance defining the type of fog that affects everything
			 * rendered in the scene.
			 *
			 * @type {?(Fog|FogExp2)}
			 * @default null
			 */
			this.fog = null;

			/**
			 * Sets the blurriness of the background. Only influences environment maps
			 * assigned to {@link Scene#background}. Valid input is a float between `0`
			 * and `1`.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.backgroundBlurriness = 0;

			/**
			 * Attenuates the color of the background. Only applies to background textures.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.backgroundIntensity = 1;

			/**
			 * The rotation of the background in radians. Only influences environment maps
			 * assigned to {@link Scene#background}.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */
			this.backgroundRotation = new Euler();

			/**
			 * Attenuates the color of the environment. Only influences environment maps
			 * assigned to {@link Scene#environment}.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.environmentIntensity = 1;

			/**
			 * The rotation of the environment map in radians. Only influences physical materials
			 * in the scene when {@link Scene#environment} is used.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */
			this.environmentRotation = new Euler();

			/**
			 * Forces everything in the scene to be rendered with the defined material. It is possible
			 * to exclude materials from override by setting {@link Material#allowOverride} to `false`.
			 *
			 * @type {?Material}
			 * @default null
			 */
			this.overrideMaterial = null;

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

			}

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.environment !== null ) this.environment = source.environment.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();

			this.backgroundBlurriness = source.backgroundBlurriness;
			this.backgroundIntensity = source.backgroundIntensity;
			this.backgroundRotation.copy( source.backgroundRotation );

			this.environmentIntensity = source.environmentIntensity;
			this.environmentRotation.copy( source.environmentRotation );

			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
			if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
			data.object.backgroundRotation = this.backgroundRotation.toArray();

			if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
			data.object.environmentRotation = this.environmentRotation.toArray();

			return data;

		}

	}

	const LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(
		0.4123908, 0.3575843, 0.1804808,
		0.2126390, 0.7151687, 0.0721923,
		0.0193308, 0.1191948, 0.9505322
	);

	const XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(
		3.2409699, -1.5373832, -0.4986108,
		-0.9692436, 1.8759675, 0.0415551,
		0.0556301, -0.203977, 1.0569715
	);

	function createColorManagement() {

		const ColorManagement = {

			enabled: true,

			workingColorSpace: LinearSRGBColorSpace,

			/**
			 * Implementations of supported color spaces.
			 *
			 * Required:
			 *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
			 *	- whitePoint: reference white [ x y ]
			 *	- transfer: transfer function (pre-defined)
			 *	- toXYZ: Matrix3 RGB to XYZ transform
			 *	- fromXYZ: Matrix3 XYZ to RGB transform
			 *	- luminanceCoefficients: RGB luminance coefficients
			 *
			 * Optional:
			 *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: 'extended' | 'standard' }
			 *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
			 *
			 * Reference:
			 * - https://www.russellcottrell.com/photo/matrixCalculator.htm
			 */
			spaces: {},

			convert: function ( color, sourceColorSpace, targetColorSpace ) {

				if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

					return color;

				}

				if ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {

					color.r = SRGBToLinear( color.r );
					color.g = SRGBToLinear( color.g );
					color.b = SRGBToLinear( color.b );

				}

				if ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {

					color.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );
					color.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );

				}

				if ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {

					color.r = LinearToSRGB( color.r );
					color.g = LinearToSRGB( color.g );
					color.b = LinearToSRGB( color.b );

				}

				return color;

			},

			workingToColorSpace: function ( color, targetColorSpace ) {

				return this.convert( color, this.workingColorSpace, targetColorSpace );

			},

			colorSpaceToWorking: function ( color, sourceColorSpace ) {

				return this.convert( color, sourceColorSpace, this.workingColorSpace );

			},

			getPrimaries: function ( colorSpace ) {

				return this.spaces[ colorSpace ].primaries;

			},

			getTransfer: function ( colorSpace ) {

				if ( colorSpace === NoColorSpace ) return LinearTransfer;

				return this.spaces[ colorSpace ].transfer;

			},

			getToneMappingMode: function ( colorSpace ) {

				return this.spaces[ colorSpace ].outputColorSpaceConfig.toneMappingMode || 'standard';

			},

			getLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {

				return target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );

			},

			define: function ( colorSpaces ) {

				Object.assign( this.spaces, colorSpaces );

			},

			// Internal APIs

			_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {

				return targetMatrix
					.copy( this.spaces[ sourceColorSpace ].toXYZ )
					.multiply( this.spaces[ targetColorSpace ].fromXYZ );

			},

			_getDrawingBufferColorSpace: function ( colorSpace ) {

				return this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;

			},

			_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {

				return this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;

			},

			// Deprecated

			fromWorkingColorSpace: function ( color, targetColorSpace ) {

				warnOnce( 'ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().' ); // @deprecated, r177

				return ColorManagement.workingToColorSpace( color, targetColorSpace );

			},

			toWorkingColorSpace: function ( color, sourceColorSpace ) {

				warnOnce( 'ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().' ); // @deprecated, r177

				return ColorManagement.colorSpaceToWorking( color, sourceColorSpace );

			},

		};

		/******************************************************************************
		 * sRGB definitions
		 */

		const REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];
		const REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];
		const D65 = [ 0.3127, 0.3290 ];

		ColorManagement.define( {

			[ LinearSRGBColorSpace ]: {
				primaries: REC709_PRIMARIES,
				whitePoint: D65,
				transfer: LinearTransfer,
				toXYZ: LINEAR_REC709_TO_XYZ,
				fromXYZ: XYZ_TO_LINEAR_REC709,
				luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
				workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
				outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
			},

			[ SRGBColorSpace ]: {
				primaries: REC709_PRIMARIES,
				whitePoint: D65,
				transfer: SRGBTransfer,
				toXYZ: LINEAR_REC709_TO_XYZ,
				fromXYZ: XYZ_TO_LINEAR_REC709,
				luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
				outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
			},

		} );

		return ColorManagement;

	}

	const ColorManagement = /*@__PURE__*/ createColorManagement();

	function SRGBToLinear( c ) {

		return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

	}

	function LinearToSRGB( c ) {

		return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

	}

	const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	const _hslA = { h: 0, s: 0, l: 0 };
	const _hslB = { h: 0, s: 0, l: 0 };

	function hue2rgb( p, q, t ) {

		if ( t < 0 ) t += 1;
		if ( t > 1 ) t -= 1;
		if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
		if ( t < 1 / 2 ) return q;
		if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
		return p;

	}

	/**
	 * A Color instance is represented by RGB components in the linear <i>working
	 * color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs
	 * conventionally using `SRGBColorSpace` (such as hexadecimals and CSS
	 * strings) are converted to the working color space automatically.
	 *
	 * ```js
	 * // converted automatically from SRGBColorSpace to LinearSRGBColorSpace
	 * const color = new THREE.Color().setHex( 0x112233 );
	 * ```
	 * Source color spaces may be specified explicitly, to ensure correct conversions.
	 * ```js
	 * // assumed already LinearSRGBColorSpace; no conversion
	 * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );
	 *
	 * // converted explicitly from SRGBColorSpace to LinearSRGBColorSpace
	 * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );
	 * ```
	 * If THREE.ColorManagement is disabled, no conversions occur. For details,
	 * see <i>Color management</i>. Iterating through a Color instance will yield
	 * its components (r, g, b) in the corresponding order. A Color can be initialised
	 * in any of the following ways:
	 * ```js
	 * //empty constructor - will default white
	 * const color1 = new THREE.Color();
	 *
	 * //Hexadecimal color (recommended)
	 * const color2 = new THREE.Color( 0xff0000 );
	 *
	 * //RGB string
	 * const color3 = new THREE.Color("rgb(255, 0, 0)");
	 * const color4 = new THREE.Color("rgb(100%, 0%, 0%)");
	 *
	 * //X11 color name - all 140 color names are supported.
	 * //Note the lack of CamelCase in the name
	 * const color5 = new THREE.Color( 'skyblue' );
	 * //HSL string
	 * const color6 = new THREE.Color("hsl(0, 100%, 50%)");
	 *
	 * //Separate RGB values between 0 and 1
	 * const color7 = new THREE.Color( 1, 0, 0 );
	 * ```
	 */
	class Color {

		/**
		 * Constructs a new color.
		 *
		 * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
		 * and that method is used throughout the rest of the documentation.
		 *
		 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
		 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
		 * @param {number} [g] - The green component.
		 * @param {number} [b] - The blue component.
		 */
		constructor( r, g, b ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isColor = true;

			/**
			 * The red component.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.r = 1;

			/**
			 * The green component.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.g = 1;

			/**
			 * The blue component.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.b = 1;

			return this.set( r, g, b );

		}

		/**
		 * Sets the colors's components from the given values.
		 *
		 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
		 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
		 * @param {number} [g] - The green component.
		 * @param {number} [b] - The blue component.
		 * @return {Color} A reference to this color.
		 */
		set( r, g, b ) {

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string

				const value = r;

				if ( value && value.isColor ) {

					this.copy( value );

				} else if ( typeof value === 'number' ) {

					this.setHex( value );

				} else if ( typeof value === 'string' ) {

					this.setStyle( value );

				}

			} else {

				this.setRGB( r, g, b );

			}

			return this;

		}

		/**
		 * Sets the colors's components to the given scalar value.
		 *
		 * @param {number} scalar - The scalar value.
		 * @return {Color} A reference to this color.
		 */
		setScalar( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		}

		/**
		 * Sets this color from a hexadecimal value.
		 *
		 * @param {number} hex - The hexadecimal value.
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */
		setHex( hex, colorSpace = SRGBColorSpace ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			ColorManagement.colorSpaceToWorking( this, colorSpace );

			return this;

		}

		/**
		 * Sets this color from RGB values.
		 *
		 * @param {number} r - Red channel value between `0.0` and `1.0`.
		 * @param {number} g - Green channel value between `0.0` and `1.0`.
		 * @param {number} b - Blue channel value between `0.0` and `1.0`.
		 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */
		setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

			this.r = r;
			this.g = g;
			this.b = b;

			ColorManagement.colorSpaceToWorking( this, colorSpace );

			return this;

		}

		/**
		 * Sets this color from RGB values.
		 *
		 * @param {number} h - Hue value between `0.0` and `1.0`.
		 * @param {number} s - Saturation value between `0.0` and `1.0`.
		 * @param {number} l - Lightness value between `0.0` and `1.0`.
		 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */
		setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo( h, 1 );
			s = clamp( s, 0, 1 );
			l = clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				const q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			ColorManagement.colorSpaceToWorking( this, colorSpace );

			return this;

		}

		/**
		 * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
		 * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
		 * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
		 * all 140 color names are supported).
		 *
		 * @param {string} style - Color as a CSS-style string.
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */
		setStyle( style, colorSpace = SRGBColorSpace ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					warn( 'Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			let m;

			if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				let color;
				const name = m[ 1 ];
				const components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)

							handleAlpha( color[ 4 ] );

							return this.setRGB(
								Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
								Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
								Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
								colorSpace
							);

						}

						if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

							handleAlpha( color[ 4 ] );

							return this.setRGB(
								Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
								Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
								Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
								colorSpace
							);

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

							handleAlpha( color[ 4 ] );

							return this.setHSL(
								parseFloat( color[ 1 ] ) / 360,
								parseFloat( color[ 2 ] ) / 100,
								parseFloat( color[ 3 ] ) / 100,
								colorSpace
							);

						}

						break;

					default:

						warn( 'Color: Unknown color model ' + style );

				}

			} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

				// hex color

				const hex = m[ 1 ];
				const size = hex.length;

				if ( size === 3 ) {

					// #ff0
					return this.setRGB(
						parseInt( hex.charAt( 0 ), 16 ) / 15,
						parseInt( hex.charAt( 1 ), 16 ) / 15,
						parseInt( hex.charAt( 2 ), 16 ) / 15,
						colorSpace
					);

				} else if ( size === 6 ) {

					// #ff0000
					return this.setHex( parseInt( hex, 16 ), colorSpace );

				} else {

					warn( 'Color: Invalid hex color ' + style );

				}

			} else if ( style && style.length > 0 ) {

				return this.setColorName( style, colorSpace );

			}

			return this;

		}

		/**
		 * Sets this color from a color name. Faster than {@link Color#setStyle} if
		 * you don't need the other CSS-style formats.
		 *
		 * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
		 * ```js
		 * Color.NAMES.aliceblue // returns 0xF0F8FF
		 * ```
		 *
		 * @param {string} style - The color name.
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {Color} A reference to this color.
		 */
		setColorName( style, colorSpace = SRGBColorSpace ) {

			// color keywords
			const hex = _colorKeywords[ style.toLowerCase() ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex, colorSpace );

			} else {

				// unknown color
				warn( 'Color: Unknown color ' + style );

			}

			return this;

		}

		/**
		 * Returns a new color with copied values from this instance.
		 *
		 * @return {Color} A clone of this instance.
		 */
		clone() {

			return new this.constructor( this.r, this.g, this.b );

		}

		/**
		 * Copies the values of the given color to this instance.
		 *
		 * @param {Color} color - The color to copy.
		 * @return {Color} A reference to this color.
		 */
		copy( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		}

		/**
		 * Copies the given color into this color, and then converts this color from
		 * `SRGBColorSpace` to `LinearSRGBColorSpace`.
		 *
		 * @param {Color} color - The color to copy/convert.
		 * @return {Color} A reference to this color.
		 */
		copySRGBToLinear( color ) {

			this.r = SRGBToLinear( color.r );
			this.g = SRGBToLinear( color.g );
			this.b = SRGBToLinear( color.b );

			return this;

		}

		/**
		 * Copies the given color into this color, and then converts this color from
		 * `LinearSRGBColorSpace` to `SRGBColorSpace`.
		 *
		 * @param {Color} color - The color to copy/convert.
		 * @return {Color} A reference to this color.
		 */
		copyLinearToSRGB( color ) {

			this.r = LinearToSRGB( color.r );
			this.g = LinearToSRGB( color.g );
			this.b = LinearToSRGB( color.b );

			return this;

		}

		/**
		 * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
		 *
		 * @return {Color} A reference to this color.
		 */
		convertSRGBToLinear() {

			this.copySRGBToLinear( this );

			return this;

		}

		/**
		 * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
		 *
		 * @return {Color} A reference to this color.
		 */
		convertLinearToSRGB() {

			this.copyLinearToSRGB( this );

			return this;

		}

		/**
		 * Returns the hexadecimal value of this color.
		 *
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {number} The hexadecimal value.
		 */
		getHex( colorSpace = SRGBColorSpace ) {

			ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

			return Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );

		}

		/**
		 * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
		 *
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {string} The hexadecimal value as a string.
		 */
		getHexString( colorSpace = SRGBColorSpace ) {

			return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( -6 );

		}

		/**
		 * Converts the colors RGB values into the HSL format and stores them into the
		 * given target object.
		 *
		 * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
		 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
		 * @return {{h:number,s:number,l:number}} The HSL representation of this color.
		 */
		getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0

			ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

			const r = _color.r, g = _color.g, b = _color.b;

			const max = Math.max( r, g, b );
			const min = Math.min( r, g, b );

			let hue, saturation;
			const lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				const delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		}

		/**
		 * Returns the RGB values of this color and stores them into the given target object.
		 *
		 * @param {Color} target - The target color that is used to store the method's result.
		 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
		 * @return {Color} The RGB representation of this color.
		 */
		getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

			ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

			target.r = _color.r;
			target.g = _color.g;
			target.b = _color.b;

			return target;

		}

		/**
		 * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
		 *
		 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
		 * @return {string} The CSS representation of this color.
		 */
		getStyle( colorSpace = SRGBColorSpace ) {

			ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

			const r = _color.r, g = _color.g, b = _color.b;

			if ( colorSpace !== SRGBColorSpace ) {

				// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
				return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

			}

			return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

		}

		/**
		 * Adds the given HSL values to this color's values.
		 * Internally, this converts the color's RGB values to HSL, adds HSL
		 * and then converts the color back to RGB.
		 *
		 * @param {number} h - Hue value between `0.0` and `1.0`.
		 * @param {number} s - Saturation value between `0.0` and `1.0`.
		 * @param {number} l - Lightness value between `0.0` and `1.0`.
		 * @return {Color} A reference to this color.
		 */
		offsetHSL( h, s, l ) {

			this.getHSL( _hslA );

			return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

		}

		/**
		 * Adds the RGB values of the given color to the RGB values of this color.
		 *
		 * @param {Color} color - The color to add.
		 * @return {Color} A reference to this color.
		 */
		add( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		}

		/**
		 * Adds the RGB values of the given colors and stores the result in this instance.
		 *
		 * @param {Color} color1 - The first color.
		 * @param {Color} color2 - The second color.
		 * @return {Color} A reference to this color.
		 */
		addColors( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		}

		/**
		 * Adds the given scalar value to the RGB values of this color.
		 *
		 * @param {number} s - The scalar to add.
		 * @return {Color} A reference to this color.
		 */
		addScalar( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		}

		/**
		 * Subtracts the RGB values of the given color from the RGB values of this color.
		 *
		 * @param {Color} color - The color to subtract.
		 * @return {Color} A reference to this color.
		 */
		sub( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		}

		/**
		 * Multiplies the RGB values of the given color with the RGB values of this color.
		 *
		 * @param {Color} color - The color to multiply.
		 * @return {Color} A reference to this color.
		 */
		multiply( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		}

		/**
		 * Multiplies the given scalar value with the RGB values of this color.
		 *
		 * @param {number} s - The scalar to multiply.
		 * @return {Color} A reference to this color.
		 */
		multiplyScalar( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		}

		/**
		 * Linearly interpolates this color's RGB values toward the RGB values of the
		 * given color. The alpha argument can be thought of as the ratio between
		 * the two colors, where `0.0` is this color and `1.0` is the first argument.
		 *
		 * @param {Color} color - The color to converge on.
		 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
		 * @return {Color} A reference to this color.
		 */
		lerp( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		}

		/**
		 * Linearly interpolates between the given colors and stores the result in this instance.
		 * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
		 * is the first and `1.0` is the second color.
		 *
		 * @param {Color} color1 - The first color.
		 * @param {Color} color2 - The second color.
		 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
		 * @return {Color} A reference to this color.
		 */
		lerpColors( color1, color2, alpha ) {

			this.r = color1.r + ( color2.r - color1.r ) * alpha;
			this.g = color1.g + ( color2.g - color1.g ) * alpha;
			this.b = color1.b + ( color2.b - color1.b ) * alpha;

			return this;

		}

		/**
		 * Linearly interpolates this color's HSL values toward the HSL values of the
		 * given color. It differs from {@link Color#lerp} by not interpolating straight
		 * from one color to the other, but instead going through all the hues in between
		 * those two colors. The alpha argument can be thought of as the ratio between
		 * the two colors, where 0.0 is this color and 1.0 is the first argument.
		 *
		 * @param {Color} color - The color to converge on.
		 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
		 * @return {Color} A reference to this color.
		 */
		lerpHSL( color, alpha ) {

			this.getHSL( _hslA );
			color.getHSL( _hslB );

			const h = lerp( _hslA.h, _hslB.h, alpha );
			const s = lerp( _hslA.s, _hslB.s, alpha );
			const l = lerp( _hslA.l, _hslB.l, alpha );

			this.setHSL( h, s, l );

			return this;

		}

		/**
		 * Sets the color's RGB components from the given 3D vector.
		 *
		 * @param {Vector3} v - The vector to set.
		 * @return {Color} A reference to this color.
		 */
		setFromVector3( v ) {

			this.r = v.x;
			this.g = v.y;
			this.b = v.z;

			return this;

		}

		/**
		 * Transforms this color with the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The matrix.
		 * @return {Color} A reference to this color.
		 */
		applyMatrix3( m ) {

			const r = this.r, g = this.g, b = this.b;
			const e = m.elements;

			this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
			this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
			this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

			return this;

		}

		/**
		 * Returns `true` if this color is equal with the given one.
		 *
		 * @param {Color} c - The color to test for equality.
		 * @return {boolean} Whether this bounding color is equal with the given one.
		 */
		equals( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		}

		/**
		 * Sets this color's RGB components from the given array.
		 *
		 * @param {Array<number>} array - An array holding the RGB values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Color} A reference to this color.
		 */
		fromArray( array, offset = 0 ) {

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		}

		/**
		 * Writes the RGB components of this color to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the color components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The color components.
		 */
		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

		/**
		 * Sets the components of this color from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding color data.
		 * @param {number} index - The index into the attribute.
		 * @return {Color} A reference to this color.
		 */
		fromBufferAttribute( attribute, index ) {

			this.r = attribute.getX( index );
			this.g = attribute.getY( index );
			this.b = attribute.getZ( index );

			return this;

		}

		/**
		 * This methods defines the serialization result of this class. Returns the color
		 * as a hexadecimal value.
		 *
		 * @return {number} The hexadecimal value.
		 */
		toJSON() {

			return this.getHex();

		}

		*[ Symbol.iterator ]() {

			yield this.r;
			yield this.g;
			yield this.b;

		}

	}

	const _color = /*@__PURE__*/ new Color();

	/**
	 * A dictionary with X11 color names.
	 *
	 * Note that multiple words such as Dark Orange become the string 'darkorange'.
	 *
	 * @static
	 * @type {Object}
	 */
	Color.NAMES = _colorKeywords;

	/**
	 * Class representing a 2D vector. A 2D vector is an ordered pair of numbers
	 * (labeled x and y), which can be used to represent a number of things, such as:
	 *
	 * - A point in 2D space (i.e. a position on a plane).
	 * - A direction and length across a plane. In three.js the length will
	 * always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
	 * and the direction is also measured from `(0, 0)` towards `(x, y)`.
	 * - Any arbitrary ordered pair of numbers.
	 *
	 * There are other things a 2D vector can be used to represent, such as
	 * momentum vectors, complex numbers and so on, however these are the most
	 * common uses in three.js.
	 *
	 * Iterating through a vector instance will yield its components `(x, y)` in
	 * the corresponding order.
	 * ```js
	 * const a = new THREE.Vector2( 0, 1 );
	 *
	 * //no arguments; will be initialised to (0, 0)
	 * const b = new THREE.Vector2( );
	 *
	 * const d = a.distanceTo( b );
	 * ```
	 */
	class Vector2 {

		/**
		 * Constructs a new 2D vector.
		 *
		 * @param {number} [x=0] - The x value of this vector.
		 * @param {number} [y=0] - The y value of this vector.
		 */
		constructor( x = 0, y = 0 ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			Vector2.prototype.isVector2 = true;

			/**
			 * The x value of this vector.
			 *
			 * @type {number}
			 */
			this.x = x;

			/**
			 * The y value of this vector.
			 *
			 * @type {number}
			 */
			this.y = y;

		}

		/**
		 * Alias for {@link Vector2#x}.
		 *
		 * @type {number}
		 */
		get width() {

			return this.x;

		}

		set width( value ) {

			this.x = value;

		}

		/**
		 * Alias for {@link Vector2#y}.
		 *
		 * @type {number}
		 */
		get height() {

			return this.y;

		}

		set height( value ) {

			this.y = value;

		}

		/**
		 * Sets the vector components.
		 *
		 * @param {number} x - The value of the x component.
		 * @param {number} y - The value of the y component.
		 * @return {Vector2} A reference to this vector.
		 */
		set( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		}

		/**
		 * Sets the vector components to the same value.
		 *
		 * @param {number} scalar - The value to set for all vector components.
		 * @return {Vector2} A reference to this vector.
		 */
		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		}

		/**
		 * Sets the vector's x component to the given value
		 *
		 * @param {number} x - The value to set.
		 * @return {Vector2} A reference to this vector.
		 */
		setX( x ) {

			this.x = x;

			return this;

		}

		/**
		 * Sets the vector's y component to the given value
		 *
		 * @param {number} y - The value to set.
		 * @return {Vector2} A reference to this vector.
		 */
		setY( y ) {

			this.y = y;

			return this;

		}

		/**
		 * Allows to set a vector component with an index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
		 * @param {number} value - The value to set.
		 * @return {Vector2} A reference to this vector.
		 */
		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		/**
		 * Returns the value of the vector component which matches the given index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
		 * @return {number} A vector component value.
		 */
		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		/**
		 * Returns a new vector with copied values from this instance.
		 *
		 * @return {Vector2} A clone of this instance.
		 */
		clone() {

			return new this.constructor( this.x, this.y );

		}

		/**
		 * Copies the values of the given vector to this instance.
		 *
		 * @param {Vector2} v - The vector to copy.
		 * @return {Vector2} A reference to this vector.
		 */
		copy( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		}

		/**
		 * Adds the given vector to this instance.
		 *
		 * @param {Vector2} v - The vector to add.
		 * @return {Vector2} A reference to this vector.
		 */
		add( v ) {

			this.x += v.x;
			this.y += v.y;

			return this;

		}

		/**
		 * Adds the given scalar value to all components of this instance.
		 *
		 * @param {number} s - The scalar to add.
		 * @return {Vector2} A reference to this vector.
		 */
		addScalar( s ) {

			this.x += s;
			this.y += s;

			return this;

		}

		/**
		 * Adds the given vectors and stores the result in this instance.
		 *
		 * @param {Vector2} a - The first vector.
		 * @param {Vector2} b - The second vector.
		 * @return {Vector2} A reference to this vector.
		 */
		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		}

		/**
		 * Adds the given vector scaled by the given factor to this instance.
		 *
		 * @param {Vector2} v - The vector.
		 * @param {number} s - The factor that scales `v`.
		 * @return {Vector2} A reference to this vector.
		 */
		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		}

		/**
		 * Subtracts the given vector from this instance.
		 *
		 * @param {Vector2} v - The vector to subtract.
		 * @return {Vector2} A reference to this vector.
		 */
		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;

			return this;

		}

		/**
		 * Subtracts the given scalar value from all components of this instance.
		 *
		 * @param {number} s - The scalar to subtract.
		 * @return {Vector2} A reference to this vector.
		 */
		subScalar( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		}

		/**
		 * Subtracts the given vectors and stores the result in this instance.
		 *
		 * @param {Vector2} a - The first vector.
		 * @param {Vector2} b - The second vector.
		 * @return {Vector2} A reference to this vector.
		 */
		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		}

		/**
		 * Multiplies the given vector with this instance.
		 *
		 * @param {Vector2} v - The vector to multiply.
		 * @return {Vector2} A reference to this vector.
		 */
		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		}

		/**
		 * Multiplies the given scalar value with all components of this instance.
		 *
		 * @param {number} scalar - The scalar to multiply.
		 * @return {Vector2} A reference to this vector.
		 */
		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		}

		/**
		 * Divides this instance by the given vector.
		 *
		 * @param {Vector2} v - The vector to divide.
		 * @return {Vector2} A reference to this vector.
		 */
		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		}

		/**
		 * Divides this vector by the given scalar.
		 *
		 * @param {number} scalar - The scalar to divide.
		 * @return {Vector2} A reference to this vector.
		 */
		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		/**
		 * Multiplies this vector (with an implicit 1 as the 3rd component) by
		 * the given 3x3 matrix.
		 *
		 * @param {Matrix3} m - The matrix to apply.
		 * @return {Vector2} A reference to this vector.
		 */
		applyMatrix3( m ) {

			const x = this.x, y = this.y;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		}

		/**
		 * If this vector's x or y value is greater than the given vector's x or y
		 * value, replace that value with the corresponding min value.
		 *
		 * @param {Vector2} v - The vector.
		 * @return {Vector2} A reference to this vector.
		 */
		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		}

		/**
		 * If this vector's x or y value is less than the given vector's x or y
		 * value, replace that value with the corresponding max value.
		 *
		 * @param {Vector2} v - The vector.
		 * @return {Vector2} A reference to this vector.
		 */
		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		}

		/**
		 * If this vector's x or y value is greater than the max vector's x or y
		 * value, it is replaced by the corresponding value.
		 * If this vector's x or y value is less than the min vector's x or y value,
		 * it is replaced by the corresponding value.
		 *
		 * @param {Vector2} min - The minimum x and y values.
		 * @param {Vector2} max - The maximum x and y values in the desired range.
		 * @return {Vector2} A reference to this vector.
		 */
		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = clamp( this.x, min.x, max.x );
			this.y = clamp( this.y, min.y, max.y );

			return this;

		}

		/**
		 * If this vector's x or y values are greater than the max value, they are
		 * replaced by the max value.
		 * If this vector's x or y values are less than the min value, they are
		 * replaced by the min value.
		 *
		 * @param {number} minVal - The minimum value the components will be clamped to.
		 * @param {number} maxVal - The maximum value the components will be clamped to.
		 * @return {Vector2} A reference to this vector.
		 */
		clampScalar( minVal, maxVal ) {

			this.x = clamp( this.x, minVal, maxVal );
			this.y = clamp( this.y, minVal, maxVal );

			return this;

		}

		/**
		 * If this vector's length is greater than the max value, it is replaced by
		 * the max value.
		 * If this vector's length is less than the min value, it is replaced by the
		 * min value.
		 *
		 * @param {number} min - The minimum value the vector length will be clamped to.
		 * @param {number} max - The maximum value the vector length will be clamped to.
		 * @return {Vector2} A reference to this vector.
		 */
		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

		}

		/**
		 * The components of this vector are rounded down to the nearest integer value.
		 *
		 * @return {Vector2} A reference to this vector.
		 */
		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		}

		/**
		 * The components of this vector are rounded up to the nearest integer value.
		 *
		 * @return {Vector2} A reference to this vector.
		 */
		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		}

		/**
		 * The components of this vector are rounded to the nearest integer value
		 *
		 * @return {Vector2} A reference to this vector.
		 */
		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		}

		/**
		 * The components of this vector are rounded towards zero (up if negative,
		 * down if positive) to an integer value.
		 *
		 * @return {Vector2} A reference to this vector.
		 */
		roundToZero() {

			this.x = Math.trunc( this.x );
			this.y = Math.trunc( this.y );

			return this;

		}

		/**
		 * Inverts this vector - i.e. sets x = -x and y = -y.
		 *
		 * @return {Vector2} A reference to this vector.
		 */
		negate() {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		}

		/**
		 * Calculates the dot product of the given vector with this instance.
		 *
		 * @param {Vector2} v - The vector to compute the dot product with.
		 * @return {number} The result of the dot product.
		 */
		dot( v ) {

			return this.x * v.x + this.y * v.y;

		}

		/**
		 * Calculates the cross product of the given vector with this instance.
		 *
		 * @param {Vector2} v - The vector to compute the cross product with.
		 * @return {number} The result of the cross product.
		 */
		cross( v ) {

			return this.x * v.y - this.y * v.x;

		}

		/**
		 * Computes the square of the Euclidean length (straight-line length) from
		 * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
		 * compare the length squared instead as it is slightly more efficient to calculate.
		 *
		 * @return {number} The square length of this vector.
		 */
		lengthSq() {

			return this.x * this.x + this.y * this.y;

		}

		/**
		 * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
		 *
		 * @return {number} The length of this vector.
		 */
		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		}

		/**
		 * Computes the Manhattan length of this vector.
		 *
		 * @return {number} The length of this vector.
		 */
		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y );

		}

		/**
		 * Converts this vector to a unit vector - that is, sets it equal to a vector
		 * with the same direction as this one, but with a vector length of `1`.
		 *
		 * @return {Vector2} A reference to this vector.
		 */
		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		/**
		 * Computes the angle in radians of this vector with respect to the positive x-axis.
		 *
		 * @return {number} The angle in radians.
		 */
		angle() {

			const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		}

		/**
		 * Returns the angle between the given vector and this instance in radians.
		 *
		 * @param {Vector2} v - The vector to compute the angle with.
		 * @return {number} The angle in radians.
		 */
		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( clamp( theta, -1, 1 ) );

		}

		/**
		 * Computes the distance from the given vector to this instance.
		 *
		 * @param {Vector2} v - The vector to compute the distance to.
		 * @return {number} The distance.
		 */
		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		/**
		 * Computes the squared distance from the given vector to this instance.
		 * If you are just comparing the distance with another distance, you should compare
		 * the distance squared instead as it is slightly more efficient to calculate.
		 *
		 * @param {Vector2} v - The vector to compute the squared distance to.
		 * @return {number} The squared distance.
		 */
		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		}

		/**
		 * Computes the Manhattan distance from the given vector to this instance.
		 *
		 * @param {Vector2} v - The vector to compute the Manhattan distance to.
		 * @return {number} The Manhattan distance.
		 */
		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		}

		/**
		 * Sets this vector to a vector with the same direction as this one, but
		 * with the specified length.
		 *
		 * @param {number} length - The new length of this vector.
		 * @return {Vector2} A reference to this vector.
		 */
		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		/**
		 * Linearly interpolates between the given vector and this instance, where
		 * alpha is the percent distance along the line - alpha = 0 will be this
		 * vector, and alpha = 1 will be the given one.
		 *
		 * @param {Vector2} v - The vector to interpolate towards.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector2} A reference to this vector.
		 */
		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		}

		/**
		 * Linearly interpolates between the given vectors, where alpha is the percent
		 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
		 * be the second one. The result is stored in this instance.
		 *
		 * @param {Vector2} v1 - The first vector.
		 * @param {Vector2} v2 - The second vector.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector2} A reference to this vector.
		 */
		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;

			return this;

		}

		/**
		 * Returns `true` if this vector is equal with the given one.
		 *
		 * @param {Vector2} v - The vector to test for equality.
		 * @return {boolean} Whether this vector is equal with the given one.
		 */
		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		}

		/**
		 * Sets this vector's x value to be `array[ offset ]` and y
		 * value to be `array[ offset + 1 ]`.
		 *
		 * @param {Array<number>} array - An array holding the vector component values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Vector2} A reference to this vector.
		 */
		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		}

		/**
		 * Writes the components of this vector to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the vector components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The vector components.
		 */
		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		}

		/**
		 * Sets the components of this vector from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
		 * @param {number} index - The index into the attribute.
		 * @return {Vector2} A reference to this vector.
		 */
		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		}

		/**
		 * Rotates this vector around the given center by the given angle.
		 *
		 * @param {Vector2} center - The point around which to rotate.
		 * @param {number} angle - The angle to rotate, in radians.
		 * @return {Vector2} A reference to this vector.
		 */
		rotateAround( center, angle ) {

			const c = Math.cos( angle ), s = Math.sin( angle );

			const x = this.x - center.x;
			const y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

		/**
		 * Sets each component of this vector to a pseudo-random value between `0` and
		 * `1`, excluding `1`.
		 *
		 * @return {Vector2} A reference to this vector.
		 */
		random() {

			this.x = Math.random();
			this.y = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;

		}

	}

	/**
	 * Represents an axis-aligned bounding box (AABB) in 3D space.
	 */
	class Box3 {

		/**
		 * Constructs a new bounding box.
		 *
		 * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
		 * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
		 */
		constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isBox3 = true;

			/**
			 * The lower boundary of the box.
			 *
			 * @type {Vector3}
			 */
			this.min = min;

			/**
			 * The upper boundary of the box.
			 *
			 * @type {Vector3}
			 */
			this.max = max;

		}

		/**
		 * Sets the lower and upper boundaries of this box.
		 * Please note that this method only copies the values from the given objects.
		 *
		 * @param {Vector3} min - The lower boundary of the box.
		 * @param {Vector3} max - The upper boundary of the box.
		 * @return {Box3} A reference to this bounding box.
		 */
		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		/**
		 * Sets the upper and lower bounds of this box so it encloses the position data
		 * in the given array.
		 *
		 * @param {Array<number>} array - An array holding 3D position data.
		 * @return {Box3} A reference to this bounding box.
		 */
		setFromArray( array ) {

			this.makeEmpty();

			for ( let i = 0, il = array.length; i < il; i += 3 ) {

				this.expandByPoint( _vector$4.fromArray( array, i ) );

			}

			return this;

		}

		/**
		 * Sets the upper and lower bounds of this box so it encloses the position data
		 * in the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
		 * @return {Box3} A reference to this bounding box.
		 */
		setFromBufferAttribute( attribute ) {

			this.makeEmpty();

			for ( let i = 0, il = attribute.count; i < il; i ++ ) {

				this.expandByPoint( _vector$4.fromBufferAttribute( attribute, i ) );

			}

			return this;

		}

		/**
		 * Sets the upper and lower bounds of this box so it encloses the position data
		 * in the given array.
		 *
		 * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
		 * @return {Box3} A reference to this bounding box.
		 */
		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		/**
		 * Centers this box on the given center vector and sets this box's width, height and
		 * depth to the given size values.
		 *
		 * @param {Vector3} center - The center of the box.
		 * @param {Vector3} size - The x, y and z dimensions of the box.
		 * @return {Box3} A reference to this bounding box.
		 */
		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		/**
		 * Computes the world-axis-aligned bounding box for the given 3D object
		 * (including its children), accounting for the object's, and children's,
		 * world transforms. The function may result in a larger box than strictly necessary.
		 *
		 * @param {Object3D} object - The 3D object to compute the bounding box for.
		 * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
		 * world-axis-aligned bounding box at the expense of more computation.
		 * @return {Box3} A reference to this bounding box.
		 */
		setFromObject( object, precise = false ) {

			this.makeEmpty();

			return this.expandByObject( object, precise );

		}

		/**
		 * Returns a new box with copied values from this instance.
		 *
		 * @return {Box3} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

		/**
		 * Copies the values of the given box to this instance.
		 *
		 * @param {Box3} box - The box to copy.
		 * @return {Box3} A reference to this bounding box.
		 */
		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		/**
		 * Makes this box empty which means in encloses a zero space in 3D.
		 *
		 * @return {Box3} A reference to this bounding box.
		 */
		makeEmpty() {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		}

		/**
		 * Returns true if this box includes zero points within its bounds.
		 * Note that a box with equal lower and upper bounds still includes one
		 * point, the one both bounds share.
		 *
		 * @return {boolean} Whether this box is empty or not.
		 */
		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		}

		/**
		 * Returns the center point of this box.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The center point.
		 */
		getCenter( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		/**
		 * Returns the dimensions of this box.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The size.
		 */
		getSize( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		}

		/**
		 * Expands the boundaries of this box to include the given point.
		 *
		 * @param {Vector3} point - The point that should be included by the bounding box.
		 * @return {Box3} A reference to this bounding box.
		 */
		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		/**
		 * Expands this box equilaterally by the given vector. The width of this
		 * box will be expanded by the x component of the vector in both
		 * directions. The height of this box will be expanded by the y component of
		 * the vector in both directions. The depth of this box will be
		 * expanded by the z component of the vector in both directions.
		 *
		 * @param {Vector3} vector - The vector that should expand the bounding box.
		 * @return {Box3} A reference to this bounding box.
		 */
		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		/**
		 * Expands each dimension of the box by the given scalar. If negative, the
		 * dimensions of the box will be contracted.
		 *
		 * @param {number} scalar - The scalar value that should expand the bounding box.
		 * @return {Box3} A reference to this bounding box.
		 */
		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		/**
		 * Expands the boundaries of this box to include the given 3D object and
		 * its children, accounting for the object's, and children's, world
		 * transforms. The function may result in a larger box than strictly
		 * necessary (unless the precise parameter is set to true).
		 *
		 * @param {Object3D} object - The 3D object that should expand the bounding box.
		 * @param {boolean} precise - If set to `true`, the method expands the bounding box
		 * as little as necessary at the expense of more computation.
		 * @return {Box3} A reference to this bounding box.
		 */
		expandByObject( object, precise = false ) {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			object.updateWorldMatrix( false, false );

			const geometry = object.geometry;

			if ( geometry !== undefined ) {

				const positionAttribute = geometry.getAttribute( 'position' );

				// precise AABB computation based on vertex data requires at least a position attribute.
				// instancing isn't supported so far and uses the normal (conservative) code path.

				if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

					for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

						if ( object.isMesh === true ) {

							object.getVertexPosition( i, _vector$4 );

						} else {

							_vector$4.fromBufferAttribute( positionAttribute, i );

						}

						_vector$4.applyMatrix4( object.matrixWorld );
						this.expandByPoint( _vector$4 );

					}

				} else {

					if ( object.boundingBox !== undefined ) {

						// object-level bounding box

						if ( object.boundingBox === null ) {

							object.computeBoundingBox();

						}

						_box$2.copy( object.boundingBox );


					} else {

						// geometry-level bounding box

						if ( geometry.boundingBox === null ) {

							geometry.computeBoundingBox();

						}

						_box$2.copy( geometry.boundingBox );

					}

					_box$2.applyMatrix4( object.matrixWorld );

					this.union( _box$2 );

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				this.expandByObject( children[ i ], precise );

			}

			return this;

		}

		/**
		 * Returns `true` if the given point lies within or on the boundaries of this box.
		 *
		 * @param {Vector3} point - The point to test.
		 * @return {boolean} Whether the bounding box contains the given point or not.
		 */
		containsPoint( point ) {

			return point.x >= this.min.x && point.x <= this.max.x &&
				point.y >= this.min.y && point.y <= this.max.y &&
				point.z >= this.min.z && point.z <= this.max.z;

		}

		/**
		 * Returns `true` if this bounding box includes the entirety of the given bounding box.
		 * If this box and the given one are identical, this function also returns `true`.
		 *
		 * @param {Box3} box - The bounding box to test.
		 * @return {boolean} Whether the bounding box contains the given bounding box or not.
		 */
		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		}

		/**
		 * Returns a point as a proportion of this box's width, height and depth.
		 *
		 * @param {Vector3} point - A point in 3D space.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} A point as a proportion of this box's width, height and depth.
		 */
		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		}

		/**
		 * Returns `true` if the given bounding box intersects with this bounding box.
		 *
		 * @param {Box3} box - The bounding box to test.
		 * @return {boolean} Whether the given bounding box intersects with this bounding box.
		 */
		intersectsBox( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x >= this.min.x && box.min.x <= this.max.x &&
				box.max.y >= this.min.y && box.min.y <= this.max.y &&
				box.max.z >= this.min.z && box.min.z <= this.max.z;

		}

		/**
		 * Returns `true` if the given bounding sphere intersects with this bounding box.
		 *
		 * @param {Sphere} sphere - The bounding sphere to test.
		 * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
		 */
		intersectsSphere( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, _vector$4 );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$4.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		/**
		 * Returns `true` if the given plane intersects with this bounding box.
		 *
		 * @param {Plane} plane - The plane to test.
		 * @return {boolean} Whether the given plane intersects with this bounding box.
		 */
		intersectsPlane( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			let min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		}

		/**
		 * Returns `true` if the given triangle intersects with this bounding box.
		 *
		 * @param {Triangle} triangle - The triangle to test.
		 * @return {boolean} Whether the given triangle intersects with this bounding box.
		 */
		intersectsTriangle( triangle ) {

			if ( this.isEmpty() ) {

				return false;

			}

			// compute box center and extents
			this.getCenter( _center );
			_extents.subVectors( this.max, _center );

			// translate triangle to aabb origin
			_v0$2.subVectors( triangle.a, _center );
			_v1$2.subVectors( triangle.b, _center );
			_v2$2.subVectors( triangle.c, _center );

			// compute edge vectors for triangle
			_f0.subVectors( _v1$2, _v0$2 );
			_f1.subVectors( _v2$2, _v1$2 );
			_f2.subVectors( _v0$2, _v2$2 );

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			let axes = [
				0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
				_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
				- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
			];
			if ( ! satForAxes( axes, _v0$2, _v1$2, _v2$2, _extents ) ) {

				return false;

			}

			// test 3 face normals from the aabb
			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
			if ( ! satForAxes( axes, _v0$2, _v1$2, _v2$2, _extents ) ) {

				return false;

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors( _f0, _f1 );
			axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

			return satForAxes( axes, _v0$2, _v1$2, _v2$2, _extents );

		}

		/**
		 * Clamps the given point within the bounds of this box.
		 *
		 * @param {Vector3} point - The point to clamp.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The clamped point.
		 */
		clampPoint( point, target ) {

			return target.copy( point ).clamp( this.min, this.max );

		}

		/**
		 * Returns the euclidean distance from any edge of this box to the specified point. If
		 * the given point lies inside of this box, the distance will be `0`.
		 *
		 * @param {Vector3} point - The point to compute the distance to.
		 * @return {number} The euclidean distance.
		 */
		distanceToPoint( point ) {

			return this.clampPoint( point, _vector$4 ).distanceTo( point );

		}

		/**
		 * Returns a bounding sphere that encloses this bounding box.
		 *
		 * @param {Sphere} target - The target sphere that is used to store the method's result.
		 * @return {Sphere} The bounding sphere that encloses this bounding box.
		 */
		getBoundingSphere( target ) {

			if ( this.isEmpty() ) {

				target.makeEmpty();

			} else {

				this.getCenter( target.center );

				target.radius = this.getSize( _vector$4 ).length() * 0.5;

			}

			return target;

		}

		/**
		 * Computes the intersection of this bounding box and the given one, setting the upper
		 * bound of this box to the lesser of the two boxes' upper bounds and the
		 * lower bound of this box to the greater of the two boxes' lower bounds. If
		 * there's no overlap, makes this box empty.
		 *
		 * @param {Box3} box - The bounding box to intersect with.
		 * @return {Box3} A reference to this bounding box.
		 */
		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		}

		/**
		 * Computes the union of this box and another and the given one, setting the upper
		 * bound of this box to the greater of the two boxes' upper bounds and the
		 * lower bound of this box to the lesser of the two boxes' lower bounds.
		 *
		 * @param {Box3} box - The bounding box that will be unioned with this instance.
		 * @return {Box3} A reference to this bounding box.
		 */
		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		/**
		 * Transforms this bounding box by the given 4x4 transformation matrix.
		 *
		 * @param {Matrix4} matrix - The transformation matrix.
		 * @return {Box3} A reference to this bounding box.
		 */
		applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

			this.setFromPoints( _points );

			return this;

		}

		/**
		 * Adds the given offset to both the upper and lower bounds of this bounding box,
		 * effectively moving it in 3D space.
		 *
		 * @param {Vector3} offset - The offset that should be used to translate the bounding box.
		 * @return {Box3} A reference to this bounding box.
		 */
		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		/**
		 * Returns `true` if this bounding box is equal with the given one.
		 *
		 * @param {Box3} box - The box to test for equality.
		 * @return {boolean} Whether this bounding box is equal with the given one.
		 */
		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

		/**
		 * Returns a serialized structure of the bounding box.
		 *
		 * @return {Object} Serialized structure with fields representing the object state.
		 */
		toJSON() {

			return {
				min: this.min.toArray(),
				max: this.max.toArray()
			};

		}

		/**
		 * Returns a serialized structure of the bounding box.
		 *
		 * @param {Object} json - The serialized json to set the box from.
		 * @return {Box3} A reference to this bounding box.
		 */
		fromJSON( json ) {

			this.min.fromArray( json.min );
			this.max.fromArray( json.max );
			return this;

		}

	}

	const _points = [
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3()
	];

	const _vector$4 = /*@__PURE__*/ new Vector3();

	const _box$2 = /*@__PURE__*/ new Box3();

	// triangle centered vertices

	const _v0$2 = /*@__PURE__*/ new Vector3();
	const _v1$2 = /*@__PURE__*/ new Vector3();
	const _v2$2 = /*@__PURE__*/ new Vector3();

	// triangle edge vectors

	const _f0 = /*@__PURE__*/ new Vector3();
	const _f1 = /*@__PURE__*/ new Vector3();
	const _f2 = /*@__PURE__*/ new Vector3();

	const _center = /*@__PURE__*/ new Vector3();
	const _extents = /*@__PURE__*/ new Vector3();
	const _triangleNormal = /*@__PURE__*/ new Vector3();
	const _testAxis = /*@__PURE__*/ new Vector3();

	function satForAxes( axes, v0, v1, v2, extents ) {

		for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

			_testAxis.fromArray( axes, i );
			// project the aabb onto the separating axis
			const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
			// project all 3 vertices of the triangle onto the separating axis
			const p0 = v0.dot( _testAxis );
			const p1 = v1.dot( _testAxis );
			const p2 = v2.dot( _testAxis );
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is separating and we can exit
				return false;

			}

		}

		return true;

	}

	const _box$1 = /*@__PURE__*/ new Box3();
	const _v1$1 = /*@__PURE__*/ new Vector3();
	const _v2$1 = /*@__PURE__*/ new Vector3();

	/**
	 * An analytical 3D sphere defined by a center and radius. This class is mainly
	 * used as a Bounding Sphere for 3D objects.
	 */
	let Sphere$1 = class Sphere {

		/**
		 * Constructs a new sphere.
		 *
		 * @param {Vector3} [center=(0,0,0)] - The center of the sphere
		 * @param {number} [radius=-1] - The radius of the sphere.
		 */
		constructor( center = new Vector3(), radius = -1 ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isSphere = true;

			/**
			 * The center of the sphere
			 *
			 * @type {Vector3}
			 */
			this.center = center;

			/**
			 * The radius of the sphere.
			 *
			 * @type {number}
			 */
			this.radius = radius;

		}

		/**
		 * Sets the sphere's components by copying the given values.
		 *
		 * @param {Vector3} center - The center.
		 * @param {number} radius - The radius.
		 * @return {Sphere} A reference to this sphere.
		 */
		set( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		}

		/**
		 * Computes the minimum bounding sphere for list of points.
		 * If the optional center point is given, it is used as the sphere's
		 * center. Otherwise, the center of the axis-aligned bounding box
		 * encompassing the points is calculated.
		 *
		 * @param {Array<Vector3>} points - A list of points in 3D space.
		 * @param {Vector3} [optionalCenter] - The center of the sphere.
		 * @return {Sphere} A reference to this sphere.
		 */
		setFromPoints( points, optionalCenter ) {

			const center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				_box$1.setFromPoints( points ).getCenter( center );

			}

			let maxRadiusSq = 0;

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		}

		/**
		 * Copies the values of the given sphere to this instance.
		 *
		 * @param {Sphere} sphere - The sphere to copy.
		 * @return {Sphere} A reference to this sphere.
		 */
		copy( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		}

		/**
		 * Returns `true` if the sphere is empty (the radius set to a negative number).
		 *
		 * Spheres with a radius of `0` contain only their center point and are not
		 * considered to be empty.
		 *
		 * @return {boolean} Whether this sphere is empty or not.
		 */
		isEmpty() {

			return ( this.radius < 0 );

		}

		/**
		 * Makes this sphere empty which means in encloses a zero space in 3D.
		 *
		 * @return {Sphere} A reference to this sphere.
		 */
		makeEmpty() {

			this.center.set( 0, 0, 0 );
			this.radius = -1;

			return this;

		}

		/**
		 * Returns `true` if this sphere contains the given point inclusive of
		 * the surface of the sphere.
		 *
		 * @param {Vector3} point - The point to check.
		 * @return {boolean} Whether this sphere contains the given point or not.
		 */
		containsPoint( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		}

		/**
		 * Returns the closest distance from the boundary of the sphere to the
		 * given point. If the sphere contains the point, the distance will
		 * be negative.
		 *
		 * @param {Vector3} point - The point to compute the distance to.
		 * @return {number} The distance to the point.
		 */
		distanceToPoint( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		}

		/**
		 * Returns `true` if this sphere intersects with the given one.
		 *
		 * @param {Sphere} sphere - The sphere to test.
		 * @return {boolean} Whether this sphere intersects with the given one or not.
		 */
		intersectsSphere( sphere ) {

			const radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		}

		/**
		 * Returns `true` if this sphere intersects with the given box.
		 *
		 * @param {Box3} box - The box to test.
		 * @return {boolean} Whether this sphere intersects with the given box or not.
		 */
		intersectsBox( box ) {

			return box.intersectsSphere( this );

		}

		/**
		 * Returns `true` if this sphere intersects with the given plane.
		 *
		 * @param {Plane} plane - The plane to test.
		 * @return {boolean} Whether this sphere intersects with the given plane or not.
		 */
		intersectsPlane( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		}

		/**
		 * Clamps a point within the sphere. If the point is outside the sphere, it
		 * will clamp it to the closest point on the edge of the sphere. Points
		 * already inside the sphere will not be affected.
		 *
		 * @param {Vector3} point - The plane to clamp.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The clamped point.
		 */
		clampPoint( point, target ) {

			const deltaLengthSq = this.center.distanceToSquared( point );

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		}

		/**
		 * Returns a bounding box that encloses this sphere.
		 *
		 * @param {Box3} target - The target box that is used to store the method's result.
		 * @return {Box3} The bounding box that encloses this sphere.
		 */
		getBoundingBox( target ) {

			if ( this.isEmpty() ) {

				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		}

		/**
		 * Transforms this sphere with the given 4x4 transformation matrix.
		 *
		 * @param {Matrix4} matrix - The transformation matrix.
		 * @return {Sphere} A reference to this sphere.
		 */
		applyMatrix4( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		}

		/**
		 * Translates the sphere's center by the given offset.
		 *
		 * @param {Vector3} offset - The offset.
		 * @return {Sphere} A reference to this sphere.
		 */
		translate( offset ) {

			this.center.add( offset );

			return this;

		}

		/**
		 * Expands the boundaries of this sphere to include the given point.
		 *
		 * @param {Vector3} point - The point to include.
		 * @return {Sphere} A reference to this sphere.
		 */
		expandByPoint( point ) {

			if ( this.isEmpty() ) {

				this.center.copy( point );

				this.radius = 0;

				return this;

			}

			_v1$1.subVectors( point, this.center );

			const lengthSq = _v1$1.lengthSq();

			if ( lengthSq > ( this.radius * this.radius ) ) {

				// calculate the minimal sphere

				const length = Math.sqrt( lengthSq );

				const delta = ( length - this.radius ) * 0.5;

				this.center.addScaledVector( _v1$1, delta / length );

				this.radius += delta;

			}

			return this;

		}

		/**
		 * Expands this sphere to enclose both the original sphere and the given sphere.
		 *
		 * @param {Sphere} sphere - The sphere to include.
		 * @return {Sphere} A reference to this sphere.
		 */
		union( sphere ) {

			if ( sphere.isEmpty() ) {

				return this;

			}

			if ( this.isEmpty() ) {

				this.copy( sphere );

				return this;

			}

			if ( this.center.equals( sphere.center ) === true ) {

				 this.radius = Math.max( this.radius, sphere.radius );

			} else {

				_v2$1.subVectors( sphere.center, this.center ).setLength( sphere.radius );

				this.expandByPoint( _v1$1.copy( sphere.center ).add( _v2$1 ) );

				this.expandByPoint( _v1$1.copy( sphere.center ).sub( _v2$1 ) );

			}

			return this;

		}

		/**
		 * Returns `true` if this sphere is equal with the given one.
		 *
		 * @param {Sphere} sphere - The sphere to test for equality.
		 * @return {boolean} Whether this bounding sphere is equal with the given one.
		 */
		equals( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

		/**
		 * Returns a new sphere with copied values from this instance.
		 *
		 * @return {Sphere} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

		/**
		 * Returns a serialized structure of the bounding sphere.
		 *
		 * @return {Object} Serialized structure with fields representing the object state.
		 */
		toJSON() {

			return {
				radius: this.radius,
				center: this.center.toArray()
			};

		}

		/**
		 * Returns a serialized structure of the bounding sphere.
		 *
		 * @param {Object} json - The serialized json to set the sphere from.
		 * @return {Box3} A reference to this bounding sphere.
		 */
		fromJSON( json ) {

			this.radius = json.radius;
			this.center.fromArray( json.center );
			return this;

		}

	};

	const _vector1 = /*@__PURE__*/ new Vector3();
	const _vector2$1 = /*@__PURE__*/ new Vector3();
	const _normalMatrix = /*@__PURE__*/ new Matrix3();

	/**
	 * A two dimensional surface that extends infinitely in 3D space, represented
	 * in [Hessian normal form]{@link http://mathworld.wolfram.com/HessianNormalForm.html}
	 * by a unit length normal vector and a constant.
	 */
	let Plane$1 = class Plane {

		/**
		 * Constructs a new plane.
		 *
		 * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
		 * @param {number} [constant=0] - The signed distance from the origin to the plane.
		 */
		constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isPlane = true;

			/**
			 * A unit length vector defining the normal of the plane.
			 *
			 * @type {Vector3}
			 */
			this.normal = normal;

			/**
			 * The signed distance from the origin to the plane.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.constant = constant;

		}

		/**
		 * Sets the plane components by copying the given values.
		 *
		 * @param {Vector3} normal - The normal.
		 * @param {number} constant - The constant.
		 * @return {Plane} A reference to this plane.
		 */
		set( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		}

		/**
		 * Sets the plane components by defining `x`, `y`, `z` as the
		 * plane normal and `w` as the constant.
		 *
		 * @param {number} x - The value for the normal's x component.
		 * @param {number} y - The value for the normal's y component.
		 * @param {number} z - The value for the normal's z component.
		 * @param {number} w - The constant value.
		 * @return {Plane} A reference to this plane.
		 */
		setComponents( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		}

		/**
		 * Sets the plane from the given normal and coplanar point (that is a point
		 * that lies onto the plane).
		 *
		 * @param {Vector3} normal - The normal.
		 * @param {Vector3} point - A coplanar point.
		 * @return {Plane} A reference to this plane.
		 */
		setFromNormalAndCoplanarPoint( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		}

		/**
		 * Sets the plane from three coplanar points. The winding order is
		 * assumed to be counter-clockwise, and determines the direction of
		 * the plane normal.
		 *
		 * @param {Vector3} a - The first coplanar point.
		 * @param {Vector3} b - The second coplanar point.
		 * @param {Vector3} c - The third coplanar point.
		 * @return {Plane} A reference to this plane.
		 */
		setFromCoplanarPoints( a, b, c ) {

			const normal = _vector1.subVectors( c, b ).cross( _vector2$1.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		}

		/**
		 * Copies the values of the given plane to this instance.
		 *
		 * @param {Plane} plane - The plane to copy.
		 * @return {Plane} A reference to this plane.
		 */
		copy( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		}

		/**
		 * Normalizes the plane normal and adjusts the constant accordingly.
		 *
		 * @return {Plane} A reference to this plane.
		 */
		normalize() {

			// Note: will lead to a divide by zero if the plane is invalid.

			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		}

		/**
		 * Negates both the plane normal and the constant.
		 *
		 * @return {Plane} A reference to this plane.
		 */
		negate() {

			this.constant *= -1;
			this.normal.negate();

			return this;

		}

		/**
		 * Returns the signed distance from the given point to this plane.
		 *
		 * @param {Vector3} point - The point to compute the distance for.
		 * @return {number} The signed distance.
		 */
		distanceToPoint( point ) {

			return this.normal.dot( point ) + this.constant;

		}

		/**
		 * Returns the signed distance from the given sphere to this plane.
		 *
		 * @param {Sphere} sphere - The sphere to compute the distance for.
		 * @return {number} The signed distance.
		 */
		distanceToSphere( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		}

		/**
		 * Projects a the given point onto the plane.
		 *
		 * @param {Vector3} point - The point to project.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The projected point on the plane.
		 */
		projectPoint( point, target ) {

			return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

		}

		/**
		 * Returns the intersection point of the passed line and the plane. Returns
		 * `null` if the line does not intersect. Returns the line's starting point if
		 * the line is coplanar with the plane.
		 *
		 * @param {Line3} line - The line to compute the intersection for.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */
		intersectLine( line, target ) {

			const direction = line.delta( _vector1 );

			const denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return null;

			}

			const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return null;

			}

			return target.copy( line.start ).addScaledVector( direction, t );

		}

		/**
		 * Returns `true` if the given line segment intersects with (passes through) the plane.
		 *
		 * @param {Line3} line - The line to test.
		 * @return {boolean} Whether the given line segment intersects with the plane or not.
		 */
		intersectsLine( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			const startSign = this.distanceToPoint( line.start );
			const endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		}

		/**
		 * Returns `true` if the given bounding box intersects with the plane.
		 *
		 * @param {Box3} box - The bounding box to test.
		 * @return {boolean} Whether the given bounding box intersects with the plane or not.
		 */
		intersectsBox( box ) {

			return box.intersectsPlane( this );

		}

		/**
		 * Returns `true` if the given bounding sphere intersects with the plane.
		 *
		 * @param {Sphere} sphere - The bounding sphere to test.
		 * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
		 */
		intersectsSphere( sphere ) {

			return sphere.intersectsPlane( this );

		}

		/**
		 * Returns a coplanar vector to the plane, by calculating the
		 * projection of the normal at the origin onto the plane.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The coplanar point.
		 */
		coplanarPoint( target ) {

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		}

		/**
		 * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
		 *
		 * The optional normal matrix can be pre-computed like so:
		 * ```js
		 * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
		 * ```
		 *
		 * @param {Matrix4} matrix - The transformation matrix.
		 * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
		 * @return {Plane} A reference to this plane.
		 */
		applyMatrix4( matrix, optionalNormalMatrix ) {

			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		}

		/**
		 * Translates the plane by the distance defined by the given offset vector.
		 * Note that this only affects the plane constant and will not affect the normal vector.
		 *
		 * @param {Vector3} offset - The offset vector.
		 * @return {Plane} A reference to this plane.
		 */
		translate( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		}

		/**
		 * Returns `true` if this plane is equal with the given one.
		 *
		 * @param {Plane} plane - The plane to test for equality.
		 * @return {boolean} Whether this plane is equal with the given one.
		 */
		equals( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

		/**
		 * Returns a new plane with copied values from this instance.
		 *
		 * @return {Plane} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

	};

	const _sphere$1 = /*@__PURE__*/ new Sphere$1();
	const _defaultSpriteCenter = /*@__PURE__*/ new Vector2( 0.5, 0.5 );
	const _vector$3 = /*@__PURE__*/ new Vector3();

	/**
	 * Frustums are used to determine what is inside the camera's field of view.
	 * They help speed up the rendering process - objects which lie outside a camera's
	 * frustum can safely be excluded from rendering.
	 *
	 * This class is mainly intended for use internally by a renderer.
	 */
	class Frustum {

		/**
		 * Constructs a new frustum.
		 *
		 * @param {Plane} [p0] - The first plane that encloses the frustum.
		 * @param {Plane} [p1] - The second plane that encloses the frustum.
		 * @param {Plane} [p2] - The third plane that encloses the frustum.
		 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
		 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
		 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
		 */
		constructor( p0 = new Plane$1(), p1 = new Plane$1(), p2 = new Plane$1(), p3 = new Plane$1(), p4 = new Plane$1(), p5 = new Plane$1() ) {

			/**
			 * This array holds the planes that enclose the frustum.
			 *
			 * @type {Array<Plane>}
			 */
			this.planes = [ p0, p1, p2, p3, p4, p5 ];

		}

		/**
		 * Sets the frustum planes by copying the given planes.
		 *
		 * @param {Plane} [p0] - The first plane that encloses the frustum.
		 * @param {Plane} [p1] - The second plane that encloses the frustum.
		 * @param {Plane} [p2] - The third plane that encloses the frustum.
		 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
		 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
		 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
		 * @return {Frustum} A reference to this frustum.
		 */
		set( p0, p1, p2, p3, p4, p5 ) {

			const planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		}

		/**
		 * Copies the values of the given frustum to this instance.
		 *
		 * @param {Frustum} frustum - The frustum to copy.
		 * @return {Frustum} A reference to this frustum.
		 */
		copy( frustum ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		}

		/**
		 * Sets the frustum planes from the given projection matrix.
		 *
		 * @param {Matrix4} m - The projection matrix.
		 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
		 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
		 * @return {Frustum} A reference to this frustum.
		 */
		setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {

			const planes = this.planes;
			const me = m.elements;
			const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();

			if ( reversedDepth ) {

				planes[ 4 ].setComponents( me2, me6, me10, me14 ).normalize(); // far
				planes[ 5 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); // near

			} else {

				planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); // far

				if ( coordinateSystem === WebGLCoordinateSystem ) {

					planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize(); // near

				} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

					planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize(); // near

				} else {

					throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

				}

			}

			return this;

		}

		/**
		 * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
		 *
		 * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
		 *
		 * @param {Object3D} object - The 3D object to test.
		 * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
		 */
		intersectsObject( object ) {

			if ( object.boundingSphere !== undefined ) {

				if ( object.boundingSphere === null ) object.computeBoundingSphere();

				_sphere$1.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

			} else {

				const geometry = object.geometry;

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

			}

			return this.intersectsSphere( _sphere$1 );

		}

		/**
		 * Returns `true` if the given sprite is intersecting this frustum.
		 *
		 * @param {Sprite} sprite - The sprite to test.
		 * @return {boolean} Whether the sprite is intersecting this frustum or not.
		 */
		intersectsSprite( sprite ) {

			_sphere$1.center.set( 0, 0, 0 );

			const offset = _defaultSpriteCenter.distanceTo( sprite.center );

			_sphere$1.radius = 0.7071067811865476 + offset;
			_sphere$1.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( _sphere$1 );

		}

		/**
		 * Returns `true` if the given bounding sphere is intersecting this frustum.
		 *
		 * @param {Sphere} sphere - The bounding sphere to test.
		 * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
		 */
		intersectsSphere( sphere ) {

			const planes = this.planes;
			const center = sphere.center;
			const negRadius = - sphere.radius;

			for ( let i = 0; i < 6; i ++ ) {

				const distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		}

		/**
		 * Returns `true` if the given bounding box is intersecting this frustum.
		 *
		 * @param {Box3} box - The bounding box to test.
		 * @return {boolean} Whether the bounding box is intersecting this frustum or not.
		 */
		intersectsBox( box ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				const plane = planes[ i ];

				// corner at max distance

				_vector$3.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$3.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$3.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if ( plane.distanceToPoint( _vector$3 ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		/**
		 * Returns `true` if the given point lies within the frustum.
		 *
		 * @param {Vector3} point - The point to test.
		 * @return {boolean} Whether the point lies within this frustum or not.
		 */
		containsPoint( point ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		/**
		 * Returns a new frustum with copied values from this instance.
		 *
		 * @return {Frustum} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

	}

	/**
	 * Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers
	 * (labeled x, y, z and w), which can be used to represent a number of things, such as:
	 *
	 * - A point in 4D space.
	 * - A direction and length in 4D space. In three.js the length will
	 * always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`
	 * and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.
	 * - Any arbitrary ordered quadruplet of numbers.
	 *
	 * There are other things a 4D vector can be used to represent, however these
	 * are the most common uses in *three.js*.
	 *
	 * Iterating through a vector instance will yield its components `(x, y, z, w)` in
	 * the corresponding order.
	 * ```js
	 * const a = new THREE.Vector4( 0, 1, 0, 0 );
	 *
	 * //no arguments; will be initialised to (0, 0, 0, 1)
	 * const b = new THREE.Vector4( );
	 *
	 * const d = a.dot( b );
	 * ```
	 */
	class Vector4 {

		/**
		 * Constructs a new 4D vector.
		 *
		 * @param {number} [x=0] - The x value of this vector.
		 * @param {number} [y=0] - The y value of this vector.
		 * @param {number} [z=0] - The z value of this vector.
		 * @param {number} [w=1] - The w value of this vector.
		 */
		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			Vector4.prototype.isVector4 = true;

			/**
			 * The x value of this vector.
			 *
			 * @type {number}
			 */
			this.x = x;

			/**
			 * The y value of this vector.
			 *
			 * @type {number}
			 */
			this.y = y;

			/**
			 * The z value of this vector.
			 *
			 * @type {number}
			 */
			this.z = z;

			/**
			 * The w value of this vector.
			 *
			 * @type {number}
			 */
			this.w = w;

		}

		/**
		 * Alias for {@link Vector4#z}.
		 *
		 * @type {number}
		 */
		get width() {

			return this.z;

		}

		set width( value ) {

			this.z = value;

		}

		/**
		 * Alias for {@link Vector4#w}.
		 *
		 * @type {number}
		 */
		get height() {

			return this.w;

		}

		set height( value ) {

			this.w = value;

		}

		/**
		 * Sets the vector components.
		 *
		 * @param {number} x - The value of the x component.
		 * @param {number} y - The value of the y component.
		 * @param {number} z - The value of the z component.
		 * @param {number} w - The value of the w component.
		 * @return {Vector4} A reference to this vector.
		 */
		set( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		}

		/**
		 * Sets the vector components to the same value.
		 *
		 * @param {number} scalar - The value to set for all vector components.
		 * @return {Vector4} A reference to this vector.
		 */
		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		}

		/**
		 * Sets the vector's x component to the given value
		 *
		 * @param {number} x - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */
		setX( x ) {

			this.x = x;

			return this;

		}

		/**
		 * Sets the vector's y component to the given value
		 *
		 * @param {number} y - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */
		setY( y ) {

			this.y = y;

			return this;

		}

		/**
		 * Sets the vector's z component to the given value
		 *
		 * @param {number} z - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */
		setZ( z ) {

			this.z = z;

			return this;

		}

		/**
		 * Sets the vector's w component to the given value
		 *
		 * @param {number} w - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */
		setW( w ) {

			this.w = w;

			return this;

		}

		/**
		 * Allows to set a vector component with an index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
		 * `2` equals to z, `3` equals to w.
		 * @param {number} value - The value to set.
		 * @return {Vector4} A reference to this vector.
		 */
		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		/**
		 * Returns the value of the vector component which matches the given index.
		 *
		 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
		 * `2` equals to z, `3` equals to w.
		 * @return {number} A vector component value.
		 */
		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		/**
		 * Returns a new vector with copied values from this instance.
		 *
		 * @return {Vector4} A clone of this instance.
		 */
		clone() {

			return new this.constructor( this.x, this.y, this.z, this.w );

		}

		/**
		 * Copies the values of the given vector to this instance.
		 *
		 * @param {Vector3|Vector4} v - The vector to copy.
		 * @return {Vector4} A reference to this vector.
		 */
		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		}

		/**
		 * Adds the given vector to this instance.
		 *
		 * @param {Vector4} v - The vector to add.
		 * @return {Vector4} A reference to this vector.
		 */
		add( v ) {

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		}

		/**
		 * Adds the given scalar value to all components of this instance.
		 *
		 * @param {number} s - The scalar to add.
		 * @return {Vector4} A reference to this vector.
		 */
		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		}

		/**
		 * Adds the given vectors and stores the result in this instance.
		 *
		 * @param {Vector4} a - The first vector.
		 * @param {Vector4} b - The second vector.
		 * @return {Vector4} A reference to this vector.
		 */
		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		}

		/**
		 * Adds the given vector scaled by the given factor to this instance.
		 *
		 * @param {Vector4} v - The vector.
		 * @param {number} s - The factor that scales `v`.
		 * @return {Vector4} A reference to this vector.
		 */
		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		}

		/**
		 * Subtracts the given vector from this instance.
		 *
		 * @param {Vector4} v - The vector to subtract.
		 * @return {Vector4} A reference to this vector.
		 */
		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		}

		/**
		 * Subtracts the given scalar value from all components of this instance.
		 *
		 * @param {number} s - The scalar to subtract.
		 * @return {Vector4} A reference to this vector.
		 */
		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		}

		/**
		 * Subtracts the given vectors and stores the result in this instance.
		 *
		 * @param {Vector4} a - The first vector.
		 * @param {Vector4} b - The second vector.
		 * @return {Vector4} A reference to this vector.
		 */
		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		}

		/**
		 * Multiplies the given vector with this instance.
		 *
		 * @param {Vector4} v - The vector to multiply.
		 * @return {Vector4} A reference to this vector.
		 */
		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;

			return this;

		}

		/**
		 * Multiplies the given scalar value with all components of this instance.
		 *
		 * @param {number} scalar - The scalar to multiply.
		 * @return {Vector4} A reference to this vector.
		 */
		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		}

		/**
		 * Multiplies this vector with the given 4x4 matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Vector4} A reference to this vector.
		 */
		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z, w = this.w;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		}

		/**
		 * Divides this instance by the given vector.
		 *
		 * @param {Vector4} v - The vector to divide.
		 * @return {Vector4} A reference to this vector.
		 */
		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
			this.w /= v.w;

			return this;

		}

		/**
		 * Divides this vector by the given scalar.
		 *
		 * @param {number} scalar - The scalar to divide.
		 * @return {Vector4} A reference to this vector.
		 */
		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		/**
		 * Sets the x, y and z components of this
		 * vector to the quaternion's axis and w to the angle.
		 *
		 * @param {Quaternion} q - The Quaternion to set.
		 * @return {Vector4} A reference to this vector.
		 */
		setAxisAngleFromQuaternion( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			const s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		}

		/**
		 * Sets the x, y and z components of this
		 * vector to the axis of rotation and w to the angle.
		 *
		 * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
		 * @return {Vector4} A reference to this vector.
		 */
		setAxisAngleFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			let angle, x, y, z; // variables for result
			const epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				const xx = ( m11 + 1 ) / 2;
				const yy = ( m22 + 1 ) / 2;
				const zz = ( m33 + 1 ) / 2;
				const xy = ( m12 + m21 ) / 4;
				const xz = ( m13 + m31 ) / 4;
				const yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				( m13 - m31 ) * ( m13 - m31 ) +
				( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		}

		/**
		 * Sets the vector components to the position elements of the
		 * given transformation matrix.
		 *
		 * @param {Matrix4} m - The 4x4 matrix.
		 * @return {Vector4} A reference to this vector.
		 */
		setFromMatrixPosition( m ) {

			const e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];
			this.w = e[ 15 ];

			return this;

		}

		/**
		 * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
		 * value, replace that value with the corresponding min value.
		 *
		 * @param {Vector4} v - The vector.
		 * @return {Vector4} A reference to this vector.
		 */
		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		}

		/**
		 * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
		 * value, replace that value with the corresponding max value.
		 *
		 * @param {Vector4} v - The vector.
		 * @return {Vector4} A reference to this vector.
		 */
		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		}

		/**
		 * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
		 * value, it is replaced by the corresponding value.
		 * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
		 * it is replaced by the corresponding value.
		 *
		 * @param {Vector4} min - The minimum x, y and z values.
		 * @param {Vector4} max - The maximum x, y and z values in the desired range.
		 * @return {Vector4} A reference to this vector.
		 */
		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = clamp( this.x, min.x, max.x );
			this.y = clamp( this.y, min.y, max.y );
			this.z = clamp( this.z, min.z, max.z );
			this.w = clamp( this.w, min.w, max.w );

			return this;

		}

		/**
		 * If this vector's x, y, z or w values are greater than the max value, they are
		 * replaced by the max value.
		 * If this vector's x, y, z or w values are less than the min value, they are
		 * replaced by the min value.
		 *
		 * @param {number} minVal - The minimum value the components will be clamped to.
		 * @param {number} maxVal - The maximum value the components will be clamped to.
		 * @return {Vector4} A reference to this vector.
		 */
		clampScalar( minVal, maxVal ) {

			this.x = clamp( this.x, minVal, maxVal );
			this.y = clamp( this.y, minVal, maxVal );
			this.z = clamp( this.z, minVal, maxVal );
			this.w = clamp( this.w, minVal, maxVal );

			return this;

		}

		/**
		 * If this vector's length is greater than the max value, it is replaced by
		 * the max value.
		 * If this vector's length is less than the min value, it is replaced by the
		 * min value.
		 *
		 * @param {number} min - The minimum value the vector length will be clamped to.
		 * @param {number} max - The maximum value the vector length will be clamped to.
		 * @return {Vector4} A reference to this vector.
		 */
		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

		}

		/**
		 * The components of this vector are rounded down to the nearest integer value.
		 *
		 * @return {Vector4} A reference to this vector.
		 */
		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		}

		/**
		 * The components of this vector are rounded up to the nearest integer value.
		 *
		 * @return {Vector4} A reference to this vector.
		 */
		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		}

		/**
		 * The components of this vector are rounded to the nearest integer value
		 *
		 * @return {Vector4} A reference to this vector.
		 */
		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		}

		/**
		 * The components of this vector are rounded towards zero (up if negative,
		 * down if positive) to an integer value.
		 *
		 * @return {Vector4} A reference to this vector.
		 */
		roundToZero() {

			this.x = Math.trunc( this.x );
			this.y = Math.trunc( this.y );
			this.z = Math.trunc( this.z );
			this.w = Math.trunc( this.w );

			return this;

		}

		/**
		 * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
		 *
		 * @return {Vector4} A reference to this vector.
		 */
		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		}

		/**
		 * Calculates the dot product of the given vector with this instance.
		 *
		 * @param {Vector4} v - The vector to compute the dot product with.
		 * @return {number} The result of the dot product.
		 */
		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		}

		/**
		 * Computes the square of the Euclidean length (straight-line length) from
		 * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
		 * compare the length squared instead as it is slightly more efficient to calculate.
		 *
		 * @return {number} The square length of this vector.
		 */
		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		}

		/**
		 * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
		 *
		 * @return {number} The length of this vector.
		 */
		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		}

		/**
		 * Computes the Manhattan length of this vector.
		 *
		 * @return {number} The length of this vector.
		 */
		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		}

		/**
		 * Converts this vector to a unit vector - that is, sets it equal to a vector
		 * with the same direction as this one, but with a vector length of `1`.
		 *
		 * @return {Vector4} A reference to this vector.
		 */
		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		/**
		 * Sets this vector to a vector with the same direction as this one, but
		 * with the specified length.
		 *
		 * @param {number} length - The new length of this vector.
		 * @return {Vector4} A reference to this vector.
		 */
		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		/**
		 * Linearly interpolates between the given vector and this instance, where
		 * alpha is the percent distance along the line - alpha = 0 will be this
		 * vector, and alpha = 1 will be the given one.
		 *
		 * @param {Vector4} v - The vector to interpolate towards.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector4} A reference to this vector.
		 */
		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		}

		/**
		 * Linearly interpolates between the given vectors, where alpha is the percent
		 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
		 * be the second one. The result is stored in this instance.
		 *
		 * @param {Vector4} v1 - The first vector.
		 * @param {Vector4} v2 - The second vector.
		 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
		 * @return {Vector4} A reference to this vector.
		 */
		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;
			this.w = v1.w + ( v2.w - v1.w ) * alpha;

			return this;

		}

		/**
		 * Returns `true` if this vector is equal with the given one.
		 *
		 * @param {Vector4} v - The vector to test for equality.
		 * @return {boolean} Whether this vector is equal with the given one.
		 */
		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		}

		/**
		 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
		 * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
		 *
		 * @param {Array<number>} array - An array holding the vector component values.
		 * @param {number} [offset=0] - The offset into the array.
		 * @return {Vector4} A reference to this vector.
		 */
		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		}

		/**
		 * Writes the components of this vector to the given array. If no array is provided,
		 * the method returns a new instance.
		 *
		 * @param {Array<number>} [array=[]] - The target array holding the vector components.
		 * @param {number} [offset=0] - Index of the first element in the array.
		 * @return {Array<number>} The vector components.
		 */
		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		}

		/**
		 * Sets the components of this vector from the given buffer attribute.
		 *
		 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
		 * @param {number} index - The index into the attribute.
		 * @return {Vector4} A reference to this vector.
		 */
		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

		/**
		 * Sets each component of this vector to a pseudo-random value between `0` and
		 * `1`, excluding `1`.
		 *
		 * @return {Vector4} A reference to this vector.
		 */
		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;
			yield this.w;

		}

	}

	function WebGLAnimation() {

		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame( time, frame ) {

			animationLoop( time, frame );

			requestId = context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				requestId = context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				context.cancelAnimationFrame( requestId );

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	function WebGLAttributes( gl ) {

		const buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			const array = attribute.array;
			const usage = attribute.usage;
			const size = array.byteLength;

			const buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			let type;

			if ( array instanceof Float32Array ) {

				type = gl.FLOAT;

			} else if ( typeof Float16Array !== 'undefined' && array instanceof Float16Array ) {

				type = gl.HALF_FLOAT;

			} else if ( array instanceof Uint16Array ) {

				if ( attribute.isFloat16BufferAttribute ) {

					type = gl.HALF_FLOAT;

				} else {

					type = gl.UNSIGNED_SHORT;

				}

			} else if ( array instanceof Int16Array ) {

				type = gl.SHORT;

			} else if ( array instanceof Uint32Array ) {

				type = gl.UNSIGNED_INT;

			} else if ( array instanceof Int32Array ) {

				type = gl.INT;

			} else if ( array instanceof Int8Array ) {

				type = gl.BYTE;

			} else if ( array instanceof Uint8Array ) {

				type = gl.UNSIGNED_BYTE;

			} else if ( array instanceof Uint8ClampedArray ) {

				type = gl.UNSIGNED_BYTE;

			} else {

				throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version,
				size: size
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			const array = attribute.array;
			const updateRanges = attribute.updateRanges;

			gl.bindBuffer( bufferType, buffer );

			if ( updateRanges.length === 0 ) {

				// Not using update ranges
				gl.bufferSubData( bufferType, 0, array );

			} else {

				// Before applying update ranges, we merge any adjacent / overlapping
				// ranges to reduce load on `gl.bufferSubData`. Empirically, this has led
				// to performance improvements for applications which make heavy use of
				// update ranges. Likely due to GPU command overhead.
				//
				// Note that to reduce garbage collection between frames, we merge the
				// update ranges in-place. This is safe because this method will clear the
				// update ranges once updated.

				updateRanges.sort( ( a, b ) => a.start - b.start );

				// To merge the update ranges in-place, we work from left to right in the
				// existing updateRanges array, merging ranges. This may result in a final
				// array which is smaller than the original. This index tracks the last
				// index representing a merged range, any data after this index can be
				// trimmed once the merge algorithm is completed.
				let mergeIndex = 0;

				for ( let i = 1; i < updateRanges.length; i ++ ) {

					const previousRange = updateRanges[ mergeIndex ];
					const range = updateRanges[ i ];

					// We add one here to merge adjacent ranges. This is safe because ranges
					// operate over positive integers.
					if ( range.start <= previousRange.start + previousRange.count + 1 ) {

						previousRange.count = Math.max(
							previousRange.count,
							range.start + range.count - previousRange.start
						);

					} else {

						++ mergeIndex;
						updateRanges[ mergeIndex ] = range;

					}

				}

				// Trim the array to only contain the merged ranges.
				updateRanges.length = mergeIndex + 1;

				for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

					const range = updateRanges[ i ];

					gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
						array, range.start, range.count );

				}

				attribute.clearUpdateRanges();

			}

			attribute.onUploadCallback();

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			if ( attribute.isGLBufferAttribute ) {

				const cached = buffers.get( attribute );

				if ( ! cached || cached.version < attribute.version ) {

					buffers.set( attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					} );

				}

				return;

			}

			const data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				if ( data.size !== attribute.array.byteLength ) {

					throw new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );

				}

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	const _vector$2 = /*@__PURE__*/ new Vector3();
	const _vector2 = /*@__PURE__*/ new Vector2();

	let _id$2 = 0;

	/**
	 * This class stores data for an attribute (such as vertex positions, face
	 * indices, normals, colors, UVs, and any custom attributes ) associated with
	 * a geometry, which allows for more efficient passing of data to the GPU.
	 *
	 * When working with vector-like data, the `fromBufferAttribute( attribute, index )`
	 * helper methods on vector and color class might be helpful. E.g. {@link Vector3#fromBufferAttribute}.
	 */
	class BufferAttribute {

		/**
		 * Constructs a new buffer attribute.
		 *
		 * @param {TypedArray} array - The array holding the attribute data.
		 * @param {number} itemSize - The item size.
		 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
		 */
		constructor( array, itemSize, normalized = false ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isBufferAttribute = true;

			/**
			 * The ID of the buffer attribute.
			 *
			 * @name BufferAttribute#id
			 * @type {number}
			 * @readonly
			 */
			Object.defineProperty( this, 'id', { value: _id$2 ++ } );

			/**
			 * The name of the buffer attribute.
			 *
			 * @type {string}
			 */
			this.name = '';

			/**
			 * The array holding the attribute data. It should have `itemSize * numVertices`
			 * elements, where `numVertices` is the number of vertices in the associated geometry.
			 *
			 * @type {TypedArray}
			 */
			this.array = array;

			/**
			 * The number of values of the array that should be associated with a particular vertex.
			 * For instance, if this attribute is storing a 3-component vector (such as a position,
			 * normal, or color), then the value should be `3`.
			 *
			 * @type {number}
			 */
			this.itemSize = itemSize;

			/**
			 * Represents the number of items this buffer attribute stores. It is internally computed
			 * by dividing the `array` length by the `itemSize`.
			 *
			 * @type {number}
			 * @readonly
			 */
			this.count = array !== undefined ? array.length / itemSize : 0;

			/**
			 * Applies to integer data only. Indicates how the underlying data in the buffer maps to
			 * the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
			 * and `normalized` is `true`, the values `0 - +65535` in the array data will be mapped to
			 * `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
			 * to floats unmodified, i.e. `65535` becomes `65535.0f`.
			 *
			 * @type {boolean}
			 */
			this.normalized = normalized;

			/**
			 * Defines the intended usage pattern of the data store for optimization purposes.
			 *
			 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
			 * instantiate a new one and set the desired usage before the next render.
			 *
			 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
			 * @default StaticDrawUsage
			 */
			this.usage = StaticDrawUsage;

			/**
			 * This can be used to only update some components of stored vectors (for example, just the
			 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
			 *
			 * @type {Array<Object>}
			 */
			this.updateRanges = [];

			/**
			 * Configures the bound GPU type for use in shaders.
			 *
			 * Note: this only has an effect for integer arrays and is not configurable for float arrays.
			 * For lower precision float types, use `Float16BufferAttribute`.
			 *
			 * @type {(FloatType|IntType)}
			 * @default FloatType
			 */
			this.gpuType = FloatType;

			/**
			 * A version number, incremented every time the `needsUpdate` is set to `true`.
			 *
			 * @type {number}
			 */
			this.version = 0;

		}

		/**
		 * A callback function that is executed after the renderer has transferred the attribute
		 * array data to the GPU.
		 */
		onUploadCallback() {}

		/**
		 * Flag to indicate that this attribute has changed and should be re-sent to
		 * the GPU. Set this to `true` when you modify the value of the array.
		 *
		 * @type {number}
		 * @default false
		 * @param {boolean} value
		 */
		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		/**
		 * Sets the usage of this buffer attribute.
		 *
		 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
		 * @return {BufferAttribute} A reference to this buffer attribute.
		 */
		setUsage( value ) {

			this.usage = value;

			return this;

		}

		/**
		 * Adds a range of data in the data array to be updated on the GPU.
		 *
		 * @param {number} start - Position at which to start update.
		 * @param {number} count - The number of components to update.
		 */
		addUpdateRange( start, count ) {

			this.updateRanges.push( { start, count } );

		}

		/**
		 * Clears the update ranges.
		 */
		clearUpdateRanges() {

			this.updateRanges.length = 0;

		}

		/**
		 * Copies the values of the given buffer attribute to this instance.
		 *
		 * @param {BufferAttribute} source - The buffer attribute to copy.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		copy( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.usage = source.usage;
			this.gpuType = source.gpuType;

			return this;

		}

		/**
		 * Copies a vector from the given buffer attribute to this one. The start
		 * and destination position in the attribute buffers are represented by the
		 * given indices.
		 *
		 * @param {number} index1 - The destination index into this buffer attribute.
		 * @param {BufferAttribute} attribute - The buffer attribute to copy from.
		 * @param {number} index2 - The source index into the given buffer attribute.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		copyAt( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		}

		/**
		 * Copies the given array data into this buffer attribute.
		 *
		 * @param {(TypedArray|Array)} array - The array to copy.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		copyArray( array ) {

			this.array.set( array );

			return this;

		}

		/**
		 * Applies the given 3x3 matrix to the given attribute. Works with
		 * item size `2` and `3`.
		 *
		 * @param {Matrix3} m - The matrix to apply.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		applyMatrix3( m ) {

			if ( this.itemSize === 2 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector2.fromBufferAttribute( this, i );
					_vector2.applyMatrix3( m );

					this.setXY( i, _vector2.x, _vector2.y );

				}

			} else if ( this.itemSize === 3 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector$2.fromBufferAttribute( this, i );
					_vector$2.applyMatrix3( m );

					this.setXYZ( i, _vector$2.x, _vector$2.y, _vector$2.z );

				}

			}

			return this;

		}

		/**
		 * Applies the given 4x4 matrix to the given attribute. Only works with
		 * item size `3`.
		 *
		 * @param {Matrix4} m - The matrix to apply.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		applyMatrix4( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$2.fromBufferAttribute( this, i );

				_vector$2.applyMatrix4( m );

				this.setXYZ( i, _vector$2.x, _vector$2.y, _vector$2.z );

			}

			return this;

		}

		/**
		 * Applies the given 3x3 normal matrix to the given attribute. Only works with
		 * item size `3`.
		 *
		 * @param {Matrix3} m - The normal matrix to apply.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		applyNormalMatrix( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$2.fromBufferAttribute( this, i );

				_vector$2.applyNormalMatrix( m );

				this.setXYZ( i, _vector$2.x, _vector$2.y, _vector$2.z );

			}

			return this;

		}

		/**
		 * Applies the given 4x4 matrix to the given attribute. Only works with
		 * item size `3` and with direction vectors.
		 *
		 * @param {Matrix4} m - The matrix to apply.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		transformDirection( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$2.fromBufferAttribute( this, i );

				_vector$2.transformDirection( m );

				this.setXYZ( i, _vector$2.x, _vector$2.y, _vector$2.z );

			}

			return this;

		}

		/**
		 * Sets the given array data in the buffer attribute.
		 *
		 * @param {(TypedArray|Array)} value - The array data to set.
		 * @param {number} [offset=0] - The offset in this buffer attribute's array.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		set( value, offset = 0 ) {

			// Matching BufferAttribute constructor, do not normalize the array.
			this.array.set( value, offset );

			return this;

		}

		/**
		 * Returns the given component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} component - The component index.
		 * @return {number} The returned value.
		 */
		getComponent( index, component ) {

			let value = this.array[ index * this.itemSize + component ];

			if ( this.normalized ) value = denormalize( value, this.array );

			return value;

		}

		/**
		 * Sets the given value to the given component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} component - The component index.
		 * @param {number} value - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		setComponent( index, component, value ) {

			if ( this.normalized ) value = normalize( value, this.array );

			this.array[ index * this.itemSize + component ] = value;

			return this;

		}

		/**
		 * Returns the x component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @return {number} The x component.
		 */
		getX( index ) {

			let x = this.array[ index * this.itemSize ];

			if ( this.normalized ) x = denormalize( x, this.array );

			return x;

		}

		/**
		 * Sets the x component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} x - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		setX( index, x ) {

			if ( this.normalized ) x = normalize( x, this.array );

			this.array[ index * this.itemSize ] = x;

			return this;

		}

		/**
		 * Returns the y component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @return {number} The y component.
		 */
		getY( index ) {

			let y = this.array[ index * this.itemSize + 1 ];

			if ( this.normalized ) y = denormalize( y, this.array );

			return y;

		}

		/**
		 * Sets the y component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} y - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		setY( index, y ) {

			if ( this.normalized ) y = normalize( y, this.array );

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		}

		/**
		 * Returns the z component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @return {number} The z component.
		 */
		getZ( index ) {

			let z = this.array[ index * this.itemSize + 2 ];

			if ( this.normalized ) z = denormalize( z, this.array );

			return z;

		}

		/**
		 * Sets the z component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} z - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		setZ( index, z ) {

			if ( this.normalized ) z = normalize( z, this.array );

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		}

		/**
		 * Returns the w component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @return {number} The w component.
		 */
		getW( index ) {

			let w = this.array[ index * this.itemSize + 3 ];

			if ( this.normalized ) w = denormalize( w, this.array );

			return w;

		}

		/**
		 * Sets the w component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} w - The value to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		setW( index, w ) {

			if ( this.normalized ) w = normalize( w, this.array );

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		}

		/**
		 * Sets the x and y component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} x - The value for the x component to set.
		 * @param {number} y - The value for the y component to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		setXY( index, x, y ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );

			}

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		}

		/**
		 * Sets the x, y and z component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} x - The value for the x component to set.
		 * @param {number} y - The value for the y component to set.
		 * @param {number} z - The value for the z component to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		setXYZ( index, x, y, z ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );
				z = normalize( z, this.array );

			}

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		}

		/**
		 * Sets the x, y, z and w component of the vector at the given index.
		 *
		 * @param {number} index - The index into the buffer attribute.
		 * @param {number} x - The value for the x component to set.
		 * @param {number} y - The value for the y component to set.
		 * @param {number} z - The value for the z component to set.
		 * @param {number} w - The value for the w component to set.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		setXYZW( index, x, y, z, w ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );
				z = normalize( z, this.array );
				w = normalize( w, this.array );

			}

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		}

		/**
		 * Sets the given callback function that is executed after the Renderer has transferred
		 * the attribute array data to the GPU. Can be used to perform clean-up operations after
		 * the upload when attribute data are not needed anymore on the CPU side.
		 *
		 * @param {Function} callback - The `onUpload()` callback.
		 * @return {BufferAttribute} A reference to this instance.
		 */
		onUpload( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

		/**
		 * Returns a new buffer attribute with copied values from this instance.
		 *
		 * @return {BufferAttribute} A clone of this instance.
		 */
		clone() {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

		/**
		 * Serializes the buffer attribute into JSON.
		 *
		 * @return {Object} A JSON object representing the serialized buffer attribute.
		 */
		toJSON() {

			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.from( this.array ),
				normalized: this.normalized
			};

			if ( this.name !== '' ) data.name = this.name;
			if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

			return data;

		}

	}

	/**
	 * Convenient class that can be used when creating a `UInt16` buffer attribute with
	 * a plain `Array` instance.
	 *
	 * @augments BufferAttribute
	 */
	class Uint16BufferAttribute extends BufferAttribute {

		/**
		 * Constructs a new buffer attribute.
		 *
		 * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
		 * @param {number} itemSize - The item size.
		 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
		 */
		constructor( array, itemSize, normalized ) {

			super( new Uint16Array( array ), itemSize, normalized );

		}

	}

	/**
	 * Convenient class that can be used when creating a `UInt32` buffer attribute with
	 * a plain `Array` instance.
	 *
	 * @augments BufferAttribute
	 */
	class Uint32BufferAttribute extends BufferAttribute {

		/**
		 * Constructs a new buffer attribute.
		 *
		 * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
		 * @param {number} itemSize - The item size.
		 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
		 */
		constructor( array, itemSize, normalized ) {

			super( new Uint32Array( array ), itemSize, normalized );

		}

	}

	/**
	 * Convenient class that can be used when creating a `Float32` buffer attribute with
	 * a plain `Array` instance.
	 *
	 * @augments BufferAttribute
	 */
	class Float32BufferAttribute extends BufferAttribute {

		/**
		 * Constructs a new buffer attribute.
		 *
		 * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
		 * @param {number} itemSize - The item size.
		 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
		 */
		constructor( array, itemSize, normalized ) {

			super( new Float32Array( array ), itemSize, normalized );

		}

	}

	let _id$1 = 0;

	const _m1$2 = /*@__PURE__*/ new Matrix4();
	const _obj = /*@__PURE__*/ new Object3D();
	const _offset = /*@__PURE__*/ new Vector3();
	const _box = /*@__PURE__*/ new Box3();
	const _boxMorphTargets = /*@__PURE__*/ new Box3();
	const _vector$1 = /*@__PURE__*/ new Vector3();

	/**
	 * A representation of mesh, line, or point geometry. Includes vertex
	 * positions, face indices, normals, colors, UVs, and custom attributes
	 * within buffers, reducing the cost of passing all this data to the GPU.
	 *
	 * ```js
	 * const geometry = new THREE.BufferGeometry();
	 * // create a simple square shape. We duplicate the top left and bottom right
	 * // vertices because each vertex needs to appear once per triangle.
	 * const vertices = new Float32Array( [
	 * 	-1.0, -1.0,  1.0, // v0
	 * 	 1.0, -1.0,  1.0, // v1
	 * 	 1.0,  1.0,  1.0, // v2
	 *
	 * 	 1.0,  1.0,  1.0, // v3
	 * 	-1.0,  1.0,  1.0, // v4
	 * 	-1.0, -1.0,  1.0  // v5
	 * ] );
	 * // itemSize = 3 because there are 3 values (components) per vertex
	 * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
	 * const mesh = new THREE.Mesh( geometry, material );
	 * ```
	 *
	 * @augments EventDispatcher
	 */
	class BufferGeometry extends EventDispatcher {

		/**
		 * Constructs a new geometry.
		 */
		constructor() {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isBufferGeometry = true;

			/**
			 * The ID of the geometry.
			 *
			 * @name BufferGeometry#id
			 * @type {number}
			 * @readonly
			 */
			Object.defineProperty( this, 'id', { value: _id$1 ++ } );

			/**
			 * The UUID of the geometry.
			 *
			 * @type {string}
			 * @readonly
			 */
			this.uuid = generateUUID();

			/**
			 * The name of the geometry.
			 *
			 * @type {string}
			 */
			this.name = '';
			this.type = 'BufferGeometry';

			/**
			 * Allows for vertices to be re-used across multiple triangles; this is
			 * called using "indexed triangles". Each triangle is associated with the
			 * indices of three vertices. This attribute therefore stores the index of
			 * each vertex for each triangular face. If this attribute is not set, the
			 * renderer assumes that each three contiguous positions represent a single triangle.
			 *
			 * @type {?BufferAttribute}
			 * @default null
			 */
			this.index = null;

			/**
			 * A (storage) buffer attribute which was generated with a compute shader and
			 * now defines indirect draw calls.
			 *
			 * Can only be used with {@link WebGPURenderer} and a WebGPU backend.
			 *
			 * @type {?BufferAttribute}
			 * @default null
			 */
			this.indirect = null;

			/**
			 * This dictionary has as id the name of the attribute to be set and as value
			 * the buffer attribute to set it to. Rather than accessing this property directly,
			 * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.
			 *
			 * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}
			 */
			this.attributes = {};

			/**
			 * This dictionary holds the morph targets of the geometry.
			 *
			 * Note: Once the geometry has been rendered, the morph attribute data cannot
			 * be changed. You will have to call `dispose()?, and create a new geometry instance.
			 *
			 * @type {Object}
			 */
			this.morphAttributes = {};

			/**
			 * Used to control the morph target behavior; when set to `true`, the morph
			 * target data is treated as relative offsets, rather than as absolute
			 * positions/normals.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.morphTargetsRelative = false;

			/**
			 * Split the geometry into groups, each of which will be rendered in a
			 * separate draw call. This allows an array of materials to be used with the geometry.
			 *
			 * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.
			 *
			 * Every vertex and index must belong to exactly one group  groups must not share vertices or
			 * indices, and must not leave vertices or indices unused.
			 *
			 * @type {Array<Object>}
			 */
			this.groups = [];

			/**
			 * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.
			 *
			 * @type {?Box3}
			 * @default null
			 */
			this.boundingBox = null;

			/**
			 * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.
			 *
			 * @type {?Sphere}
			 * @default null
			 */
			this.boundingSphere = null;

			/**
			 * Determines the part of the geometry to render. This should not be set directly,
			 * instead use `setDrawRange()`.
			 *
			 * @type {{start:number,count:number}}
			 */
			this.drawRange = { start: 0, count: Infinity };

			/**
			 * An object that can be used to store custom data about the geometry.
			 * It should not hold references to functions as these will not be cloned.
			 *
			 * @type {Object}
			 */
			this.userData = {};

		}

		/**
		 * Returns the index of this geometry.
		 *
		 * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
		 */
		getIndex() {

			return this.index;

		}

		/**
		 * Sets the given index to this geometry.
		 *
		 * @param {Array<number>|BufferAttribute} index - The index to set.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		setIndex( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

			return this;

		}

		/**
		 * Sets the given indirect attribute to this geometry.
		 *
		 * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		setIndirect( indirect ) {

			this.indirect = indirect;

			return this;

		}

		/**
		 * Returns the indirect attribute of this geometry.
		 *
		 * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
		 */
		getIndirect() {

			return this.indirect;

		}

		/**
		 * Returns the buffer attribute for the given name.
		 *
		 * @param {string} name - The attribute name.
		 * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
		 * Returns `undefined` if not attribute has been found.
		 */
		getAttribute( name ) {

			return this.attributes[ name ];

		}

		/**
		 * Sets the given attribute for the given name.
		 *
		 * @param {string} name - The attribute name.
		 * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		setAttribute( name, attribute ) {

			this.attributes[ name ] = attribute;

			return this;

		}

		/**
		 * Deletes the attribute for the given name.
		 *
		 * @param {string} name - The attribute name to delete.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		deleteAttribute( name ) {

			delete this.attributes[ name ];

			return this;

		}

		/**
		 * Returns `true` if this geometry has an attribute for the given name.
		 *
		 * @param {string} name - The attribute name.
		 * @return {boolean} Whether this geometry has an attribute for the given name or not.
		 */
		hasAttribute( name ) {

			return this.attributes[ name ] !== undefined;

		}

		/**
		 * Adds a group to this geometry.
		 *
		 * @param {number} start - The first element in this draw call. That is the first
		 * vertex for non-indexed geometry, otherwise the first triangle index.
		 * @param {number} count - Specifies how many vertices (or indices) are part of this group.
		 * @param {number} [materialIndex=0] - The material array index to use.
		 */
		addGroup( start, count, materialIndex = 0 ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		}

		/**
		 * Clears all groups.
		 */
		clearGroups() {

			this.groups = [];

		}

		/**
		 * Sets the draw range for this geometry.
		 *
		 * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
		 * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
		 * For indexed BufferGeometry, `count` is the number of indices to render.
		 */
		setDrawRange( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		}

		/**
		 * Applies the given 4x4 transformation matrix to the geometry.
		 *
		 * @param {Matrix4} matrix - The matrix to apply.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		applyMatrix4( matrix ) {

			const position = this.attributes.position;

			if ( position !== undefined ) {

				position.applyMatrix4( matrix );

				position.needsUpdate = true;

			}

			const normal = this.attributes.normal;

			if ( normal !== undefined ) {

				const normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normal.applyNormalMatrix( normalMatrix );

				normal.needsUpdate = true;

			}

			const tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				tangent.transformDirection( matrix );

				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		}

		/**
		 * Applies the rotation represented by the Quaternion to the geometry.
		 *
		 * @param {Quaternion} q - The Quaternion to apply.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		applyQuaternion( q ) {

			_m1$2.makeRotationFromQuaternion( q );

			this.applyMatrix4( _m1$2 );

			return this;

		}

		/**
		 * Rotates the geometry about the X axis. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		rotateX( angle ) {

			// rotate geometry around world x-axis

			_m1$2.makeRotationX( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		}

		/**
		 * Rotates the geometry about the Y axis. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		rotateY( angle ) {

			// rotate geometry around world y-axis

			_m1$2.makeRotationY( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		}

		/**
		 * Rotates the geometry about the Z axis. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} angle - The angle in radians.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		rotateZ( angle ) {

			// rotate geometry around world z-axis

			_m1$2.makeRotationZ( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		}

		/**
		 * Translates the geometry. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#position} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} x - The x offset.
		 * @param {number} y - The y offset.
		 * @param {number} z - The z offset.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		translate( x, y, z ) {

			// translate geometry

			_m1$2.makeTranslation( x, y, z );

			this.applyMatrix4( _m1$2 );

			return this;

		}

		/**
		 * Scales the geometry. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#scale} for typical
		 * real-time mesh rotation.
		 *
		 * @param {number} x - The x scale.
		 * @param {number} y - The y scale.
		 * @param {number} z - The z scale.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		scale( x, y, z ) {

			// scale geometry

			_m1$2.makeScale( x, y, z );

			this.applyMatrix4( _m1$2 );

			return this;

		}

		/**
		 * Rotates the geometry to face a point in 3D space. This is typically done as a one time
		 * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
		 * real-time mesh rotation.
		 *
		 * @param {Vector3} vector - The target point.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		lookAt( vector ) {

			_obj.lookAt( vector );

			_obj.updateMatrix();

			this.applyMatrix4( _obj.matrix );

			return this;

		}

		/**
		 * Center the geometry based on its bounding box.
		 *
		 * @return {BufferGeometry} A reference to this instance.
		 */
		center() {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset ).negate();

			this.translate( _offset.x, _offset.y, _offset.z );

			return this;

		}

		/**
		 * Defines a geometry by creating a `position` attribute based on the given array of points. The array
		 * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
		 * set to `0`.
		 *
		 * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
		 * data from the array. The length of the array must match the vertex count.
		 *
		 * @param {Array<Vector2>|Array<Vector3>} points - The points.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		setFromPoints( points ) {

			const positionAttribute = this.getAttribute( 'position' );

			if ( positionAttribute === undefined ) {

				const position = [];

				for ( let i = 0, l = points.length; i < l; i ++ ) {

					const point = points[ i ];
					position.push( point.x, point.y, point.z || 0 );

				}

				this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			} else {

				const l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size

				for ( let i = 0; i < l; i ++ ) {

					const point = points[ i ];
					positionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );

				}

				if ( points.length > positionAttribute.count ) {

					warn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );

				}

				positionAttribute.needsUpdate = true;

			}

			return this;

		}

		/**
		 * Computes the bounding box of the geometry, and updates the `boundingBox` member.
		 * The bounding box is not computed by the engine; it must be computed by your app.
		 * You may need to recompute the bounding box if the geometry vertices are modified.
		 */
		computeBoundingBox() {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				error( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

				this.boundingBox.set(
					new Vector3( - Infinity, - Infinity, - Infinity ),
					new Vector3( + Infinity, + Infinity, + Infinity )
				);

				return;

			}

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_box.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$1.addVectors( this.boundingBox.min, _box.min );
							this.boundingBox.expandByPoint( _vector$1 );

							_vector$1.addVectors( this.boundingBox.max, _box.max );
							this.boundingBox.expandByPoint( _vector$1 );

						} else {

							this.boundingBox.expandByPoint( _box.min );
							this.boundingBox.expandByPoint( _box.max );

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				error( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		}

		/**
		 * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
		 * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
		 * You may need to recompute the bounding sphere if the geometry vertices are modified.
		 */
		computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere$1();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				error( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

				this.boundingSphere.set( new Vector3(), Infinity );

				return;

			}

			if ( position ) {

				// first, find the center of the bounding sphere

				const center = this.boundingSphere.center;

				_box.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_boxMorphTargets.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$1.addVectors( _box.min, _boxMorphTargets.min );
							_box.expandByPoint( _vector$1 );

							_vector$1.addVectors( _box.max, _boxMorphTargets.max );
							_box.expandByPoint( _vector$1 );

						} else {

							_box.expandByPoint( _boxMorphTargets.min );
							_box.expandByPoint( _boxMorphTargets.max );

						}

					}

				}

				_box.getCenter( center );

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				let maxRadiusSq = 0;

				for ( let i = 0, il = position.count; i < il; i ++ ) {

					_vector$1.fromBufferAttribute( position, i );

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$1 ) );

				}

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						const morphTargetsRelative = this.morphTargetsRelative;

						for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

							_vector$1.fromBufferAttribute( morphAttribute, j );

							if ( morphTargetsRelative ) {

								_offset.fromBufferAttribute( position, j );
								_vector$1.add( _offset );

							}

							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$1 ) );

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					error( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		}

		/**
		 * Calculates and adds a tangent attribute to this geometry.
		 *
		 * The computation is only supported for indexed geometries and if position, normal, and uv attributes
		 * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
		 * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
		 */
		computeTangents() {

			const index = this.index;
			const attributes = this.attributes;

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( index === null ||
				 attributes.position === undefined ||
				 attributes.normal === undefined ||
				 attributes.uv === undefined ) {

				error( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
				return;

			}

			const positionAttribute = attributes.position;
			const normalAttribute = attributes.normal;
			const uvAttribute = attributes.uv;

			if ( this.hasAttribute( 'tangent' ) === false ) {

				this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

			}

			const tangentAttribute = this.getAttribute( 'tangent' );

			const tan1 = [], tan2 = [];

			for ( let i = 0; i < positionAttribute.count; i ++ ) {

				tan1[ i ] = new Vector3();
				tan2[ i ] = new Vector3();

			}

			const vA = new Vector3(),
				vB = new Vector3(),
				vC = new Vector3(),

				uvA = new Vector2(),
				uvB = new Vector2(),
				uvC = new Vector2(),

				sdir = new Vector3(),
				tdir = new Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromBufferAttribute( positionAttribute, a );
				vB.fromBufferAttribute( positionAttribute, b );
				vC.fromBufferAttribute( positionAttribute, c );

				uvA.fromBufferAttribute( uvAttribute, a );
				uvB.fromBufferAttribute( uvAttribute, b );
				uvC.fromBufferAttribute( uvAttribute, c );

				vB.sub( vA );
				vC.sub( vA );

				uvB.sub( uvA );
				uvC.sub( uvA );

				const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

				// silently ignore degenerate uv triangles having coincident or colinear vertices

				if ( ! isFinite( r ) ) return;

				sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
				tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			let groups = this.groups;

			if ( groups.length === 0 ) {

				groups = [ {
					start: 0,
					count: index.count
				} ];

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleTriangle(
						index.getX( j + 0 ),
						index.getX( j + 1 ),
						index.getX( j + 2 )
					);

				}

			}

			const tmp = new Vector3(), tmp2 = new Vector3();
			const n = new Vector3(), n2 = new Vector3();

			function handleVertex( v ) {

				n.fromBufferAttribute( normalAttribute, v );
				n2.copy( n );

				const t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				const test = tmp2.dot( tan2[ v ] );
				const w = ( test < 0.0 ) ? -1 : 1.0;

				tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleVertex( index.getX( j + 0 ) );
					handleVertex( index.getX( j + 1 ) );
					handleVertex( index.getX( j + 2 ) );

				}

			}

		}

		/**
		 * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
		 * each vertex normal to be the average of the face normals of the faces that share that vertex.
		 * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
		 * to be the same as the face normal.
		 */
		computeVertexNormals() {

			const index = this.index;
			const positionAttribute = this.getAttribute( 'position' );

			if ( positionAttribute !== undefined ) {

				let normalAttribute = this.getAttribute( 'normal' );

				if ( normalAttribute === undefined ) {

					normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
					this.setAttribute( 'normal', normalAttribute );

				} else {

					// reset existing normals to zero

					for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

						normalAttribute.setXYZ( i, 0, 0, 0 );

					}

				}

				const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
				const cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					for ( let i = 0, il = index.count; i < il; i += 3 ) {

						const vA = index.getX( i + 0 );
						const vB = index.getX( i + 1 );
						const vC = index.getX( i + 2 );

						pA.fromBufferAttribute( positionAttribute, vA );
						pB.fromBufferAttribute( positionAttribute, vB );
						pC.fromBufferAttribute( positionAttribute, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						nA.fromBufferAttribute( normalAttribute, vA );
						nB.fromBufferAttribute( normalAttribute, vB );
						nC.fromBufferAttribute( normalAttribute, vC );

						nA.add( cb );
						nB.add( cb );
						nC.add( cb );

						normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
						normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
						normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

						pA.fromBufferAttribute( positionAttribute, i + 0 );
						pB.fromBufferAttribute( positionAttribute, i + 1 );
						pC.fromBufferAttribute( positionAttribute, i + 2 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

					}

				}

				this.normalizeNormals();

				normalAttribute.needsUpdate = true;

			}

		}

		/**
		 * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
		 * correct lighting on the geometry surfaces.
		 */
		normalizeNormals() {

			const normals = this.attributes.normal;

			for ( let i = 0, il = normals.count; i < il; i ++ ) {

				_vector$1.fromBufferAttribute( normals, i );

				_vector$1.normalize();

				normals.setXYZ( i, _vector$1.x, _vector$1.y, _vector$1.z );

			}

		}

		/**
		 * Return a new non-index version of this indexed geometry. If the geometry
		 * is already non-indexed, the method is a NOOP.
		 *
		 * @return {BufferGeometry} The non-indexed version of this indexed geometry.
		 */
		toNonIndexed() {

			function convertBufferAttribute( attribute, indices ) {

				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;

				const array2 = new array.constructor( indices.length * itemSize );

				let index = 0, index2 = 0;

				for ( let i = 0, l = indices.length; i < l; i ++ ) {

					if ( attribute.isInterleavedBufferAttribute ) {

						index = indices[ i ] * attribute.data.stride + attribute.offset;

					} else {

						index = indices[ i ] * itemSize;

					}

					for ( let j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize, normalized );

			}

			//

			if ( this.index === null ) {

				warn( 'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
				return this;

			}

			const geometry2 = new BufferGeometry();

			const indices = this.index.array;
			const attributes = this.attributes;

			// attributes

			for ( const name in attributes ) {

				const attribute = attributes[ name ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.setAttribute( name, newAttribute );

			}

			// morph attributes

			const morphAttributes = this.morphAttributes;

			for ( const name in morphAttributes ) {

				const morphArray = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

					const attribute = morphAttribute[ i ];

					const newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative;

			// groups

			const groups = this.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		}

		/**
		 * Serializes the geometry into JSON.
		 *
		 * @return {Object} A JSON object representing the serialized geometry.
		 */
		toJSON() {

			const data = {
				metadata: {
					version: 4.7,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				const parameters = this.parameters;

				for ( const key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			// for simplicity the code assumes attributes are not shared across geometries, see #15811

			data.data = { attributes: {} };

			const index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				data.data.attributes[ key ] = attribute.toJSON( data.data );

			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for ( const key in this.morphAttributes ) {

				const attributeArray = this.morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];

					array.push( attribute.toJSON( data.data ) );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) {

				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;

			}

			const groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			const boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = boundingSphere.toJSON();

			}

			return data;

		}

		/**
		 * Returns a new geometry with copied values from this instance.
		 *
		 * @return {BufferGeometry} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

		/**
		 * Copies the values of the given geometry to this instance.
		 *
		 * @param {BufferGeometry} source - The geometry to copy.
		 * @return {BufferGeometry} A reference to this instance.
		 */
		copy( source ) {

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// used for storing cloned, shared data

			const data = {};

			// name

			this.name = source.name;

			// index

			const index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			// attributes

			const attributes = source.attributes;

			for ( const name in attributes ) {

				const attribute = attributes[ name ];
				this.setAttribute( name, attribute.clone( data ) );

			}

			// morph attributes

			const morphAttributes = source.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone( data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			this.morphTargetsRelative = source.morphTargetsRelative;

			// groups

			const groups = source.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			const boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			const boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		}

		/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 *
		 * @fires BufferGeometry#dispose
		 */
		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	/**
	 * A geometry class for a rectangular cuboid with a given width, height, and depth.
	 * On creation, the cuboid is centred on the origin, with each edge parallel to one
	 * of the axes.
	 *
	 * ```js
	 * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
	 * const cube = new THREE.Mesh( geometry, material );
	 * scene.add( cube );
	 * ```
	 *
	 * @augments BufferGeometry
	 */
	class BoxGeometry extends BufferGeometry {

		/**
		 * Constructs a new box geometry.
		 *
		 * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
		 * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
		 * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
		 * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
		 * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
		 * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
		 */
		constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

			super();

			this.type = 'BoxGeometry';

			/**
			 * Holds the constructor parameters that have been
			 * used to generate the geometry. Any modification
			 * after instantiation does not change the geometry.
			 *
			 * @type {Object}
			 */
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			const scope = this;

			// segments

			widthSegments = Math.floor( widthSegments );
			heightSegments = Math.floor( heightSegments );
			depthSegments = Math.floor( depthSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let numberOfVertices = 0;
			let groupStart = 0;

			// build each side of the box geometry

			buildPlane( 'z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x', 1, -1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
			buildPlane( 'x', 'z', 'y', 1, -1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
			buildPlane( 'x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', -1, -1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;

				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;

				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;

				let vertexCounter = 0;
				let groupCount = 0;

				const vector = new Vector3();

				// generate vertices, normals and uvs

				for ( let iy = 0; iy < gridY1; iy ++ ) {

					const y = iy * segmentHeight - heightHalf;

					for ( let ix = 0; ix < gridX1; ix ++ ) {

						const x = ix * segmentWidth - widthHalf;

						// set values to correct vector component

						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer

						vertices.push( vector.x, vector.y, vector.z );

						// set values to correct vector component

						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : -1;

						// now apply vector to normal buffer

						normals.push( vector.x, vector.y, vector.z );

						// uvs

						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );

						// counters

						vertexCounter += 1;

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( let iy = 0; iy < gridY; iy ++ ) {

					for ( let ix = 0; ix < gridX; ix ++ ) {

						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// increase counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups

				groupStart += groupCount;

				// update total number of vertices

				numberOfVertices += vertexCounter;

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		/**
		 * Factory method for creating an instance of this class from the given
		 * JSON object.
		 *
		 * @param {Object} data - A JSON object representing the serialized geometry.
		 * @return {BoxGeometry} A new instance.
		 */
		static fromJSON( data ) {

			return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

		}

	}

	/**
	 * A geometry class for representing a plane.
	 *
	 * ```js
	 * const geometry = new THREE.PlaneGeometry( 1, 1 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
	 * const plane = new THREE.Mesh( geometry, material );
	 * scene.add( plane );
	 * ```
	 *
	 * @augments BufferGeometry
	 */
	class PlaneGeometry extends BufferGeometry {

		/**
		 * Constructs a new plane geometry.
		 *
		 * @param {number} [width=1] - The width along the X axis.
		 * @param {number} [height=1] - The height along the Y axis
		 * @param {number} [widthSegments=1] - The number of segments along the X axis.
		 * @param {number} [heightSegments=1] - The number of segments along the Y axis.
		 */
		constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

			super();

			this.type = 'PlaneGeometry';

			/**
			 * Holds the constructor parameters that have been
			 * used to generate the geometry. Any modification
			 * after instantiation does not change the geometry.
			 *
			 * @type {Object}
			 */
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			const width_half = width / 2;
			const height_half = height / 2;

			const gridX = Math.floor( widthSegments );
			const gridY = Math.floor( heightSegments );

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			const segment_width = width / gridX;
			const segment_height = height / gridY;

			//

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segment_height - height_half;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segment_width - width_half;

					vertices.push( x, - y, 0 );

					normals.push( 0, 0, 1 );

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

				}

			}

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * ( iy + 1 );
					const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = ( ix + 1 ) + gridX1 * iy;

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		/**
		 * Factory method for creating an instance of this class from the given
		 * JSON object.
		 *
		 * @param {Object} data - A JSON object representing the serialized geometry.
		 * @return {PlaneGeometry} A new instance.
		 */
		static fromJSON( data ) {

			return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

		}

	}

	let _materialId = 0;

	/**
	 * Abstract base class for materials.
	 *
	 * Materials define the appearance of renderable 3D objects.
	 *
	 * @abstract
	 * @augments EventDispatcher
	 */
	let Material$1 = class Material extends EventDispatcher {

		/**
		 * Constructs a new material.
		 */
		constructor() {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMaterial = true;

			/**
			 * The ID of the material.
			 *
			 * @name Material#id
			 * @type {number}
			 * @readonly
			 */
			Object.defineProperty( this, 'id', { value: _materialId ++ } );

			/**
			 * The UUID of the material.
			 *
			 * @type {string}
			 * @readonly
			 */
			this.uuid = generateUUID();

			/**
			 * The name of the material.
			 *
			 * @type {string}
			 */
			this.name = '';

			/**
			 * The type property is used for detecting the object type
			 * in context of serialization/deserialization.
			 *
			 * @type {string}
			 * @readonly
			 */
			this.type = 'Material';

			/**
			 * Defines the blending type of the material.
			 *
			 * It must be set to `CustomBlending` if custom blending properties like
			 * {@link Material#blendSrc}, {@link Material#blendDst} or {@link Material#blendEquation}
			 * should have any effect.
			 *
			 * @type {(NoBlending|NormalBlending|AdditiveBlending|SubtractiveBlending|MultiplyBlending|CustomBlending)}
			 * @default NormalBlending
			 */
			this.blending = NormalBlending;

			/**
			 * Defines which side of faces will be rendered - front, back or both.
			 *
			 * @type {(FrontSide|BackSide|DoubleSide)}
			 * @default FrontSide
			 */
			this.side = FrontSide;

			/**
			 * If set to `true`, vertex colors should be used.
			 *
			 * The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
			 * four (RGBA) component color buffer attribute is used.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.vertexColors = false;

			/**
			 * Defines how transparent the material is.
			 * A value of `0.0` indicates fully transparent, `1.0` is fully opaque.
			 *
			 * If the {@link Material#transparent} is not set to `true`,
			 * the material will remain fully opaque and this value will only affect its color.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.opacity = 1;

			/**
			 * Defines whether this material is transparent. This has an effect on
			 * rendering as transparent objects need special treatment and are rendered
			 * after non-transparent objects.
			 *
			 * When set to true, the extent to which the material is transparent is
			 * controlled by {@link Material#opacity}.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.transparent = false;

			/**
			 * Enables alpha hashed transparency, an alternative to {@link Material#transparent} or
			 * {@link Material#alphaTest}. The material will not be rendered if opacity is lower than
			 * a random threshold. Randomization introduces some grain or noise, but approximates alpha
			 * blending without the associated problems of sorting. Using TAA can reduce the resulting noise.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.alphaHash = false;

			/**
			 * Defines the blending source factor.
			 *
			 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
			 * @default SrcAlphaFactor
			 */
			this.blendSrc = SrcAlphaFactor;

			/**
			 * Defines the blending destination factor.
			 *
			 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
			 * @default OneMinusSrcAlphaFactor
			 */
			this.blendDst = OneMinusSrcAlphaFactor;

			/**
			 * Defines the blending equation.
			 *
			 * @type {(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
			 * @default AddEquation
			 */
			this.blendEquation = AddEquation;

			/**
			 * Defines the blending source alpha factor.
			 *
			 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
			 * @default null
			 */
			this.blendSrcAlpha = null;

			/**
			 * Defines the blending destination alpha factor.
			 *
			 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
			 * @default null
			 */
			this.blendDstAlpha = null;

			/**
			 * Defines the blending equation of the alpha channel.
			 *
			 * @type {?(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
			 * @default null
			 */
			this.blendEquationAlpha = null;

			/**
			 * Represents the RGB values of the constant blend color.
			 *
			 * This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.
			 *
			 * @type {Color}
			 * @default (0,0,0)
			 */
			this.blendColor = new Color( 0, 0, 0 );

			/**
			 * Represents the alpha value of the constant blend color.
			 *
			 * This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.blendAlpha = 0;

			/**
			 * Defines the depth function.
			 *
			 * @type {(NeverDepth|AlwaysDepth|LessDepth|LessEqualDepth|EqualDepth|GreaterEqualDepth|GreaterDepth|NotEqualDepth)}
			 * @default LessEqualDepth
			 */
			this.depthFunc = LessEqualDepth;

			/**
			 * Whether to have depth test enabled when rendering this material.
			 * When the depth test is disabled, the depth write will also be implicitly disabled.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.depthTest = true;

			/**
			 * Whether rendering this material has any effect on the depth buffer.
			 *
			 * When drawing 2D overlays it can be useful to disable the depth writing in
			 * order to layer several things together without creating z-index artifacts.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.depthWrite = true;

			/**
			 * The bit mask to use when writing to the stencil buffer.
			 *
			 * @type {number}
			 * @default 0xff
			 */
			this.stencilWriteMask = 0xff;

			/**
			 * The stencil comparison function to use.
			 *
			 * @type {NeverStencilFunc|LessStencilFunc|EqualStencilFunc|LessEqualStencilFunc|GreaterStencilFunc|NotEqualStencilFunc|GreaterEqualStencilFunc|AlwaysStencilFunc}
			 * @default AlwaysStencilFunc
			 */
			this.stencilFunc = AlwaysStencilFunc;

			/**
			 * The value to use when performing stencil comparisons or stencil operations.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.stencilRef = 0;

			/**
			 * The bit mask to use when comparing against the stencil buffer.
			 *
			 * @type {number}
			 * @default 0xff
			 */
			this.stencilFuncMask = 0xff;

			/**
			 * Which stencil operation to perform when the comparison function returns `false`.
			 *
			 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
			 * @default KeepStencilOp
			 */
			this.stencilFail = KeepStencilOp;

			/**
			 * Which stencil operation to perform when the comparison function returns
			 * `true` but the depth test fails.
			 *
			 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
			 * @default KeepStencilOp
			 */
			this.stencilZFail = KeepStencilOp;

			/**
			 * Which stencil operation to perform when the comparison function returns
			 * `true` and the depth test passes.
			 *
			 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
			 * @default KeepStencilOp
			 */
			this.stencilZPass = KeepStencilOp;

			/**
			 * Whether stencil operations are performed against the stencil buffer. In
			 * order to perform writes or comparisons against the stencil buffer this
			 * value must be `true`.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.stencilWrite = false;

			/**
			 * User-defined clipping planes specified as THREE.Plane objects in world
			 * space. These planes apply to the objects this material is attached to.
			 * Points in space whose signed distance to the plane is negative are clipped
			 * (not rendered). This requires {@link WebGLRenderer#localClippingEnabled} to
			 * be `true`.
			 *
			 * @type {?Array<Plane>}
			 * @default null
			 */
			this.clippingPlanes = null;

			/**
			 * Changes the behavior of clipping planes so that only their intersection is
			 * clipped, rather than their union.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.clipIntersection = false;

			/**
			 * Defines whether to clip shadows according to the clipping planes specified
			 * on this material.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.clipShadows = false;

			/**
			 * Defines which side of faces cast shadows. If `null`, the side casting shadows
			 * is determined as follows:
			 *
			 * - When {@link Material#side} is set to `FrontSide`, the back side cast shadows.
			 * - When {@link Material#side} is set to `BackSide`, the front side cast shadows.
			 * - When {@link Material#side} is set to `DoubleSide`, both sides cast shadows.
			 *
			 * @type {?(FrontSide|BackSide|DoubleSide)}
			 * @default null
			 */
			this.shadowSide = null;

			/**
			 * Whether to render the material's color.
			 *
			 * This can be used in conjunction with {@link Object3D#renderOder} to create invisible
			 * objects that occlude other objects.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.colorWrite = true;

			/**
			 * Override the renderer's default precision for this material.
			 *
			 * @type {?('highp'|'mediump'|'lowp')}
			 * @default null
			 */
			this.precision = null;

			/**
			 * Whether to use polygon offset or not. When enabled, each fragment's depth value will
			 * be offset after it is interpolated from the depth values of the appropriate vertices.
			 * The offset is added before the depth test is performed and before the value is written
			 * into the depth buffer.
			 *
			 * Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
			 * rendering solids with highlighted edges.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.polygonOffset = false;

			/**
			 * Specifies a scale factor that is used to create a variable depth offset for each polygon.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.polygonOffsetFactor = 0;

			/**
			 * Is multiplied by an implementation-specific value to create a constant depth offset.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.polygonOffsetUnits = 0;

			/**
			 * Whether to apply dithering to the color to remove the appearance of banding.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.dithering = false;

			/**
			 * Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
			 * (meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
			 * will smooth aliasing on clip plane edges and alphaTest-clipped edges.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.alphaToCoverage = false;

			/**
			 * Whether to premultiply the alpha (transparency) value.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.premultipliedAlpha = false;

			/**
			 * Whether double-sided, transparent objects should be rendered with a single pass or not.
			 *
			 * The engine renders double-sided, transparent objects with two draw calls (back faces first,
			 * then front faces) to mitigate transparency artifacts. There are scenarios however where this
			 * approach produces no quality gains but still doubles draw calls e.g. when rendering flat
			 * vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
			 * disable the two pass rendering to avoid performance issues.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.forceSinglePass = false;

			/**
			 * Whether it's possible to override the material with {@link Scene#overrideMaterial} or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.allowOverride = true;

			/**
			 * Defines whether 3D objects using this material are visible.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.visible = true;

			/**
			 * Defines whether this material is tone mapped according to the renderer's tone mapping setting.
			 *
			 * It is ignored when rendering to a render target or using post processing or when using
			 * `WebGPURenderer`. In all these cases, all materials are honored by tone mapping.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.toneMapped = true;

			/**
			 * An object that can be used to store custom data about the Material. It
			 * should not hold references to functions as these will not be cloned.
			 *
			 * @type {Object}
			 */
			this.userData = {};

			/**
			 * This starts at `0` and counts how many times {@link Material#needsUpdate} is set to `true`.
			 *
			 * @type {number}
			 * @readonly
			 * @default 0
			 */
			this.version = 0;

			this._alphaTest = 0;

		}

		/**
		 * Sets the alpha value to be used when running an alpha test. The material
		 * will not be rendered if the opacity is lower than this value.
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */
		get alphaTest() {

			return this._alphaTest;

		}

		set alphaTest( value ) {

			if ( this._alphaTest > 0 !== value > 0 ) {

				this.version ++;

			}

			this._alphaTest = value;

		}

		/**
		 * An optional callback that is executed immediately before the material is used to render a 3D object.
		 *
		 * This method can only be used when rendering with {@link WebGLRenderer}.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Scene} scene - The scene.
		 * @param {Camera} camera - The camera that is used to render the scene.
		 * @param {BufferGeometry} geometry - The 3D object's geometry.
		 * @param {Object3D} object - The 3D object.
		 * @param {Object} group - The geometry group data.
		 */
		onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

		/**
		 * An optional callback that is executed immediately before the shader
		 * program is compiled. This function is called with the shader source code
		 * as a parameter. Useful for the modification of built-in materials.
		 *
		 * This method can only be used when rendering with {@link WebGLRenderer}. The
		 * recommended approach when customizing materials is to use `WebGPURenderer` with the new
		 * Node Material system and [TSL]{@link https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language}.
		 *
		 * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
		 * @param {WebGLRenderer} renderer - A reference to the renderer.
		 */
		onBeforeCompile( /* shaderobject, renderer */ ) {}

		/**
		 * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
		 * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
		 * shader or recompile the shader for this material as needed.
		 *
		 * This method can only be used when rendering with {@link WebGLRenderer}.
		 *
		 * @return {string} The custom program cache key.
		 */
		customProgramCacheKey() {

			return this.onBeforeCompile.toString();

		}

		/**
		 * This method can be used to set default values from parameter objects.
		 * It is a generic implementation so it can be used with different types
		 * of materials.
		 *
		 * @param {Object} [values] - The material values to set.
		 */
		setValues( values ) {

			if ( values === undefined ) return;

			for ( const key in values ) {

				const newValue = values[ key ];

				if ( newValue === undefined ) {

					warn( `Material: parameter '${ key }' has value of undefined.` );
					continue;

				}

				const currentValue = this[ key ];

				if ( currentValue === undefined ) {

					warn( `Material: '${ key }' is not a property of THREE.${ this.type }.` );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

		/**
		 * Serializes the material into JSON.
		 *
		 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
		 * @return {Object} A JSON object representing the serialized material.
		 * @see {@link ObjectLoader#parse}
		 */
		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( isRootObject ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			const data = {
				metadata: {
					version: 4.7,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.sheen !== undefined ) data.sheen = this.sheen;
			if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
			if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
			if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
			if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

			if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

				data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

			}

			if ( this.sheenColorMap && this.sheenColorMap.isTexture ) {

				data.sheenColorMap = this.sheenColorMap.toJSON( meta ).uuid;

			}

			if ( this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture ) {

				data.sheenRoughnessMap = this.sheenRoughnessMap.toJSON( meta ).uuid;

			}

			if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

			if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
			if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
			if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

			if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

				data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

			}

			if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

				data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

			}

			if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
			if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

			if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

				data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

			}

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

			if ( this.lightMap && this.lightMap.isTexture ) {

				data.lightMap = this.lightMap.toJSON( meta ).uuid;
				data.lightMapIntensity = this.lightMapIntensity;

			}

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
			if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
			if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;

				if ( this.combine !== undefined ) data.combine = this.combine;

			}

			if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
			if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
			if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.transmission !== undefined ) data.transmission = this.transmission;
			if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
			if ( this.thickness !== undefined ) data.thickness = this.thickness;
			if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
			if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
			if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors === true ) data.vertexColors = true;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = true;

			if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
			if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
			if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
			if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
			if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
			if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
			if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
			if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

			if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
			if ( this.depthTest === false ) data.depthTest = this.depthTest;
			if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
			if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

			if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
			if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
			if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
			if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
			if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
			if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
			if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
			if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

			// rotation (SpriteMaterial)
			if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.alphaHash === true ) data.alphaHash = true;
			if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
			if ( this.forceSinglePass === true ) data.forceSinglePass = true;

			if ( this.wireframe === true ) data.wireframe = true;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.flatShading === true ) data.flatShading = true;

			if ( this.visible === false ) data.visible = false;

			if ( this.toneMapped === false ) data.toneMapped = false;

			if ( this.fog === false ) data.fog = false;

			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				const values = [];

				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRootObject ) {

				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		}

		/**
		 * Returns a new material with copied values from this instance.
		 *
		 * @return {Material} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

		/**
		 * Copies the values of the given material to this instance.
		 *
		 * @param {Material} source - The material to copy.
		 * @return {Material} A reference to this instance.
		 */
		copy( source ) {

			this.name = source.name;

			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
			this.blendColor.copy( source.blendColor );
			this.blendAlpha = source.blendAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;

			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if ( srcPlanes !== null ) {

				const n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( let i = 0; i !== n; ++ i ) {

					dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;

			this.shadowSide = source.shadowSide;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.alphaHash = source.alphaHash;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.forceSinglePass = source.forceSinglePass;

			this.visible = source.visible;

			this.toneMapped = source.toneMapped;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			return this;

		}

		/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 *
		 * @fires Material#dispose
		 */
		dispose() {

			/**
			 * Fires when the material has been disposed of.
			 *
			 * @event Material#dispose
			 * @type {Object}
			 */
			this.dispatchEvent( { type: 'dispose' } );

		}

		/**
		 * Setting this property to `true` indicates the engine the material
		 * needs to be recompiled.
		 *
		 * @type {boolean}
		 * @default false
		 * @param {boolean} value
		 */
		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

	};

	/**
	 * Provides utility functions for managing uniforms.
	 *
	 * @module UniformsUtils
	 */

	/**
	 * Clones the given uniform definitions by performing a deep-copy. That means
	 * if the value of a uniform refers to an object like a Vector3 or Texture,
	 * the cloned uniform will refer to a new object reference.
	 *
	 * @param {Object} src - An object representing uniform definitions.
	 * @return {Object} The cloned uniforms.
	 */
	function cloneUniforms( src ) {

		const dst = {};

		for ( const u in src ) {

			dst[ u ] = {};

			for ( const p in src[ u ] ) {

				const property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture || property.isQuaternion ) ) {

					if ( property.isRenderTargetTexture ) {

						warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
						dst[ u ][ p ] = null;

					} else {

						dst[ u ][ p ] = property.clone();

					}

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	/**
	 * Merges the given uniform definitions into a single object. Since the
	 * method internally uses cloneUniforms(), it performs a deep-copy when
	 * producing the merged uniform definitions.
	 *
	 * @param {Array} uniforms - An array of objects containing uniform definitions.
	 * @return {Object} The merged uniforms.
	 */
	function mergeUniforms( uniforms ) {

		const merged = {};

		for ( let u = 0; u < uniforms.length; u ++ ) {

			const tmp = cloneUniforms( uniforms[ u ] );

			for ( const p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	function cloneUniformsGroups( src ) {

		const dst = [];

		for ( let u = 0; u < src.length; u ++ ) {

			dst.push( src[ u ].clone() );

		}

		return dst;

	}

	function getUnlitUniformColorSpace( renderer ) {

		const currentRenderTarget = renderer.getRenderTarget();

		if ( currentRenderTarget === null ) {

			// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
			return renderer.outputColorSpace;

		}

		// https://github.com/mrdoob/three.js/issues/27868
		if ( currentRenderTarget.isXRRenderTarget === true ) {

			return currentRenderTarget.texture.colorSpace;

		}

		return ColorManagement.workingColorSpace;

	}

	// Legacy

	const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	var default_vertex = /* glsl */`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`;

	var default_fragment = /* glsl */`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;

	/**
	 * A material rendered with custom shaders. A shader is a small program written in GLSL.
	 * that runs on the GPU. You may want to use a custom shader if you need to implement an
	 * effect not included with any of the built-in materials.
	 *
	 * There are the following notes to bear in mind when using a `ShaderMaterial`:
	 *
	 * - `ShaderMaterial` can only be used with {@link WebGLRenderer}.
	 * - Built in attributes and uniforms are passed to the shaders along with your code. If
	 * you don't want that, use {@link RawShaderMaterial} instead.
	 * - You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
	 * in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
	 * to be placed right above the loop. The loop formatting has to correspond to a defined standard.
	 *   - The loop has to be [normalized]{@link https://en.wikipedia.org/wiki/Normalized_loop}.
	 *   - The loop variable has to be *i*.
	 *   - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
	 * value of *i* for the given iteration and can be used in preprocessor
	 * statements.
	 *
	 * ```js
	 * const material = new THREE.ShaderMaterial( {
	 * 	uniforms: {
	 * 		time: { value: 1.0 },
	 * 		resolution: { value: new THREE.Vector2() }
	 * 	},
	 * 	vertexShader: document.getElementById( 'vertexShader' ).textContent,
	 * 	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
	 * } );
	 * ```
	 *
	 * @augments Material
	 */
	class ShaderMaterial extends Material$1 {

		/**
		 * Constructs a new shader material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */
		constructor( parameters ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isShaderMaterial = true;

			this.type = 'ShaderMaterial';

			/**
			 * Defines custom constants using `#define` directives within the GLSL code
			 * for both the vertex shader and the fragment shader; each key/value pair
			 * yields another directive.
			 * ```js
			 * defines: {
			 * 	FOO: 15,
			 * 	BAR: true
			 * }
			 * ```
			 * Yields the lines:
			 * ```
			 * #define FOO 15
			 * #define BAR true
			 * ```
			 *
			 * @type {Object}
			 */
			this.defines = {};

			/**
			 * An object of the form:
			 * ```js
			 * {
			 * 	"uniform1": { value: 1.0 },
			 * 	"uniform2": { value: 2 }
			 * }
			 * ```
			 * specifying the uniforms to be passed to the shader code; keys are uniform
			 * names, values are definitions of the form
			 * ```
			 * {
			 * 	value: 1.0
			 * }
			 * ```
			 * where `value` is the value of the uniform. Names must match the name of
			 * the uniform, as defined in the GLSL code. Note that uniforms are refreshed
			 * on every frame, so updating the value of the uniform will immediately
			 * update the value available to the GLSL code.
			 *
			 * @type {Object}
			 */
			this.uniforms = {};

			/**
			 * An array holding uniforms groups for configuring UBOs.
			 *
			 * @type {Array<UniformsGroup>}
			 */
			this.uniformsGroups = [];

			/**
			 * Vertex shader GLSL code. This is the actual code for the shader.
			 *
			 * @type {string}
			 */
			this.vertexShader = default_vertex;

			/**
			 * Fragment shader GLSL code. This is the actual code for the shader.
			 *
			 * @type {string}
			 */
			this.fragmentShader = default_fragment;

			/**
			 * Controls line thickness or lines.
			 *
			 * WebGL and WebGPU ignore this setting and always render line primitives with a
			 * width of one pixel.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.linewidth = 1;

			/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.wireframe = false;

			/**
			 * Controls the thickness of the wireframe.
			 *
			 * WebGL and WebGPU ignore this property and always render
			 * 1 pixel wide lines.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.wireframeLinewidth = 1;

			/**
			 * Define whether the material color is affected by global fog settings; `true`
			 * to pass fog uniforms to the shader.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.fog = false;

			/**
			 * Defines whether this material uses lighting; `true` to pass uniform data
			 * related to lighting to this shader.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.lights = false;

			/**
			 * Defines whether this material supports clipping; `true` to let the renderer
			 * pass the clippingPlanes uniform.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.clipping = false;

			/**
			 * Overwritten and set to `true` by default.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.forceSinglePass = true;

			/**
			 * This object allows to enable certain WebGL 2 extensions.
			 *
			 * - clipCullDistance: set to `true` to use vertex shader clipping
			 * - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID
			 *
			 * @type {{clipCullDistance:false,multiDraw:false}}
			 */
			this.extensions = {
				clipCullDistance: false, // set to use vertex shader clipping
				multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
			};

			/**
			 * When the rendered geometry doesn't include these attributes but the
			 * material does, these default values will be passed to the shaders. This
			 * avoids errors when buffer data is missing.
			 *
			 * - color: [ 1, 1, 1 ]
			 * - uv: [ 0, 0 ]
			 * - uv1: [ 0, 0 ]
			 *
			 * @type {Object}
			 */
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv1': [ 0, 0 ]
			};

			/**
			 * If set, this calls [gl.bindAttribLocation]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation}
			 * to bind a generic vertex index to an attribute variable.
			 *
			 * @type {string|undefined}
			 * @default undefined
			 */
			this.index0AttributeName = undefined;

			/**
			 * Can be used to force a uniform update while changing uniforms in
			 * {@link Object3D#onBeforeRender}.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.uniformsNeedUpdate = false;

			/**
			 * Defines the GLSL version of custom shader code.
			 *
			 * @type {?(GLSL1|GLSL3)}
			 * @default null
			 */
			this.glslVersion = null;

			if ( parameters !== undefined ) {

				this.setValues( parameters );

			}

		}

		copy( source ) {

			super.copy( source );

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;

			this.uniforms = cloneUniforms( source.uniforms );
			this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

			this.defines = Object.assign( {}, source.defines );

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.fog = source.fog;
			this.lights = source.lights;
			this.clipping = source.clipping;

			this.extensions = Object.assign( {}, source.extensions );

			this.glslVersion = source.glslVersion;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for ( const name in this.uniforms ) {

				const uniform = this.uniforms[ name ];
				const value = uniform.value;

				if ( value && value.isTexture ) {

					data.uniforms[ name ] = {
						type: 't',
						value: value.toJSON( meta ).uuid
					};

				} else if ( value && value.isColor ) {

					data.uniforms[ name ] = {
						type: 'c',
						value: value.getHex()
					};

				} else if ( value && value.isVector2 ) {

					data.uniforms[ name ] = {
						type: 'v2',
						value: value.toArray()
					};

				} else if ( value && value.isVector3 ) {

					data.uniforms[ name ] = {
						type: 'v3',
						value: value.toArray()
					};

				} else if ( value && value.isVector4 ) {

					data.uniforms[ name ] = {
						type: 'v4',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix3 ) {

					data.uniforms[ name ] = {
						type: 'm3',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix4 ) {

					data.uniforms[ name ] = {
						type: 'm4',
						value: value.toArray()
					};

				} else {

					data.uniforms[ name ] = {
						value: value
					};

					// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

				}

			}

			if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;

			data.lights = this.lights;
			data.clipping = this.clipping;

			const extensions = {};

			for ( const key in this.extensions ) {

				if ( this.extensions[ key ] === true ) extensions[ key ] = true;

			}

			if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

			return data;

		}

	}

	const _vector = /*@__PURE__*/ new Vector3();
	const _segCenter = /*@__PURE__*/ new Vector3();
	const _segDir = /*@__PURE__*/ new Vector3();
	const _diff = /*@__PURE__*/ new Vector3();

	const _edge1 = /*@__PURE__*/ new Vector3();
	const _edge2 = /*@__PURE__*/ new Vector3();
	const _normal = /*@__PURE__*/ new Vector3();

	/**
	 * A ray that emits from an origin in a certain direction. The class is used by
	 * {@link Raycaster} to assist with raycasting. Raycasting is used for
	 * mouse picking (working out what objects in the 3D space the mouse is over)
	 * amongst other things.
	 */
	let Ray$1 = class Ray {

		/**
		 * Constructs a new ray.
		 *
		 * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
		 * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
		 */
		constructor( origin = new Vector3(), direction = new Vector3( 0, 0, -1 ) ) {

			/**
			 * The origin of the ray.
			 *
			 * @type {Vector3}
			 */
			this.origin = origin;

			/**
			 * The (normalized) direction of the ray.
			 *
			 * @type {Vector3}
			 */
			this.direction = direction;

		}

		/**
		 * Sets the ray's components by copying the given values.
		 *
		 * @param {Vector3} origin - The origin.
		 * @param {Vector3} direction - The direction.
		 * @return {Ray} A reference to this ray.
		 */
		set( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		}

		/**
		 * Copies the values of the given ray to this instance.
		 *
		 * @param {Ray} ray - The ray to copy.
		 * @return {Ray} A reference to this ray.
		 */
		copy( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		}

		/**
		 * Returns a vector that is located at a given distance along this ray.
		 *
		 * @param {number} t - The distance along the ray to retrieve a position for.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} A position on the ray.
		 */
		at( t, target ) {

			return target.copy( this.origin ).addScaledVector( this.direction, t );

		}

		/**
		 * Adjusts the direction of the ray to point at the given vector in world space.
		 *
		 * @param {Vector3} v - The target position.
		 * @return {Ray} A reference to this ray.
		 */
		lookAt( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		}

		/**
		 * Shift the origin of this ray along its direction by the given distance.
		 *
		 * @param {number} t - The distance along the ray to interpolate.
		 * @return {Ray} A reference to this ray.
		 */
		recast( t ) {

			this.origin.copy( this.at( t, _vector ) );

			return this;

		}

		/**
		 * Returns the point along this ray that is closest to the given point.
		 *
		 * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The closest point on this ray.
		 */
		closestPointToPoint( point, target ) {

			target.subVectors( point, this.origin );

			const directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

		}

		/**
		 * Returns the distance of the closest approach between this ray and the given point.
		 *
		 * @param {Vector3} point - A point in 3D space to compute the distance to.
		 * @return {number} The distance.
		 */
		distanceToPoint( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		}

		/**
		 * Returns the squared distance of the closest approach between this ray and the given point.
		 *
		 * @param {Vector3} point - A point in 3D space to compute the distance to.
		 * @return {number} The squared distance.
		 */
		distanceSqToPoint( point ) {

			const directionDistance = _vector.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			_vector.copy( this.origin ).addScaledVector( this.direction, directionDistance );

			return _vector.distanceToSquared( point );

		}

		/**
		 * Returns the squared distance between this ray and the given line segment.
		 *
		 * @param {Vector3} v0 - The start point of the line segment.
		 * @param {Vector3} v1 - The end point of the line segment.
		 * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
		 * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
		 * @return {number} The squared distance.
		 */
		distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			_segDir.copy( v1 ).sub( v0 ).normalize();
			_diff.copy( this.origin ).sub( _segCenter );

			const segExtent = v0.distanceTo( v1 ) * 0.5;
			const a01 = - this.direction.dot( _segDir );
			const b0 = _diff.dot( this.direction );
			const b1 = - _diff.dot( _segDir );
			const c = _diff.lengthSq();
			const det = Math.abs( 1 - a01 * a01 );
			let s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

			}

			return sqrDist;

		}

		/**
		 * Intersects this ray with the given sphere, returning the intersection
		 * point or `null` if there is no intersection.
		 *
		 * @param {Sphere} sphere - The sphere to intersect.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */
		intersectSphere( sphere, target ) {

			_vector.subVectors( sphere.center, this.origin );
			const tca = _vector.dot( this.direction );
			const d2 = _vector.dot( _vector ) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			const thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			const t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			const t1 = tca + thc;

			// test to see if t1 is behind the ray - if so, return null
			if ( t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, target );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, target );

		}

		/**
		 * Returns `true` if this ray intersects with the given sphere.
		 *
		 * @param {Sphere} sphere - The sphere to intersect.
		 * @return {boolean} Whether this ray intersects with the given sphere or not.
		 */
		intersectsSphere( sphere ) {

			if ( sphere.radius < 0 ) return false; // handle empty spheres, see #31187

			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		/**
		 * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
		 * does not intersect with the plane.
		 *
		 * @param {Plane} plane - The plane to compute the distance to.
		 * @return {?number} Whether this ray intersects with the given sphere or not.
		 */
		distanceToPlane( plane ) {

			const denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		}

		/**
		 * Intersects this ray with the given plane, returning the intersection
		 * point or `null` if there is no intersection.
		 *
		 * @param {Plane} plane - The plane to intersect.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */
		intersectPlane( plane, target ) {

			const t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		}

		/**
		 * Returns `true` if this ray intersects with the given plane.
		 *
		 * @param {Plane} plane - The plane to intersect.
		 * @return {boolean} Whether this ray intersects with the given plane or not.
		 */
		intersectsPlane( plane ) {

			// check if the ray lies on the plane first

			const distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			const denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		}

		/**
		 * Intersects this ray with the given bounding box, returning the intersection
		 * point or `null` if there is no intersection.
		 *
		 * @param {Box3} box - The box to intersect.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */
		intersectBox( box, target ) {

			let tmin, tmax, tymin, tymax, tzmin, tzmax;

			const invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			const origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

			if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		}

		/**
		 * Returns `true` if this ray intersects with the given box.
		 *
		 * @param {Box3} box - The box to intersect.
		 * @return {boolean} Whether this ray intersects with the given box or not.
		 */
		intersectsBox( box ) {

			return this.intersectBox( box, _vector ) !== null;

		}

		/**
		 * Intersects this ray with the given triangle, returning the intersection
		 * point or `null` if there is no intersection.
		 *
		 * @param {Vector3} a - The first vertex of the triangle.
		 * @param {Vector3} b - The second vertex of the triangle.
		 * @param {Vector3} c - The third vertex of the triangle.
		 * @param {boolean} backfaceCulling - Whether to use backface culling or not.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The intersection point.
		 */
		intersectTriangle( a, b, c, backfaceCulling, target ) {

			// Compute the offset origin, edges, and normal.

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			_edge1.subVectors( b, a );
			_edge2.subVectors( c, a );
			_normal.crossVectors( _edge1, _edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			let DdN = this.direction.dot( _normal );
			let sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = -1;
				DdN = - DdN;

			} else {

				return null;

			}

			_diff.subVectors( this.origin, a );
			const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			const QdN = - sign * _diff.dot( _normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, target );

		}

		/**
		 * Transforms this ray with the given 4x4 transformation matrix.
		 *
		 * @param {Matrix4} matrix4 - The transformation matrix.
		 * @return {Ray} A reference to this ray.
		 */
		applyMatrix4( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		}

		/**
		 * Returns `true` if this ray is equal with the given one.
		 *
		 * @param {Ray} ray - The ray to test for equality.
		 * @return {boolean} Whether this ray is equal with the given one.
		 */
		equals( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

		/**
		 * Returns a new ray with copied values from this instance.
		 *
		 * @return {Ray} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

	};

	const _v0$1 = /*@__PURE__*/ new Vector3();
	const _v1 = /*@__PURE__*/ new Vector3();
	const _v2 = /*@__PURE__*/ new Vector3();
	const _v3$1 = /*@__PURE__*/ new Vector3();

	const _vab = /*@__PURE__*/ new Vector3();
	const _vac = /*@__PURE__*/ new Vector3();
	const _vbc = /*@__PURE__*/ new Vector3();
	const _vap = /*@__PURE__*/ new Vector3();
	const _vbp = /*@__PURE__*/ new Vector3();
	const _vcp = /*@__PURE__*/ new Vector3();

	const _v40 = /*@__PURE__*/ new Vector4();
	const _v41 = /*@__PURE__*/ new Vector4();
	const _v42 = /*@__PURE__*/ new Vector4();

	/**
	 * A geometric triangle as defined by three vectors representing its three corners.
	 */
	class Triangle {

		/**
		 * Constructs a new triangle.
		 *
		 * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
		 * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
		 * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
		 */
		constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

			/**
			 * The first corner of the triangle.
			 *
			 * @type {Vector3}
			 */
			this.a = a;

			/**
			 * The second corner of the triangle.
			 *
			 * @type {Vector3}
			 */
			this.b = b;

			/**
			 * The third corner of the triangle.
			 *
			 * @type {Vector3}
			 */
			this.c = c;

		}

		/**
		 * Computes the normal vector of a triangle.
		 *
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The triangle's normal.
		 */
		static getNormal( a, b, c, target ) {

			target.subVectors( c, b );
			_v0$1.subVectors( a, b );
			target.cross( _v0$1 );

			const targetLengthSq = target.lengthSq();
			if ( targetLengthSq > 0 ) {

				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

			}

			return target.set( 0, 0, 0 );

		}

		/**
		 * Computes a barycentric coordinates from the given vector.
		 * Returns `null` if the triangle is degenerate.
		 *
		 * @param {Vector3} point - A point in 3D space.
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The barycentric coordinates for the given point
		 */
		static getBarycoord( point, a, b, c, target ) {

			// based on: http://www.blackpawn.com/texts/pointinpoly/default.html

			_v0$1.subVectors( c, a );
			_v1.subVectors( b, a );
			_v2.subVectors( point, a );

			const dot00 = _v0$1.dot( _v0$1 );
			const dot01 = _v0$1.dot( _v1 );
			const dot02 = _v0$1.dot( _v2 );
			const dot11 = _v1.dot( _v1 );
			const dot12 = _v1.dot( _v2 );

			const denom = ( dot00 * dot11 - dot01 * dot01 );

			// collinear or singular triangle
			if ( denom === 0 ) {

				target.set( 0, 0, 0 );
				return null;

			}

			const invDenom = 1 / denom;
			const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return target.set( 1 - u - v, v, u );

		}

		/**
		 * Returns `true` if the given point, when projected onto the plane of the
		 * triangle, lies within the triangle.
		 *
		 * @param {Vector3} point - The point in 3D space to test.
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @return {boolean} Whether the given point, when projected onto the plane of the
		 * triangle, lies within the triangle or not.
		 */
		static containsPoint( point, a, b, c ) {

			// if the triangle is degenerate then we can't contain a point
			if ( this.getBarycoord( point, a, b, c, _v3$1 ) === null ) {

				return false;

			}

			return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

		}

		/**
		 * Computes the value barycentrically interpolated for the given point on the
		 * triangle. Returns `null` if the triangle is degenerate.
		 *
		 * @param {Vector3} point - Position of interpolated point.
		 * @param {Vector3} p1 - The first corner of the triangle.
		 * @param {Vector3} p2 - The second corner of the triangle.
		 * @param {Vector3} p3 - The third corner of the triangle.
		 * @param {Vector3} v1 - Value to interpolate of first vertex.
		 * @param {Vector3} v2 - Value to interpolate of second vertex.
		 * @param {Vector3} v3 - Value to interpolate of third vertex.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The interpolated value.
		 */
		static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

			if ( this.getBarycoord( point, p1, p2, p3, _v3$1 ) === null ) {

				target.x = 0;
				target.y = 0;
				if ( 'z' in target ) target.z = 0;
				if ( 'w' in target ) target.w = 0;
				return null;

			}

			target.setScalar( 0 );
			target.addScaledVector( v1, _v3$1.x );
			target.addScaledVector( v2, _v3$1.y );
			target.addScaledVector( v3, _v3$1.z );

			return target;

		}

		/**
		 * Computes the value barycentrically interpolated for the given attribute and indices.
		 *
		 * @param {BufferAttribute} attr - The attribute to interpolate.
		 * @param {number} i1 - Index of first vertex.
		 * @param {number} i2 - Index of second vertex.
		 * @param {number} i3 - Index of third vertex.
		 * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The interpolated attribute value.
		 */
		static getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {

			_v40.setScalar( 0 );
			_v41.setScalar( 0 );
			_v42.setScalar( 0 );

			_v40.fromBufferAttribute( attr, i1 );
			_v41.fromBufferAttribute( attr, i2 );
			_v42.fromBufferAttribute( attr, i3 );

			target.setScalar( 0 );
			target.addScaledVector( _v40, barycoord.x );
			target.addScaledVector( _v41, barycoord.y );
			target.addScaledVector( _v42, barycoord.z );

			return target;

		}

		/**
		 * Returns `true` if the triangle is oriented towards the given direction.
		 *
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @param {Vector3} direction - The (normalized) direction vector.
		 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
		 */
		static isFrontFacing( a, b, c, direction ) {

			_v0$1.subVectors( c, b );
			_v1.subVectors( a, b );

			// strictly front facing
			return ( _v0$1.cross( _v1 ).dot( direction ) < 0 ) ? true : false;

		}

		/**
		 * Sets the triangle's vertices by copying the given values.
		 *
		 * @param {Vector3} a - The first corner of the triangle.
		 * @param {Vector3} b - The second corner of the triangle.
		 * @param {Vector3} c - The third corner of the triangle.
		 * @return {Triangle} A reference to this triangle.
		 */
		set( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		}

		/**
		 * Sets the triangle's vertices by copying the given array values.
		 *
		 * @param {Array<Vector3>} points - An array with 3D points.
		 * @param {number} i0 - The array index representing the first corner of the triangle.
		 * @param {number} i1 - The array index representing the second corner of the triangle.
		 * @param {number} i2 - The array index representing the third corner of the triangle.
		 * @return {Triangle} A reference to this triangle.
		 */
		setFromPointsAndIndices( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		}

		/**
		 * Sets the triangle's vertices by copying the given attribute values.
		 *
		 * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
		 * @param {number} i0 - The attribute index representing the first corner of the triangle.
		 * @param {number} i1 - The attribute index representing the second corner of the triangle.
		 * @param {number} i2 - The attribute index representing the third corner of the triangle.
		 * @return {Triangle} A reference to this triangle.
		 */
		setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

			this.a.fromBufferAttribute( attribute, i0 );
			this.b.fromBufferAttribute( attribute, i1 );
			this.c.fromBufferAttribute( attribute, i2 );

			return this;

		}

		/**
		 * Returns a new triangle with copied values from this instance.
		 *
		 * @return {Triangle} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

		/**
		 * Copies the values of the given triangle to this instance.
		 *
		 * @param {Triangle} triangle - The triangle to copy.
		 * @return {Triangle} A reference to this triangle.
		 */
		copy( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		}

		/**
		 * Computes the area of the triangle.
		 *
		 * @return {number} The triangle's area.
		 */
		getArea() {

			_v0$1.subVectors( this.c, this.b );
			_v1.subVectors( this.a, this.b );

			return _v0$1.cross( _v1 ).length() * 0.5;

		}

		/**
		 * Computes the midpoint of the triangle.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The triangle's midpoint.
		 */
		getMidpoint( target ) {

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		}

		/**
		 * Computes the normal of the triangle.
		 *
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The triangle's normal.
		 */
		getNormal( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		}

		/**
		 * Computes a plane the triangle lies within.
		 *
		 * @param {Plane} target - The target vector that is used to store the method's result.
		 * @return {Plane} The plane the triangle lies within.
		 */
		getPlane( target ) {

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		}

		/**
		 * Computes a barycentric coordinates from the given vector.
		 * Returns `null` if the triangle is degenerate.
		 *
		 * @param {Vector3} point - A point in 3D space.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The barycentric coordinates for the given point
		 */
		getBarycoord( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		}

		/**
		 * Computes the value barycentrically interpolated for the given point on the
		 * triangle. Returns `null` if the triangle is degenerate.
		 *
		 * @param {Vector3} point - Position of interpolated point.
		 * @param {Vector3} v1 - Value to interpolate of first vertex.
		 * @param {Vector3} v2 - Value to interpolate of second vertex.
		 * @param {Vector3} v3 - Value to interpolate of third vertex.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {?Vector3} The interpolated value.
		 */
		getInterpolation( point, v1, v2, v3, target ) {

			return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

		}

		/**
		 * Returns `true` if the given point, when projected onto the plane of the
		 * triangle, lies within the triangle.
		 *
		 * @param {Vector3} point - The point in 3D space to test.
		 * @return {boolean} Whether the given point, when projected onto the plane of the
		 * triangle, lies within the triangle or not.
		 */
		containsPoint( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		}

		/**
		 * Returns `true` if the triangle is oriented towards the given direction.
		 *
		 * @param {Vector3} direction - The (normalized) direction vector.
		 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
		 */
		isFrontFacing( direction ) {

			return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

		}

		/**
		 * Returns `true` if this triangle intersects with the given box.
		 *
		 * @param {Box3} box - The box to intersect.
		 * @return {boolean} Whether this triangle intersects with the given box or not.
		 */
		intersectsBox( box ) {

			return box.intersectsTriangle( this );

		}

		/**
		 * Returns the closest point on the triangle to the given point.
		 *
		 * @param {Vector3} p - The point to compute the closest point for.
		 * @param {Vector3} target - The target vector that is used to store the method's result.
		 * @return {Vector3} The closest point on the triangle.
		 */
		closestPointToPoint( p, target ) {

			const a = this.a, b = this.b, c = this.c;
			let v, w;

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors( b, a );
			_vac.subVectors( c, a );
			_vap.subVectors( p, a );
			const d1 = _vab.dot( _vap );
			const d2 = _vac.dot( _vap );
			if ( d1 <= 0 && d2 <= 0 ) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy( a );

			}

			_vbp.subVectors( p, b );
			const d3 = _vab.dot( _vbp );
			const d4 = _vac.dot( _vbp );
			if ( d3 >= 0 && d4 <= d3 ) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy( b );

			}

			const vc = d1 * d4 - d3 * d2;
			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

				v = d1 / ( d1 - d3 );
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy( a ).addScaledVector( _vab, v );

			}

			_vcp.subVectors( p, c );
			const d5 = _vab.dot( _vcp );
			const d6 = _vac.dot( _vcp );
			if ( d6 >= 0 && d5 <= d6 ) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy( c );

			}

			const vb = d5 * d2 - d1 * d6;
			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

				w = d2 / ( d2 - d6 );
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy( a ).addScaledVector( _vac, w );

			}

			const va = d3 * d6 - d5 * d4;
			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

				_vbc.subVectors( c, b );
				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

			}

			// face region
			const denom = 1 / ( va + vb + vc );
			// u = va * denom
			v = vb * denom;
			w = vc * denom;

			return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

		}

		/**
		 * Returns `true` if this triangle is equal with the given one.
		 *
		 * @param {Triangle} triangle - The triangle to test for equality.
		 * @return {boolean} Whether this triangle is equal with the given one.
		 */
		equals( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	}

	/**
	 * A material for drawing geometries in a simple shaded (flat or wireframe) way.
	 *
	 * This material is not affected by lights.
	 *
	 * @augments Material
	 */
	class MeshBasicMaterial extends Material$1 {

		/**
		 * Constructs a new mesh basic material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */
		constructor( parameters ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMeshBasicMaterial = true;

			this.type = 'MeshBasicMaterial';

			/**
			 * Color of the material.
			 *
			 * @type {Color}
			 * @default (1,1,1)
			 */
			this.color = new Color( 0xffffff ); // diffuse

			/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
			 * color is modulated by the diffuse `color`.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.map = null;

			/**
			 * The light map. Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.lightMap = null;

			/**
			 * Intensity of the baked light.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.lightMapIntensity = 1.0;

			/**
			 * The red channel of this texture is used as the ambient occlusion map.
			 * Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.aoMap = null;

			/**
			 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
			 * disables ambient occlusion. Where intensity is `1` and the AO map's
			 * red channel is also `1`, ambient light is fully occluded on a surface.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.aoMapIntensity = 1.0;

			/**
			 * Specular map used by the material.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.specularMap = null;

			/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.alphaMap = null;

			/**
			 * The environment map.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.envMap = null;

			/**
			 * The rotation of the environment map in radians.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */
			this.envMapRotation = new Euler();

			/**
			 * How to combine the result of the surface's color with the environment map, if any.
			 *
			 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
			 * blend between the two colors.
			 *
			 * @type {(MultiplyOperation|MixOperation|AddOperation)}
			 * @default MultiplyOperation
			 */
			this.combine = MultiplyOperation;

			/**
			 * How much the environment map affects the surface.
			 * The valid range is between `0` (no reflections) and `1` (full reflections).
			 *
			 * @type {number}
			 * @default 1
			 */
			this.reflectivity = 1;

			/**
			 * The index of refraction (IOR) of air (approximately 1) divided by the
			 * index of refraction of the material. It is used with environment mapping
			 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
			 * The refraction ratio should not exceed `1`.
			 *
			 * @type {number}
			 * @default 0.98
			 */
			this.refractionRatio = 0.98;

			/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.wireframe = false;

			/**
			 * Controls the thickness of the wireframe.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.wireframeLinewidth = 1;

			/**
			 * Defines appearance of wireframe ends.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */
			this.wireframeLinecap = 'round';

			/**
			 * Defines appearance of wireframe joints.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */
			this.wireframeLinejoin = 'round';

			/**
			 * Whether the material is affected by fog or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.envMapRotation.copy( source.envMapRotation );
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.fog = source.fog;

			return this;

		}

	}

	const _inverseMatrix = /*@__PURE__*/ new Matrix4();
	const _ray = /*@__PURE__*/ new Ray$1();
	const _sphere = /*@__PURE__*/ new Sphere$1();
	const _sphereHitAt = /*@__PURE__*/ new Vector3();

	const _vA = /*@__PURE__*/ new Vector3();
	const _vB = /*@__PURE__*/ new Vector3();
	const _vC = /*@__PURE__*/ new Vector3();

	const _tempA = /*@__PURE__*/ new Vector3();
	const _morphA = /*@__PURE__*/ new Vector3();

	const _intersectionPoint = /*@__PURE__*/ new Vector3();
	const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

	/**
	 * Class representing triangular polygon mesh based objects.
	 *
	 * ```js
	 * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
	 * const mesh = new THREE.Mesh( geometry, material );
	 * scene.add( mesh );
	 * ```
	 *
	 * @augments Object3D
	 */
	class Mesh extends Object3D {

		/**
		 * Constructs a new mesh.
		 *
		 * @param {BufferGeometry} [geometry] - The mesh geometry.
		 * @param {Material|Array<Material>} [material] - The mesh material.
		 */
		constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMesh = true;

			this.type = 'Mesh';

			/**
			 * The mesh geometry.
			 *
			 * @type {BufferGeometry}
			 */
			this.geometry = geometry;

			/**
			 * The mesh material.
			 *
			 * @type {Material|Array<Material>}
			 * @default MeshBasicMaterial
			 */
			this.material = material;

			/**
			 * A dictionary representing the morph targets in the geometry. The key is the
			 * morph targets name, the value its attribute index. This member is `undefined`
			 * by default and only set when morph targets are detected in the geometry.
			 *
			 * @type {Object<String,number>|undefined}
			 * @default undefined
			 */
			this.morphTargetDictionary = undefined;

			/**
			 * An array of weights typically in the range `[0,1]` that specify how much of the morph
			 * is applied. This member is `undefined` by default and only set when morph targets are
			 * detected in the geometry.
			 *
			 * @type {Array<number>|undefined}
			 * @default undefined
			 */
			this.morphTargetInfluences = undefined;

			/**
			 * The number of instances of this mesh.
			 * Can only be used with {@link WebGPURenderer}.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.count = 1;

			this.updateMorphTargets();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
			this.geometry = source.geometry;

			return this;

		}

		/**
		 * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
		 * to make sure existing morph targets can influence this 3D object.
		 */
		updateMorphTargets() {

			const geometry = this.geometry;

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		}

		/**
		 * Returns the local-space position of the vertex at the given index, taking into
		 * account the current animation state of both morph targets and skinning.
		 *
		 * @param {number} index - The vertex index.
		 * @param {Vector3} target - The target object that is used to store the method's result.
		 * @return {Vector3} The vertex position in local space.
		 */
		getVertexPosition( index, target ) {

			const geometry = this.geometry;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;

			target.fromBufferAttribute( position, index );

			const morphInfluences = this.morphTargetInfluences;

			if ( morphPosition && morphInfluences ) {

				_morphA.set( 0, 0, 0 );

				for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

					const influence = morphInfluences[ i ];
					const morphAttribute = morphPosition[ i ];

					if ( influence === 0 ) continue;

					_tempA.fromBufferAttribute( morphAttribute, index );

					if ( morphTargetsRelative ) {

						_morphA.addScaledVector( _tempA, influence );

					} else {

						_morphA.addScaledVector( _tempA.sub( target ), influence );

					}

				}

				target.add( _morphA );

			}

			return target;

		}

		/**
		 * Computes intersection points between a casted ray and this line.
		 *
		 * @param {Raycaster} raycaster - The raycaster.
		 * @param {Array<Object>} intersects - The target array that holds the intersection points.
		 */
		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// test with bounding sphere in world space

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere );
			_sphere.applyMatrix4( matrixWorld );

			// check distance from ray origin to bounding sphere

			_ray.copy( raycaster.ray ).recast( raycaster.near );

			if ( _sphere.containsPoint( _ray.origin ) === false ) {

				if ( _ray.intersectSphere( _sphere, _sphereHitAt ) === null ) return;

				if ( _ray.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

			}

			// convert ray to local space of mesh

			_inverseMatrix.copy( matrixWorld ).invert();
			_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

			// test with bounding box in local space

			if ( geometry.boundingBox !== null ) {

				if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			// test for intersections with geometry

			this._computeIntersections( raycaster, intersects, _ray );

		}

		_computeIntersections( raycaster, intersects, rayLocalSpace ) {

			let intersection;

			const geometry = this.geometry;
			const material = this.material;

			const index = geometry.index;
			const position = geometry.attributes.position;
			const uv = geometry.attributes.uv;
			const uv1 = geometry.attributes.uv1;
			const normal = geometry.attributes.normal;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		}

	}

	function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

		let intersect;

		if ( material.side === BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

		}

		if ( intersect === null ) return null;

		_intersectionPointWorld.copy( point );
		_intersectionPointWorld.applyMatrix4( object.matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

		object.getVertexPosition( a, _vA );
		object.getVertexPosition( b, _vB );
		object.getVertexPosition( c, _vC );

		const intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

		if ( intersection ) {

			const barycoord = new Vector3();
			Triangle.getBarycoord( _intersectionPoint, _vA, _vB, _vC, barycoord );

			if ( uv ) {

				intersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );

			}

			if ( uv1 ) {

				intersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );

			}

			if ( normal ) {

				intersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );

				if ( intersection.normal.dot( ray.direction ) > 0 ) {

					intersection.normal.multiplyScalar( -1 );

				}

			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};

			Triangle.getNormal( _vA, _vB, _vC, face.normal );

			intersection.face = face;
			intersection.barycoord = barycoord;

		}

		return intersection;

	}

	var alphahash_fragment = /* glsl */`
#ifdef USE_ALPHAHASH

	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;

#endif
`;

	var alphahash_pars_fragment = /* glsl */`
#ifdef USE_ALPHAHASH

	/**
	 * See: https://casual-effects.com/research/Wyman2017Hashed/index.html
	 */

	const float ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.

	float hash2D( vec2 value ) {

		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );

	}

	float hash3D( vec3 value ) {

		return hash2D( vec2( hash2D( value.xy ), value.z ) );

	}

	float getAlphaHashThreshold( vec3 position ) {

		// Find the discretized derivatives of our coordinates
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );

		// Find two nearest log-discretized noise scales
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);

		// Compute alpha thresholds at our two noise scales
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);

		// Factor to interpolate lerp with
		float lerpFactor = fract( log2( pixScale ) );

		// Interpolate alpha threshold from noise at two scales
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;

		// Pass into CDF to compute uniformly distrib threshold
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);

		// Find our final, uniformly distributed alpha threshold ()
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;

		// Avoids  == 0. Could also do  =1-
		return clamp( threshold , 1.0e-6, 1.0 );

	}

#endif
`;

	var alphamap_fragment = /* glsl */`
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;

#endif
`;

	var alphamap_pars_fragment = /* glsl */`
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`;

	var alphatest_fragment = /* glsl */`
#ifdef USE_ALPHATEST

	#ifdef ALPHA_TO_COVERAGE

	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;

	#else

	if ( diffuseColor.a < alphaTest ) discard;

	#endif

#endif
`;

	var alphatest_pars_fragment = /* glsl */`
#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif
`;

	var aomap_fragment = /* glsl */`
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif

	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );

	#endif

#endif
`;

	var aomap_pars_fragment = /* glsl */`
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`;

	var batching_pars_vertex = /* glsl */`
#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif

	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {

		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );

	}

	float getIndirectIndex( const in int i ) {

		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );

	}

#endif

#ifdef USE_BATCHING_COLOR

	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {

		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;

	}

#endif
`;

	var batching_vertex = /* glsl */`
#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif
`;

	var begin_vertex = /* glsl */`
vec3 transformed = vec3( position );

#ifdef USE_ALPHAHASH

	vPosition = vec3( position );

#endif
`;

	var beginnormal_vertex = /* glsl */`
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`;

	var bsdfs = /* glsl */`

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( specularColor, 1.0, dotVH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

`;

	var iridescence_fragment = /* glsl */`

#ifdef USE_IRIDESCENCE

	// XYZ to linear-sRGB color space
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);

	// Assume air interface for top
	// Note: We don't handle the case fresnel0 == 1
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {

		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );

	}

	// Conversion FO/IOR
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {

		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );

	}

	// ior is a value between 1.0 and 3.0. 1.0 is air interface
	float IorToFresnel0( float transmittedIor, float incidentIor ) {

		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));

	}

	// Fresnel equations for dielectric/dielectric interfaces.
	// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
	// Evaluation XYZ sensitivity curves in Fourier space
	vec3 evalSensitivity( float OPD, vec3 shift ) {

		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;

		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;

	}

	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {

		vec3 I;

		// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		// Evaluate the cosTheta on the base layer (Snell law)
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );

		// Handle TIR:
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {

			return vec3( 1.0 );

		}

		float cosTheta2 = sqrt( cosTheta2Sq );

		// First interface
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;

		// Second interface
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0
		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;

		// Phase shift
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;

		// Compound terms
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );

		// Reflectance term for m = 0 (DC term amplitude)
		vec3 C0 = R12 + Rs;
		I = C0;

		// Reflectance term for m > 0 (pairs of diracs)
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {

			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;

		}

		// Since out of gamut colors might be produced, negative color values are clamped to 0.
		return max( I, vec3( 0.0 ) );

	}

#endif

`;

	var bumpmap_pars_fragment = /* glsl */`
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );

		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

		// normalize is done to ensure that the bump map looks the same regardless of the texture's scale
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm; // normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 ) * faceDirection;

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`;

	var clipping_planes_fragment = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#ifdef ALPHA_TO_COVERAGE

		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;

		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );

			if ( clipOpacity == 0.0 ) discard;

		}
		#pragma unroll_loop_end

		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

			float unionClipOpacity = 1.0;

			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );

			}
			#pragma unroll_loop_end

			clipOpacity *= 1.0 - unionClipOpacity;

		#endif

		diffuseColor.a *= clipOpacity;

		if ( diffuseColor.a == 0.0 ) discard;

	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

		}
		#pragma unroll_loop_end

		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

			bool clipped = true;

			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

			}
			#pragma unroll_loop_end

			if ( clipped ) discard;

		#endif

	#endif

#endif
`;

	var clipping_planes_pars_fragment = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`;

	var clipping_planes_pars_vertex = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`;

	var clipping_planes_vertex = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`;

	var color_fragment = /* glsl */`
#if defined( USE_COLOR_ALPHA )

	diffuseColor *= vColor;

#elif defined( USE_COLOR )

	diffuseColor.rgb *= vColor;

#endif
`;

	var color_pars_fragment = /* glsl */`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR )

	varying vec3 vColor;

#endif
`;

	var color_pars_vertex = /* glsl */`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )

	varying vec3 vColor;

#endif
`;

	var color_vertex = /* glsl */`
#if defined( USE_COLOR_ALPHA )

	vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif

#ifdef USE_BATCHING_COLOR

	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );

	vColor.xyz *= batchingColor.xyz;

#endif
`;

	var common = /* glsl */`
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }

// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {

	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );

	return fract( sin( sn ) * c );

}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

#ifdef USE_ALPHAHASH

	varying vec3 vPosition;

#endif

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}

vec3 BRDF_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated

float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated
`;

	var cube_uv_reflection_fragment = /* glsl */`
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		uv.x += filterInt * 3.0 * cubeUV_minTileSize;

		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );

		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;

		#ifdef texture2DGradEXT

			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering

		#else

			return texture2D( envMap, uv ).rgb;

		#endif

	}

	// These defines must match with PMREMGenerator

	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= cubeUV_r1 ) {

			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;

		} else if ( roughness >= cubeUV_r4 ) {

			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;

		} else if ( roughness >= cubeUV_r5 ) {

			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;

		} else if ( roughness >= cubeUV_r6 ) {

			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`;

	var defaultnormal_vertex = /* glsl */`

vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT

	vec3 transformedTangent = objectTangent;

#endif

#ifdef USE_BATCHING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;

	#ifdef USE_TANGENT

		transformedTangent = bm * transformedTangent;

	#endif

#endif

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;

	#ifdef USE_TANGENT

		transformedTangent = im * transformedTangent;

	#endif

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`;

	var displacementmap_pars_vertex = /* glsl */`
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`;

	var displacementmap_vertex = /* glsl */`
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );

#endif
`;

	var emissivemap_fragment = /* glsl */`
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );

	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE

		// use inline sRGB decode until browsers properly support SRGB8_ALPHA8 with video textures (#26516)

		emissiveColor = sRGBTransferEOTF( emissiveColor );

	#endif

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`;

	var emissivemap_pars_fragment = /* glsl */`
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`;

	var colorspace_fragment = /* glsl */`
gl_FragColor = linearToOutputTexel( gl_FragColor );
`;

	var colorspace_pars_fragment = /* glsl */`

vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}

vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

`;

	var envmap_fragment = /* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`;

	var envmap_common_pars_fragment = /* glsl */`
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`;

	var envmap_pars_fragment = /* glsl */`
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`;

	var envmap_pars_vertex = /* glsl */`
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`;

	var envmap_vertex = /* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`;

	var fog_vertex = /* glsl */`
#ifdef USE_FOG

	vFogDepth = - mvPosition.z;

#endif
`;

	var fog_pars_vertex = /* glsl */`
#ifdef USE_FOG

	varying float vFogDepth;

#endif
`;

	var fog_fragment = /* glsl */`
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`;

	var fog_pars_fragment = /* glsl */`
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float vFogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`;

	var gradientmap_pars_fragment = /* glsl */`

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return vec3( texture2D( gradientMap, coord ).r );

	#else

		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );

	#endif

}
`;

	var lightmap_pars_fragment = /* glsl */`
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`;

	var lights_lambert_fragment = /* glsl */`
LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;
`;

	var lights_lambert_pars_fragment = /* glsl */`
varying vec3 vViewPosition;

struct LambertMaterial {

	vec3 diffuseColor;
	float specularStrength;

};

void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert
`;

	var lights_pars_begin = /* glsl */`
uniform bool receiveShadow;
uniform vec3 ambientLightColor;

#if defined( USE_LIGHT_PROBES )

	uniform vec3 lightProbe[ 9 ];

#endif

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {

	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	return irradiance;

}

float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if ( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

}

float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {

	return smoothstep( coneCosine, penumbraCosine, angleCosine );

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {

		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {

		vec3 lVector = pointLight.position - geometryPosition;

		light.direction = normalize( lVector );

		float lightDistance = length( lVector );

		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {

		vec3 lVector = spotLight.position - geometryPosition;

		light.direction = normalize( lVector );

		float angleCos = dot( light.direction, spotLight.direction );

		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );

		if ( spotAttenuation > 0.0 ) {

			float lightDistance = length( lVector );

			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );

		} else {

			light.color = vec3( 0.0 );
			light.visible = false;

		}

	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {

		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		return irradiance;

	}

#endif
`;

	var envmap_physical_pars_fragment = /* glsl */`
#ifdef USE_ENVMAP

	vec3 getIBLIrradiance( const in vec3 normal ) {

		#ifdef ENVMAP_TYPE_CUBE_UV

			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );

			return PI * envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {

		#ifdef ENVMAP_TYPE_CUBE_UV

			vec3 reflectVec = reflect( - viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );

			return envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

	#ifdef USE_ANISOTROPY

		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {

			#ifdef ENVMAP_TYPE_CUBE_UV

			  // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );

				return getIBLRadiance( viewDir, bentNormal, roughness );

			#else

				return vec3( 0.0 );

			#endif

		}

	#endif

#endif
`;

	var lights_toon_fragment = /* glsl */`
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`;

	var lights_toon_pars_fragment = /* glsl */`
varying vec3 vViewPosition;

struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
`;

	var lights_phong_fragment = /* glsl */`
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`;

	var lights_phong_pars_fragment = /* glsl */`
varying vec3 vViewPosition;

struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
`;

	var lights_physical_fragment = /* glsl */`
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );

#ifdef IOR

	material.ior = ior;

	#ifdef USE_SPECULAR

		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;

		#ifdef USE_SPECULAR_COLORMAP

			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;

		#endif

		#ifdef USE_SPECULAR_INTENSITYMAP

			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;

		#endif

		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );

	#else

		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;

	#endif

	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;

#endif

#ifdef USE_CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_DISPERSION

	material.dispersion = dispersion;

#endif

#ifdef USE_IRIDESCENCE

	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;

	#ifdef USE_IRIDESCENCEMAP

		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;

	#endif

	#ifdef USE_IRIDESCENCE_THICKNESSMAP

		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;

	#else

		material.iridescenceThickness = iridescenceThicknessMaximum;

	#endif

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheenColor;

	#ifdef USE_SHEEN_COLORMAP

		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;

	#endif

	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );

	#ifdef USE_SHEEN_ROUGHNESSMAP

		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;

	#endif

#endif

#ifdef USE_ANISOTROPY

	#ifdef USE_ANISOTROPYMAP

		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;

	#else

		vec2 anisotropyV = anisotropyVector;

	#endif

	material.anisotropy = length( anisotropyV );

	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}

	// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );

	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;

#endif
`;

	var lights_physical_pars_fragment = /* glsl */`

struct PhysicalMaterial {

	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;

	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif

	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif

	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif

	#ifdef IOR
		float ior;
	#endif

	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif

	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif

};

// temporary
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );

vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );

    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf
#ifdef USE_ANISOTROPY

	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {

		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );

		return saturate(v);

	}

	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {

		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;

		return RECIPROCAL_PI * a2 * pow2 ( w2 );

	}

#endif

#ifdef USE_CLEARCOAT

	// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {

		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;

		float alpha = pow2( roughness ); // UE4's roughness

		vec3 halfDir = normalize( lightDir + viewDir );

		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );

		vec3 F = F_Schlick( f0, f90, dotVH );

		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

		float D = D_GGX( alpha, dotNH );

		return F * ( V * D );

	}

#endif

vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {

	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( f0, f90, dotVH );

	#ifdef USE_IRIDESCENCE

		F = mix( F, material.iridescenceFresnel, material.iridescence );

	#endif

	#ifdef USE_ANISOTROPY

		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );

		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );

		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );

	#else

		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

		float D = D_GGX( alpha, dotNH );

	#endif

	return F * ( V * D );

}

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see reference)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float D_Charlie( float roughness, float dotNH ) {

	float alpha = pow2( roughness );

	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );

}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float V_Neubelt( float dotNV, float dotNL ) {

	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );

}

vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );

	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );

	return sheenColor * ( D * V );

}

#endif

// This is a curve-fit approximation to the "Charlie sheen" BRDF integrated over the hemisphere from
// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	float r2 = roughness * roughness;

	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;

	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;

	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );

	return saturate( DG * RECIPROCAL_PI );

}

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;

	return fab;

}

vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	return specularColor * fab.x + specularF90 * fab.y;

}

// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	#ifdef USE_IRIDESCENCE

		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );

	#else

		vec3 Fr = specularColor;

	#endif

	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;

	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifdef USE_CLEARCOAT

		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = dotNLcc * directLight.color;

		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );

	#endif

	#ifdef USE_SHEEN

		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );

	#endif

	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef USE_CLEARCOAT

		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );

	#endif

	#ifdef USE_SHEEN

		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );

	#endif

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	#ifdef USE_IRIDESCENCE

		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );

	#else

		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );

	#endif

	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );

	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`;

	var lights_fragment_begin = /* glsl */`
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE

	float dotNVi = saturate( dot( normal, geometryViewDir ) );

	if ( material.iridescenceThickness == 0.0 ) {

		material.iridescence = 0.0;

	} else {

		material.iridescence = saturate( material.iridescence );

	}

	if ( material.iridescence > 0.0 ) {

		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );

		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );

	}

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif

		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif

		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`;

	var lights_fragment_maps = /* glsl */`
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getIBLIrradiance( geometryNormal );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	#ifdef USE_ANISOTROPY

		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );

	#else

		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );

	#endif

	#ifdef USE_CLEARCOAT

		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );

	#endif

#endif
`;

	var lights_fragment_end = /* glsl */`
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

#endif
`;

	var logdepthbuf_fragment = /* glsl */`
#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`;

	var logdepthbuf_pars_fragment = /* glsl */`
#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`;

	var logdepthbuf_pars_vertex = /* glsl */`
#ifdef USE_LOGARITHMIC_DEPTH_BUFFER

	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`;

	var logdepthbuf_vertex = /* glsl */`
#ifdef USE_LOGARITHMIC_DEPTH_BUFFER

	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

#endif
`;

	var map_fragment = /* glsl */`
#ifdef USE_MAP

	vec4 sampledDiffuseColor = texture2D( map, vMapUv );

	#ifdef DECODE_VIDEO_TEXTURE

		// use inline sRGB decode until browsers properly support SRGB8_ALPHA8 with video textures (#26516)

		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );

	#endif

	diffuseColor *= sampledDiffuseColor;

#endif
`;

	var map_pars_fragment = /* glsl */`
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`;

	var map_particle_fragment = /* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	#if defined( USE_POINTS_UV )

		vec2 uv = vUv;

	#else

		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

	#endif

#endif

#ifdef USE_MAP

	diffuseColor *= texture2D( map, uv );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`;

	var map_particle_pars_fragment = /* glsl */`
#if defined( USE_POINTS_UV )

	varying vec2 vUv;

#else

	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

		uniform mat3 uvTransform;

	#endif

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`;

	var metalnessmap_fragment = /* glsl */`
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`;

	var metalnessmap_pars_fragment = /* glsl */`
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`;

	var morphinstance_vertex = /* glsl */`
#ifdef USE_INSTANCING_MORPH

	float morphTargetInfluences[ MORPHTARGETS_COUNT ];

	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;

	}
#endif
`;

	var morphcolor_vertex = /* glsl */`
#if defined( USE_MORPHCOLORS )

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	vColor *= morphTargetBaseInfluence;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		#if defined( USE_COLOR_ALPHA )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];

		#elif defined( USE_COLOR )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];

		#endif

	}

#endif
`;

	var morphnormal_vertex = /* glsl */`
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];

	}

#endif
`;

	var morphtarget_pars_vertex = /* glsl */`
#ifdef USE_MORPHTARGETS

	#ifndef USE_INSTANCING_MORPH

		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];

	#endif

	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;

	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {

		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;

		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );

	}

#endif
`;

	var morphtarget_vertex = /* glsl */`
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];

	}

#endif
`;

	var normal_fragment_begin = /* glsl */`
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal *= faceDirection;

	#endif

#endif

#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )

	#ifdef USE_TANGENT

		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

	#else

		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);

	#endif

	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;

	#endif

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	#ifdef USE_TANGENT

		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

	#else

		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );

	#endif

	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 nonPerturbedNormal = normal;

`;

	var normal_fragment_maps = /* glsl */`

#ifdef USE_NORMALMAP_OBJECTSPACE

	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( USE_NORMALMAP_TANGENTSPACE )

	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	normal = normalize( tbn * mapN );

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`;

	var normal_pars_fragment = /* glsl */`
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`;

	var normal_pars_vertex = /* glsl */`
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`;

	var normal_vertex = /* glsl */`
#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif
`;

	var normalmap_pars_fragment = /* glsl */`
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef USE_NORMALMAP_OBJECTSPACE

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {

		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );

		vec3 N = surf_norm; // normalized

		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );

		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;

		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );

		return mat3( T * scale, B * scale, N );

	}

#endif
`;

	var clearcoat_normal_fragment_begin = /* glsl */`
#ifdef USE_CLEARCOAT

	vec3 clearcoatNormal = nonPerturbedNormal;

#endif
`;

	var clearcoat_normal_fragment_maps = /* glsl */`
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	clearcoatNormal = normalize( tbn2 * clearcoatMapN );

#endif
`;

	var clearcoat_pars_fragment = /* glsl */`

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif
`;

	var iridescence_pars_fragment = /* glsl */`

#ifdef USE_IRIDESCENCEMAP

	uniform sampler2D iridescenceMap;

#endif

#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform sampler2D iridescenceThicknessMap;

#endif
`;

	var opaque_fragment = /* glsl */`
#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif

#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif

gl_FragColor = vec4( outgoingLight, diffuseColor.a );
`;

	var packing = /* glsl */`
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)
const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;

const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );

const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );

vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}

vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	// the 0.9999 tweak is unimportant, very tiny empirical improvement
	// return vec3( vuf * Inv255, gf * PackUpscale, bf * 0.9999 );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}

vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}

float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}

float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}

vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}

vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	// -near maps to 0; -far maps to 1
	return ( viewZ + near ) / ( near - far );
}

float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	// maps orthographic depth in [ 0, 1 ] to viewZ
	return depth * ( near - far ) - near;
}

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	// -near maps to 0; -far maps to 1
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}

float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	// maps perspective depth in [ 0, 1 ] to viewZ
	return ( near * far ) / ( ( far - near ) * depth - far );
}
`;

	var premultiplied_alpha_fragment = /* glsl */`
#ifdef PREMULTIPLIED_ALPHA

	// Get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`;

	var project_vertex = /* glsl */`
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_BATCHING

	mvPosition = batchingMatrix * mvPosition;

#endif

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`;

	var dithering_fragment = /* glsl */`
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`;

	var dithering_pars_fragment = /* glsl */`
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift according to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`;

	var roughnessmap_fragment = /* glsl */`
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`;

	var roughnessmap_pars_fragment = /* glsl */`
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`;

	var shadowmap_pars_fragment = /* glsl */`
#if NUM_SPOT_LIGHT_COORDS > 0

	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];

#endif

#if NUM_SPOT_LIGHT_MAPS > 0

	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];

#endif

#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );

		#ifdef USE_REVERSED_DEPTH_BUFFER

			return step( depth, compare );

		#else

			return step( compare, depth );

		#endif

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		#ifdef USE_REVERSED_DEPTH_BUFFER

			float hard_shadow = step( distribution.x, compare );

		#else

			float hard_shadow = step( compare, distribution.x );

		#endif

		if ( hard_shadow != 1.0 ) {

			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return mix( 1.0, shadow, shadowIntensity );

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		float shadow = 1.0;

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );

		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {

			// dp = normalized distance from light to fragment position
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
			dp += shadowBias;

			// bd3D = base direction 3D
			vec3 bd3D = normalize( lightToPosition );

			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );

			#else // no percentage-closer filtering

				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

			#endif

		}

		return mix( 1.0, shadow, shadowIntensity );

	}

#endif
`;

	var shadowmap_pars_vertex = /* glsl */`

#if NUM_SPOT_LIGHT_COORDS > 0

	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];

#endif

#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`;

	var shadowmap_vertex = /* glsl */`

#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )

	// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;

#endif

#if defined( USE_SHADOWMAP )

	#if NUM_DIR_LIGHT_SHADOWS > 0

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

		}
		#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

		}
		#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif

// spot lights can be evaluated without active shadow mapping (when SpotLight.map is used)

#if NUM_SPOT_LIGHT_COORDS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {

		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

#endif


`;

	var shadowmask_pars_fragment = /* glsl */`
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`;

	var skinbase_vertex = /* glsl */`
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`;

	var skinning_pars_vertex = /* glsl */`
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	uniform highp sampler2D boneTexture;

	mat4 getBoneMatrix( const in float i ) {

		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );

		return mat4( v1, v2, v3, v4 );

	}

#endif
`;

	var skinning_vertex = /* glsl */`
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`;

	var skinnormal_vertex = /* glsl */`
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`;

	var specularmap_fragment = /* glsl */`
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`;

	var specularmap_pars_fragment = /* glsl */`
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`;

	var tonemapping_fragment = /* glsl */`
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`;

	var tonemapping_pars_fragment = /* glsl */`
#ifndef saturate
// <common> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return saturate( toneMappingExposure * color );

}

// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 CineonToneMapping( vec3 color ) {

	// filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

// Matrices for rec 2020 <> rec 709 color space conversion
// matrix provided in row-major order so it has been transposed
// https://www.itu.int/pub/R-REP-BT.2407-2017
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);

const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);

// https://iolite-engine.com/blog_posts/minimal_agx_implementation
// Mean error^2: 3.6705141e-06
vec3 agxDefaultContrastApprox( vec3 x ) {

	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;

	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;

}

// AgX Tone Mapping implementation based on Filament, which in turn is based
// on Blender's implementation using rec 2020 primaries
// https://github.com/google/filament/pull/7236
// Inputs and outputs are encoded as Linear-sRGB.

vec3 AgXToneMapping( vec3 color ) {

	// AgX constants
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);

	// explicit AgXOutsetMatrix generated from Filaments AgXOutsetMatrixInv
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);

	// LOG2_MIN      = -10.0
	// LOG2_MAX      =  +6.5
	// MIDDLE_GRAY   =  0.18
	const float AgxMinEv = - 12.47393;  // log2( pow( 2, LOG2_MIN ) * MIDDLE_GRAY )
	const float AgxMaxEv = 4.026069;    // log2( pow( 2, LOG2_MAX ) * MIDDLE_GRAY )

	color *= toneMappingExposure;

	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;

	color = AgXInsetMatrix * color;

	// Log2 encoding
	color = max( color, 1e-10 ); // avoid 0 or negative numbers for log2
	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );

	color = clamp( color, 0.0, 1.0 );

	// Apply sigmoid
	color = agxDefaultContrastApprox( color );

	// Apply AgX look
	// v = agxLook(v, look);

	color = AgXOutsetMatrix * color;

	// Linearize
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );

	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;

	// Gamut mapping. Simple clamp for now.
	color = clamp( color, 0.0, 1.0 );

	return color;

}

// https://modelviewer.dev/examples/tone-mapping

vec3 NeutralToneMapping( vec3 color ) {

	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;

	color *= toneMappingExposure;

	float x = min( color.r, min( color.g, color.b ) );

	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;

	color -= offset;

	float peak = max( color.r, max( color.g, color.b ) );

	if ( peak < StartCompression ) return color;

	float d = 1. - StartCompression;

	float newPeak = 1. - d * d / ( peak + d - StartCompression );

	color *= newPeak / peak;

	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );

	return mix( color, vec3( newPeak ), g );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`;

	var transmission_fragment = /* glsl */`
#ifdef USE_TRANSMISSION

	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;

	#ifdef USE_TRANSMISSIONMAP

		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;

	#endif

	#ifdef USE_THICKNESSMAP

		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;

	#endif

	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );

	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );

	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );

	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );

#endif
`;

	var transmission_pars_fragment = /* glsl */`
#ifdef USE_TRANSMISSION

	// Transmission code is based on glTF-Sampler-Viewer
	// https://github.com/KhronosGroup/glTF-Sample-Viewer

	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;

	#ifdef USE_TRANSMISSIONMAP

		uniform sampler2D transmissionMap;

	#endif

	#ifdef USE_THICKNESSMAP

		uniform sampler2D thicknessMap;

	#endif

	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;

	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;

	varying vec3 vWorldPosition;

	// Mipped Bicubic Texture Filtering by N8
	// https://www.shadertoy.com/view/Dl2SDW

	float w0( float a ) {

		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );

	}

	float w1( float a ) {

		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );

	}

	float w2( float a ){

		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );

	}

	float w3( float a ) {

		return ( 1.0 / 6.0 ) * ( a * a * a );

	}

	// g0 and g1 are the two amplitude functions
	float g0( float a ) {

		return w0( a ) + w1( a );

	}

	float g1( float a ) {

		return w2( a ) + w3( a );

	}

	// h0 and h1 are the two offset functions
	float h0( float a ) {

		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );

	}

	float h1( float a ) {

		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );

	}

	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {

		uv = uv * texelSize.zw + 0.5;

		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );

		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );

		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;

		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );

	}

	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {

		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );

	}

	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {

		// Direction of refracted light.
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );

		// Compute rotation-independent scaling of the model matrix.
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		// The thickness is specified in local space.
		return normalize( refractionVector ) * thickness * modelScale;

	}

	float applyIorToRoughness( const in float roughness, const in float ior ) {

		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );

	}

	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {

		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );

	}

	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {

		if ( isinf( attenuationDistance ) ) {

			// Attenuation distance is +, i.e. the transmitted color is not attenuated at all.
			return vec3( 1.0 );

		} else {

			// Compute light attenuation using Beer's law.
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
			return transmittance;

		}

	}

	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {

		vec4 transmittedLight;
		vec3 transmittance;

		#ifdef USE_DISPERSION

			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );

			for ( int i = 0; i < 3; i ++ ) {

				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;

				// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;

				// Sample framebuffer to get pixel the refracted ray hits.
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;

				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];

			}

			transmittedLight.a /= 3.0;

		#else

			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;

			// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;

			// Sample framebuffer to get pixel the refracted ray hits.
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );

		#endif

		vec3 attenuatedColor = transmittance * transmittedLight.rgb;

		// Get the specular component.
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );

		// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job
		// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;

		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );

	}
#endif
`;

	var uv_pars_fragment = /* glsl */`
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;

#endif
#ifdef USE_MAP

	varying vec2 vMapUv;

#endif
#ifdef USE_ALPHAMAP

	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	varying vec2 vNormalMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_SPECULARMAP

	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`;

	var uv_pars_vertex = /* glsl */`
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`;

	var uv_vertex = /* glsl */`
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	vUv = vec3( uv, 1 ).xy;

#endif
#ifdef USE_MAP

	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ALPHAMAP

	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_LIGHTMAP

	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_AOMAP

	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_BUMPMAP

	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_NORMALMAP

	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_DISPLACEMENTMAP

	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_EMISSIVEMAP

	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_METALNESSMAP

	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ROUGHNESSMAP

	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ANISOTROPYMAP

	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOATMAP

	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_IRIDESCENCEMAP

	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SHEEN_COLORMAP

	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULARMAP

	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULAR_COLORMAP

	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_TRANSMISSIONMAP

	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_THICKNESSMAP

	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;

#endif
`;

	var worldpos_vertex = /* glsl */`
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_BATCHING

		worldPosition = batchingMatrix * worldPosition;

	#endif

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`;

	const vertex$h = /* glsl */`
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`;

	const fragment$h = /* glsl */`
uniform sampler2D t2D;
uniform float backgroundIntensity;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	#ifdef DECODE_VIDEO_TEXTURE

		// use inline sRGB decode until browsers properly support SRGB8_ALPHA8 with video textures

		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

	#endif

	texColor.rgb *= backgroundIntensity;

	gl_FragColor = texColor;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`;

	const vertex$g = /* glsl */`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`;

	const fragment$g = /* glsl */`

#ifdef ENVMAP_TYPE_CUBE

	uniform samplerCube envMap;

#elif defined( ENVMAP_TYPE_CUBE_UV )

	uniform sampler2D envMap;

#endif

uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	#ifdef ENVMAP_TYPE_CUBE

		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );

	#else

		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );

	#endif

	texColor.rgb *= backgroundIntensity;

	gl_FragColor = texColor;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`;

	const vertex$f = /* glsl */`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`;

	const fragment$f = /* glsl */`
uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;

varying vec3 vWorldDirection;

void main() {

	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );

	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`;

	const vertex$e = /* glsl */`
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <batching_vertex>
	#include <skinbase_vertex>

	#include <morphinstance_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`;

	const fragment$e = /* glsl */`
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z

	#ifdef USE_REVERSED_DEPTH_BUFFER

		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];

	#else

		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;

	#endif

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#elif DEPTH_PACKING == 3202

		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );

	#elif DEPTH_PACKING == 3203

		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );

	#endif

}
`;

	const vertex$d = /* glsl */`
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <batching_vertex>
	#include <skinbase_vertex>

	#include <morphinstance_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`;

	const fragment$d = /* glsl */`
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`;

	const vertex$c = /* glsl */`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`;

	const fragment$c = /* glsl */`
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	gl_FragColor = texture2D( tEquirect, sampleUV );

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`;

	const vertex$b = /* glsl */`
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;

	const fragment$b = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;

	const vertex$a = /* glsl */`
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`;

	const fragment$a = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	const vertex$9 = /* glsl */`
#define LAMBERT

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

	const fragment$9 = /* glsl */`
#define LAMBERT

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	const vertex$8 = /* glsl */`
#define MATCAP

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`;

	const fragment$8 = /* glsl */`
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );

	#else

		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 ); // default if matcap is missing

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	const vertex$7 = /* glsl */`
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )

	varying vec3 vViewPosition;

#endif

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )

	vViewPosition = - mvPosition.xyz;

#endif

}
`;

	const fragment$7 = /* glsl */`
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )

	varying vec3 vViewPosition;

#endif

#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );

	#ifdef OPAQUE

		gl_FragColor.a = 1.0;

	#endif

}
`;

	const vertex$6 = /* glsl */`
#define PHONG

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

	const fragment$6 = /* glsl */`
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	const vertex$5 = /* glsl */`
#define STANDARD

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

	varying vec3 vWorldPosition;

#endif

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

#ifdef USE_TRANSMISSION

	vWorldPosition = worldPosition.xyz;

#endif
}
`;

	const fragment$5 = /* glsl */`
#define STANDARD

#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
	uniform float ior;
#endif

#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;

	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif

	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif

#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_DISPERSION
	uniform float dispersion;
#endif

#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;

	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif

	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif

#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;

	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

	#include <transmission_fragment>

	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

	#ifdef USE_SHEEN

		// Sheen energy compensation approximation calculation can be found at the end of
		// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;

	#endif

	#ifdef USE_CLEARCOAT

		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );

		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;

	#endif

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	const vertex$4 = /* glsl */`
#define TOON

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

	const fragment$4 = /* glsl */`
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	const vertex$3 = /* glsl */`
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_POINTS_UV

	varying vec2 vUv;
	uniform mat3 uvTransform;

#endif

void main() {

	#ifdef USE_POINTS_UV

		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	#endif

	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`;

	const fragment$3 = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;

	const vertex$2 = /* glsl */`
#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

	const fragment$2 = /* glsl */`
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	#include <logdepthbuf_fragment>

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>

}
`;

	const vertex$1 = /* glsl */`
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix[ 3 ];

	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;

	const fragment$1 = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>

}
`;

	const ShaderChunk = {
		alphahash_fragment: alphahash_fragment,
		alphahash_pars_fragment: alphahash_pars_fragment,
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		alphatest_pars_fragment: alphatest_pars_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		batching_pars_vertex: batching_pars_vertex,
		batching_vertex: batching_vertex,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		iridescence_fragment: iridescence_fragment,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		colorspace_fragment: colorspace_fragment,
		colorspace_pars_fragment: colorspace_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_fragment: lights_lambert_fragment,
		lights_lambert_pars_fragment: lights_lambert_pars_fragment,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphinstance_vertex: morphinstance_vertex,
		morphcolor_vertex: morphcolor_vertex,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normal_pars_fragment: normal_pars_fragment,
		normal_pars_vertex: normal_pars_vertex,
		normal_vertex: normal_vertex,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		iridescence_pars_fragment: iridescence_pars_fragment,
		opaque_fragment: opaque_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		worldpos_vertex: worldpos_vertex,

		background_vert: vertex$h,
		background_frag: fragment$h,
		backgroundCube_vert: vertex$g,
		backgroundCube_frag: fragment$g,
		cube_vert: vertex$f,
		cube_frag: fragment$f,
		depth_vert: vertex$e,
		depth_frag: fragment$e,
		distanceRGBA_vert: vertex$d,
		distanceRGBA_frag: fragment$d,
		equirect_vert: vertex$c,
		equirect_frag: fragment$c,
		linedashed_vert: vertex$b,
		linedashed_frag: fragment$b,
		meshbasic_vert: vertex$a,
		meshbasic_frag: fragment$a,
		meshlambert_vert: vertex$9,
		meshlambert_frag: fragment$9,
		meshmatcap_vert: vertex$8,
		meshmatcap_frag: fragment$8,
		meshnormal_vert: vertex$7,
		meshnormal_frag: fragment$7,
		meshphong_vert: vertex$6,
		meshphong_frag: fragment$6,
		meshphysical_vert: vertex$5,
		meshphysical_frag: fragment$5,
		meshtoon_vert: vertex$4,
		meshtoon_frag: fragment$4,
		points_vert: vertex$3,
		points_frag: fragment$3,
		shadow_vert: vertex$2,
		shadow_frag: fragment$2,
		sprite_vert: vertex$1,
		sprite_frag: fragment$1
	};

	// Uniforms library for shared webgl shaders
	const UniformsLib = {

		common: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },

			map: { value: null },
			mapTransform: { value: /*@__PURE__*/ new Matrix3() },

			alphaMap: { value: null },
			alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },

			alphaTest: { value: 0 }

		},

		specularmap: {

			specularMap: { value: null },
			specularMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		envmap: {

			envMap: { value: null },
			envMapRotation: { value: /*@__PURE__*/ new Matrix3() },
			flipEnvMap: { value: -1 },
			reflectivity: { value: 1.0 }, // basic, lambert, phong
			ior: { value: 1.5 }, // physical
			refractionRatio: { value: 0.98 }, // basic, lambert, phong

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 },
			aoMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 },
			lightMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		emissivemap: {

			emissiveMap: { value: null },
			emissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		metalnessmap: {

			metalnessMap: { value: null },
			metalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		roughnessmap: {

			roughnessMap: { value: null },
			roughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {}
			} },

			directionalLightShadows: { value: [], properties: {
				shadowIntensity: 1,
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			} },

			spotLightShadows: { value: [], properties: {
				shadowIntensity: 1,
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotLightMap: { value: [] },
			spotShadowMap: { value: [] },
			spotLightMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			} },

			pointLightShadows: { value: [], properties: {
				shadowIntensity: 1,
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} },

			ltc_1: { value: null },
			ltc_2: { value: null }

		},

		points: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			alphaTest: { value: 0 },
			uvTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		sprite: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			mapTransform: { value: /*@__PURE__*/ new Matrix3() },
			alphaMap: { value: null },
			alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			alphaTest: { value: 0 }

		}

	};

	const ShaderLib = {

		basic: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
					specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 }
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		toon: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag

		},

		matcap: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag

		},

		sprite: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: /*@__PURE__*/ new Matrix3() },
				t2D: { value: null },
				backgroundIntensity: { value: 1 }
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},

		backgroundCube: {

			uniforms: {
				envMap: { value: null },
				flipEnvMap: { value: -1 },
				backgroundBlurriness: { value: 0 },
				backgroundIntensity: { value: 1 },
				backgroundRotation: { value: /*@__PURE__*/ new Matrix3() }
			},

			vertexShader: ShaderChunk.backgroundCube_vert,
			fragmentShader: ShaderChunk.backgroundCube_frag

		},

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: -1 },
				opacity: { value: 1.0 }
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: /*@__PURE__*/ new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				clearcoatNormalMap: { value: null },
				clearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				dispersion: { value: 0 },
				iridescence: { value: 0 },
				iridescenceMap: { value: null },
				iridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				iridescenceIOR: { value: 1.3 },
				iridescenceThicknessMinimum: { value: 100 },
				iridescenceThicknessMaximum: { value: 400 },
				iridescenceThicknessMap: { value: null },
				iridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				sheen: { value: 0 },
				sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				sheenColorMap: { value: null },
				sheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				sheenRoughness: { value: 1 },
				sheenRoughnessMap: { value: null },
				sheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				transmission: { value: 0 },
				transmissionMap: { value: null },
				transmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
				transmissionSamplerMap: { value: null },
				thickness: { value: 0 },
				thicknessMap: { value: null },
				thicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				attenuationDistance: { value: 0 },
				attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
				specularColorMap: { value: null },
				specularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				specularIntensity: { value: 1 },
				specularIntensityMap: { value: null },
				specularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				anisotropyVector: { value: /*@__PURE__*/ new Vector2() },
				anisotropyMap: { value: null },
				anisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	const _rgb = { r: 0, b: 0, g: 0 };
	const _e1$1 = /*@__PURE__*/ new Euler();
	const _m1$1 = /*@__PURE__*/ new Matrix4();

	function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

		const clearColor = new Color( 0x000000 );
		let clearAlpha = alpha === true ? 0 : 1;

		let planeMesh;
		let boxMesh;

		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function getBackground( scene ) {

			let background = scene.isScene === true ? scene.background : null;

			if ( background && background.isTexture ) {

				const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
				background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

			}

			return background;

		}

		function render( scene ) {

			let forceClear = false;
			const background = getBackground( scene );

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();

			if ( environmentBlendMode === 'additive' ) {

				state.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );

			} else if ( environmentBlendMode === 'alpha-blend' ) {

				state.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );

			}

			if ( renderer.autoClear || forceClear ) {

				// buffers might not be writable which is required to ensure a correct clear

				state.buffers.depth.setTest( true );
				state.buffers.depth.setMask( true );
				state.buffers.color.setMask( true );

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

		}

		function addToRenderList( renderList, scene ) {

			const background = getBackground( scene );

			if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
							vertexShader: ShaderLib.backgroundCube.vertexShader,
							fragmentShader: ShaderLib.backgroundCube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false,
							allowOverride: false
						} )
					);

					boxMesh.geometry.deleteAttribute( 'normal' );
					boxMesh.geometry.deleteAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// add "envMap" material property so the renderer can evaluate it like for built-in materials
					Object.defineProperty( boxMesh.material, 'envMap', {

						get: function () {

							return this.uniforms.envMap.value;

						}

					} );

					objects.update( boxMesh );

				}

				_e1$1.copy( scene.backgroundRotation );

				// accommodate left-handed frame
				_e1$1.x *= -1; _e1$1.y *= -1; _e1$1.z *= -1;

				if ( background.isCubeTexture && background.isRenderTargetTexture === false ) {

					// environment maps which are not cube render targets or PMREMs follow a different convention
					_e1$1.y *= -1;
					_e1$1.z *= -1;

				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? -1 : 1;
				boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
				boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
				boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1$1.makeRotationFromEuler( _e1$1 ) );
				boxMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				boxMesh.layers.enableAll();

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneGeometry( 2, 2 ),
						new ShaderMaterial( {
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false,
							allowOverride: false
						} )
					);

					planeMesh.geometry.deleteAttribute( 'normal' );

					// add "map" material property so the renderer can evaluate it like for built-in materials
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;
				planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
				planeMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				planeMesh.layers.enableAll();

				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

			state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

		}

		function dispose() {

			if ( boxMesh !== undefined ) {

				boxMesh.geometry.dispose();
				boxMesh.material.dispose();

				boxMesh = undefined;

			}

			if ( planeMesh !== undefined ) {

				planeMesh.geometry.dispose();
				planeMesh.material.dispose();

				planeMesh = undefined;

			}

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha = 1 ) {

				clearColor.set( color );
				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render,
			addToRenderList: addToRenderList,
			dispose: dispose

		};

	}

	function WebGLBindingStates( gl, attributes ) {

		const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

		const bindingStates = {};

		const defaultState = createBindingState( null );
		let currentState = defaultState;
		let forceUpdate = false;

		function setup( object, material, program, geometry, index ) {

			let updateBuffers = false;

			const state = getBindingState( geometry, program, material );

			if ( currentState !== state ) {

				currentState = state;
				bindVertexArrayObject( currentState.object );

			}

			updateBuffers = needsUpdate( object, geometry, program, index );

			if ( updateBuffers ) saveCache( object, geometry, program, index );

			if ( index !== null ) {

				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			if ( updateBuffers || forceUpdate ) {

				forceUpdate = false;

				setupVertexAttributes( object, material, program, geometry );

				if ( index !== null ) {

					gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

				}

			}

		}

		function createVertexArrayObject() {

			return gl.createVertexArray();

		}

		function bindVertexArrayObject( vao ) {

			return gl.bindVertexArray( vao );

		}

		function deleteVertexArrayObject( vao ) {

			return gl.deleteVertexArray( vao );

		}

		function getBindingState( geometry, program, material ) {

			const wireframe = ( material.wireframe === true );

			let programMap = bindingStates[ geometry.id ];

			if ( programMap === undefined ) {

				programMap = {};
				bindingStates[ geometry.id ] = programMap;

			}

			let stateMap = programMap[ program.id ];

			if ( stateMap === undefined ) {

				stateMap = {};
				programMap[ program.id ] = stateMap;

			}

			let state = stateMap[ wireframe ];

			if ( state === undefined ) {

				state = createBindingState( createVertexArrayObject() );
				stateMap[ wireframe ] = state;

			}

			return state;

		}

		function createBindingState( vao ) {

			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for ( let i = 0; i < maxVertexAttributes; i ++ ) {

				newAttributes[ i ] = 0;
				enabledAttributes[ i ] = 0;
				attributeDivisors[ i ] = 0;

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			};

		}

		function needsUpdate( object, geometry, program, index ) {

			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;

			let attributesNum = 0;

			const programAttributes = program.getAttributes();

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					const cachedAttribute = cachedAttributes[ name ];
					let geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

					}

					if ( cachedAttribute === undefined ) return true;

					if ( cachedAttribute.attribute !== geometryAttribute ) return true;

					if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

					attributesNum ++;

				}

			}

			if ( currentState.attributesNum !== attributesNum ) return true;

			if ( currentState.index !== index ) return true;

			return false;

		}

		function saveCache( object, geometry, program, index ) {

			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			const programAttributes = program.getAttributes();

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					let attribute = attributes[ name ];

					if ( attribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

					}

					const data = {};
					data.attribute = attribute;

					if ( attribute && attribute.data ) {

						data.data = attribute.data;

					}

					cache[ name ] = data;

					attributesNum ++;

				}

			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;

			currentState.index = index;

		}

		function initAttributes() {

			const newAttributes = currentState.newAttributes;

			for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				gl.vertexAttribDivisor( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {

			if ( integer === true ) {

				gl.vertexAttribIPointer( index, size, type, stride, offset );

			} else {

				gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

			}

		}

		function setupVertexAttributes( object, material, program, geometry ) {

			initAttributes();

			const geometryAttributes = geometry.attributes;

			const programAttributes = program.getAttributes();

			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					let geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

					}

					if ( geometryAttribute !== undefined ) {

						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;

						const attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						// check for integer attributes

						const integer = ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType );

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if ( data.isInstancedInterleavedBuffer ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									stride * bytesPerElement,
									( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,
									integer
								);

							}

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									size * bytesPerElement,
									( size / programAttribute.locationSize ) * i * bytesPerElement,
									integer
								);

							}

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						const value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									gl.vertexAttrib2fv( programAttribute.location, value );
									break;

								case 3:
									gl.vertexAttrib3fv( programAttribute.location, value );
									break;

								case 4:
									gl.vertexAttrib4fv( programAttribute.location, value );
									break;

								default:
									gl.vertexAttrib1fv( programAttribute.location, value );

							}

						}

					}

				}

			}

			disableUnusedAttributes();

		}

		function dispose() {

			reset();

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				for ( const programId in programMap ) {

					const stateMap = programMap[ programId ];

					for ( const wireframe in stateMap ) {

						deleteVertexArrayObject( stateMap[ wireframe ].object );

						delete stateMap[ wireframe ];

					}

					delete programMap[ programId ];

				}

				delete bindingStates[ geometryId ];

			}

		}

		function releaseStatesOfGeometry( geometry ) {

			if ( bindingStates[ geometry.id ] === undefined ) return;

			const programMap = bindingStates[ geometry.id ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometry.id ];

		}

		function releaseStatesOfProgram( program ) {

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				if ( programMap[ program.id ] === undefined ) continue;

				const stateMap = programMap[ program.id ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ program.id ];

			}

		}

		function reset() {

			resetDefaultState();
			forceUpdate = true;

			if ( currentState === defaultState ) return;

			currentState = defaultState;
			bindVertexArrayObject( currentState.object );

		}

		// for backward-compatibility

		function resetDefaultState() {

			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		};

	}

	function WebGLBufferRenderer( gl, extensions, info ) {

		let mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			gl.drawArraysInstanced( mode, start, count, primcount );

			info.update( count, mode, primcount );

		}

		function renderMultiDraw( starts, counts, drawCount ) {

			if ( drawCount === 0 ) return;

			const extension = extensions.get( 'WEBGL_multi_draw' );
			extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			info.update( elementCount, mode, 1 );

		}

		function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

			if ( drawCount === 0 ) return;

			const extension = extensions.get( 'WEBGL_multi_draw' );

			if ( extension === null ) {

				for ( let i = 0; i < starts.length; i ++ ) {

					renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

				}

			} else {

				extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

				let elementCount = 0;
				for ( let i = 0; i < drawCount; i ++ ) {

					elementCount += counts[ i ] * primcount[ i ];

				}

				info.update( elementCount, mode, 1 );

			}

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
		this.renderMultiDraw = renderMultiDraw;
		this.renderMultiDrawInstances = renderMultiDrawInstances;

	}

	function WebGLCapabilities( gl, extensions, parameters, utils ) {

		let maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function textureFormatReadable( textureFormat ) {

			if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

				return false;

			}

			return true;

		}

		function textureTypeReadable( textureType ) {

			const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) );

			if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)
				textureType !== FloatType && ! halfFloatSupportedByExt ) {

				return false;

			}

			return true;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			warn( 'WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
		const reversedDepthBuffer = parameters.reversedDepthBuffer === true && extensions.has( 'EXT_clip_control' );

		const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		const vertexTextures = maxVertexTextures > 0;

		const maxSamples = gl.getParameter( gl.MAX_SAMPLES );

		return {

			isWebGL2: true, // keeping this for backwards compatibility

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			textureFormatReadable: textureFormatReadable,
			textureTypeReadable: textureTypeReadable,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			reversedDepthBuffer: reversedDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,

			maxSamples: maxSamples

		};

	}

	function WebGLClipping( properties ) {

		const scope = this;

		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false;

		const plane = new Plane$1(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping ) {

			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;

		};

		this.setGlobalState = function ( planes, camera ) {

			globalState = projectPlanes( planes, camera, 0 );

		};

		this.setState = function ( material, camera, useCache ) {

			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows;

			const materialProperties = properties.get( material );

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4;

				let dstArray = materialProperties.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, useCache );

				for ( let i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;

			return dstArray;

		}

	}

	let _canvas;

	/**
	 * A class containing utility functions for images.
	 *
	 * @hideconstructor
	 */
	class ImageUtils {

		/**
		 * Returns a data URI containing a representation of the given image.
		 *
		 * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
		 * @param {string} [type='image/png'] - Indicates the image format.
		 * @return {string} The data URI.
		 */
		static getDataURL( image, type = 'image/png' ) {

			if ( /^data:/i.test( image.src ) ) {

				return image.src;

			}

			if ( typeof HTMLCanvasElement === 'undefined' ) {

				return image.src;

			}

			let canvas;

			if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			return canvas.toDataURL( type );

		}

		/**
		 * Converts the given sRGB image data to linear color space.
		 *
		 * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
		 * @return {HTMLCanvasElement|Object} The converted image.
		 */
		static sRGBToLinear( image ) {

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const canvas = createElementNS( 'canvas' );

				canvas.width = image.width;
				canvas.height = image.height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height );

				const imageData = context.getImageData( 0, 0, image.width, image.height );
				const data = imageData.data;

				for ( let i = 0; i < data.length; i ++ ) {

					data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

				}

				context.putImageData( imageData, 0, 0 );

				return canvas;

			} else if ( image.data ) {

				const data = image.data.slice( 0 );

				for ( let i = 0; i < data.length; i ++ ) {

					if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

						data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

					} else {

						// assuming float

						data[ i ] = SRGBToLinear( data[ i ] );

					}

				}

				return {
					data: data,
					width: image.width,
					height: image.height
				};

			} else {

				warn( 'ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
				return image;

			}

		}

	}

	let _sourceId = 0;

	/**
	 * Represents the data source of a texture.
	 *
	 * The main purpose of this class is to decouple the data definition from the texture
	 * definition so the same data can be used with multiple texture instances.
	 */
	class Source {

		/**
		 * Constructs a new video texture.
		 *
		 * @param {any} [data=null] - The data definition of a texture.
		 */
		constructor( data = null ) {

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isSource = true;

			/**
			 * The ID of the source.
			 *
			 * @name Source#id
			 * @type {number}
			 * @readonly
			 */
			Object.defineProperty( this, 'id', { value: _sourceId ++ } );

			/**
			 * The UUID of the source.
			 *
			 * @type {string}
			 * @readonly
			 */
			this.uuid = generateUUID();

			/**
			 * The data definition of a texture.
			 *
			 * @type {any}
			 */
			this.data = data;

			/**
			 * This property is only relevant when {@link Source#needsUpdate} is set to `true` and
			 * provides more control on how texture data should be processed. When `dataReady` is set
			 * to `false`, the engine performs the memory allocation (if necessary) but does not transfer
			 * the data into the GPU memory.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.dataReady = true;

			/**
			 * This starts at `0` and counts how many times {@link Source#needsUpdate} is set to `true`.
			 *
			 * @type {number}
			 * @readonly
			 * @default 0
			 */
			this.version = 0;

		}

		/**
		 * Returns the dimensions of the source into the given target vector.
		 *
		 * @param {(Vector2|Vector3)} target - The target object the result is written into.
		 * @return {(Vector2|Vector3)} The dimensions of the source.
		 */
		getSize( target ) {

			const data = this.data;

			if ( ( typeof HTMLVideoElement !== 'undefined' ) && ( data instanceof HTMLVideoElement ) ) {

				target.set( data.videoWidth, data.videoHeight, 0 );

			} else if ( data instanceof VideoFrame ) {

				target.set( data.displayHeight, data.displayWidth, 0 );

			} else if ( data !== null ) {

				target.set( data.width, data.height, data.depth || 0 );

			} else {

				target.set( 0, 0, 0 );

			}

			return target;

		}

		/**
		 * When the property is set to `true`, the engine allocates the memory
		 * for the texture (if necessary) and triggers the actual texture upload
		 * to the GPU next time the source is used.
		 *
		 * @type {boolean}
		 * @default false
		 * @param {boolean} value
		 */
		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		/**
		 * Serializes the source into JSON.
		 *
		 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
		 * @return {Object} A JSON object representing the serialized source.
		 * @see {@link ObjectLoader#parse}
		 */
		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

				return meta.images[ this.uuid ];

			}

			const output = {
				uuid: this.uuid,
				url: ''
			};

			const data = this.data;

			if ( data !== null ) {

				let url;

				if ( Array.isArray( data ) ) {

					// cube texture

					url = [];

					for ( let i = 0, l = data.length; i < l; i ++ ) {

						if ( data[ i ].isDataTexture ) {

							url.push( serializeImage( data[ i ].image ) );

						} else {

							url.push( serializeImage( data[ i ] ) );

						}

					}

				} else {

					// texture

					url = serializeImage( data );

				}

				output.url = url;

			}

			if ( ! isRootObject ) {

				meta.images[ this.uuid ] = output;

			}

			return output;

		}

	}

	function serializeImage( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			// default images

			return ImageUtils.getDataURL( image );

		} else {

			if ( image.data ) {

				// images of DataTexture

				return {
					data: Array.from( image.data ),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};

			} else {

				warn( 'Texture: Unable to serialize Texture.' );
				return {};

			}

		}

	}

	let _textureId = 0;

	const _tempVec3 = /*@__PURE__*/ new Vector3();

	/**
	 * Base class for all textures.
	 *
	 * Note: After the initial use of a texture, its dimensions, format, and type
	 * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.
	 *
	 * @augments EventDispatcher
	 */
	class Texture extends EventDispatcher {

		/**
		 * Constructs a new texture.
		 *
		 * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
		 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
		 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
		 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
		 * @param {number} [magFilter=LinearFilter] - The mag filter value.
		 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
		 * @param {number} [format=RGBAFormat] - The texture format.
		 * @param {number} [type=UnsignedByteType] - The texture type.
		 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
		 * @param {string} [colorSpace=NoColorSpace] - The color space.
		 */
		constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isTexture = true;

			/**
			 * The ID of the texture.
			 *
			 * @name Texture#id
			 * @type {number}
			 * @readonly
			 */
			Object.defineProperty( this, 'id', { value: _textureId ++ } );

			/**
			 * The UUID of the material.
			 *
			 * @type {string}
			 * @readonly
			 */
			this.uuid = generateUUID();

			/**
			 * The name of the material.
			 *
			 * @type {string}
			 */
			this.name = '';

			/**
			 * The data definition of a texture. A reference to the data source can be
			 * shared across textures. This is often useful in context of spritesheets
			 * where multiple textures render the same data but with different texture
			 * transformations.
			 *
			 * @type {Source}
			 */
			this.source = new Source( image );

			/**
			 * An array holding user-defined mipmaps.
			 *
			 * @type {Array<Object>}
			 */
			this.mipmaps = [];

			/**
			 * How the texture is applied to the object. The value `UVMapping`
			 * is the default, where texture or uv coordinates are used to apply the map.
			 *
			 * @type {(UVMapping|CubeReflectionMapping|CubeRefractionMapping|EquirectangularReflectionMapping|EquirectangularRefractionMapping|CubeUVReflectionMapping)}
			 * @default UVMapping
			*/
			this.mapping = mapping;

			/**
			 * Lets you select the uv attribute to map the texture to. `0` for `uv`,
			 * `1` for `uv1`, `2` for `uv2` and `3` for `uv3`.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.channel = 0;

			/**
			 * This defines how the texture is wrapped horizontally and corresponds to
			 * *U* in UV mapping.
			 *
			 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
			 * @default ClampToEdgeWrapping
			 */
			this.wrapS = wrapS;

			/**
			 * This defines how the texture is wrapped horizontally and corresponds to
			 * *V* in UV mapping.
			 *
			 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
			 * @default ClampToEdgeWrapping
			 */
			this.wrapT = wrapT;

			/**
			 * How the texture is sampled when a texel covers more than one pixel.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default LinearFilter
			 */
			this.magFilter = magFilter;

			/**
			 * How the texture is sampled when a texel covers less than one pixel.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default LinearMipmapLinearFilter
			 */
			this.minFilter = minFilter;

			/**
			 * The number of samples taken along the axis through the pixel that has the
			 * highest density of texels. By default, this value is `1`. A higher value
			 * gives a less blurry result than a basic mipmap, at the cost of more
			 * texture samples being used.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.anisotropy = anisotropy;

			/**
			 * The format of the texture.
			 *
			 * @type {number}
			 * @default RGBAFormat
			 */
			this.format = format;

			/**
			 * The default internal format is derived from {@link Texture#format} and {@link Texture#type} and
			 * defines how the texture data is going to be stored on the GPU.
			 *
			 * This property allows to overwrite the default format.
			 *
			 * @type {?string}
			 * @default null
			 */
			this.internalFormat = null;

			/**
			 * The data type of the texture.
			 *
			 * @type {number}
			 * @default UnsignedByteType
			 */
			this.type = type;

			/**
			 * How much a single repetition of the texture is offset from the beginning,
			 * in each direction U and V. Typical range is `0.0` to `1.0`.
			 *
			 * @type {Vector2}
			 * @default (0,0)
			 */
			this.offset = new Vector2( 0, 0 );

			/**
			 * How many times the texture is repeated across the surface, in each
			 * direction U and V. If repeat is set greater than `1` in either direction,
			 * the corresponding wrap parameter should also be set to `RepeatWrapping`
			 * or `MirroredRepeatWrapping` to achieve the desired tiling effect.
			 *
			 * @type {Vector2}
			 * @default (1,1)
			 */
			this.repeat = new Vector2( 1, 1 );

			/**
			 * The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds
			 * to the center of the texture. Default is `(0, 0)`, the lower left.
			 *
			 * @type {Vector2}
			 * @default (0,0)
			 */
			this.center = new Vector2( 0, 0 );

			/**
			 * How much the texture is rotated around the center point, in radians.
			 * Positive values are counter-clockwise.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.rotation = 0;

			/**
			 * Whether to update the texture's uv-transformation {@link Texture#matrix}
			 * from the properties {@link Texture#offset}, {@link Texture#repeat},
			 * {@link Texture#rotation}, and {@link Texture#center}.
			 *
			 * Set this to `false` if you are specifying the uv-transform matrix directly.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.matrixAutoUpdate = true;

			/**
			 * The uv-transformation matrix of the texture.
			 *
			 * @type {Matrix3}
			 */
			this.matrix = new Matrix3();

			/**
			 * Whether to generate mipmaps (if possible) for a texture.
			 *
			 * Set this to `false` if you are creating mipmaps manually.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.generateMipmaps = true;

			/**
			 * If set to `true`, the alpha channel, if present, is multiplied into the
			 * color channels when the texture is uploaded to the GPU.
			 *
			 * Note that this property has no effect when using `ImageBitmap`. You need to
			 * configure premultiply alpha on bitmap creation instead.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.premultiplyAlpha = false;

			/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Note that this property has no effect when using `ImageBitmap`. You need to
			 * configure the flip on bitmap creation instead.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.flipY = true;

			/**
			 * Specifies the alignment requirements for the start of each pixel row in memory.
			 * The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),
			 * `4` (word-alignment), and `8` (rows start on double-word boundaries).
			 *
			 * @type {number}
			 * @default 4
			 */
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

			/**
			 * Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.
			 *
			 * @type {string}
			 * @default NoColorSpace
			 */
			this.colorSpace = colorSpace;

			/**
			 * An object that can be used to store custom data about the texture. It
			 * should not hold references to functions as these will not be cloned.
			 *
			 * @type {Object}
			 */
			this.userData = {};

			/**
			 * This can be used to only update a subregion or specific rows of the texture (for example, just the
			 * first 3 rows). Use the `addUpdateRange()` function to add ranges to this array.
			 *
			 * @type {Array<Object>}
			 */
			this.updateRanges = [];

			/**
			 * This starts at `0` and counts how many times {@link Texture#needsUpdate} is set to `true`.
			 *
			 * @type {number}
			 * @readonly
			 * @default 0
			 */
			this.version = 0;

			/**
			 * A callback function, called when the texture is updated (e.g., when
			 * {@link Texture#needsUpdate} has been set to true and then the texture is used).
			 *
			 * @type {?Function}
			 * @default null
			 */
			this.onUpdate = null;

			/**
			 * An optional back reference to the textures render target.
			 *
			 * @type {?(RenderTarget|WebGLRenderTarget)}
			 * @default null
			 */
			this.renderTarget = null;

			/**
			 * Indicates whether a texture belongs to a render target or not.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default false
			 */
			this.isRenderTargetTexture = false;

			/**
			 * Indicates if a texture should be handled like a texture array.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default false
			 */
			this.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;

			/**
			 * Indicates whether this texture should be processed by `PMREMGenerator` or not
			 * (only relevant for render target textures).
			 *
			 * @type {number}
			 * @readonly
			 * @default 0
			 */
			this.pmremVersion = 0;

		}

		/**
		 * The width of the texture in pixels.
		 */
		get width() {

			return this.source.getSize( _tempVec3 ).x;

		}

		/**
		 * The height of the texture in pixels.
		 */
		get height() {

			return this.source.getSize( _tempVec3 ).y;

		}

		/**
		 * The depth of the texture in pixels.
		 */
		get depth() {

			return this.source.getSize( _tempVec3 ).z;

		}

		/**
		 * The image object holding the texture data.
		 *
		 * @type {?Object}
		 */
		get image() {

			return this.source.data;

		}

		set image( value = null ) {

			this.source.data = value;

		}

		/**
		 * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
		 * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
		 */
		updateMatrix() {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		}

		/**
		 * Adds a range of data in the data texture to be updated on the GPU.
		 *
		 * @param {number} start - Position at which to start update.
		 * @param {number} count - The number of components to update.
		 */
		addUpdateRange( start, count ) {

			this.updateRanges.push( { start, count } );

		}

		/**
		 * Clears the update ranges.
		 */
		clearUpdateRanges() {

			this.updateRanges.length = 0;

		}

		/**
		 * Returns a new texture with copied values from this instance.
		 *
		 * @return {Texture} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

		/**
		 * Copies the values of the given texture to this instance.
		 *
		 * @param {Texture} source - The texture to copy.
		 * @return {Texture} A reference to this instance.
		 */
		copy( source ) {

			this.name = source.name;

			this.source = source.source;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;
			this.channel = source.channel;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.colorSpace = source.colorSpace;

			this.renderTarget = source.renderTarget;
			this.isRenderTargetTexture = source.isRenderTargetTexture;
			this.isArrayTexture = source.isArrayTexture;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.needsUpdate = true;

			return this;

		}

		/**
		 * Sets this texture's properties based on `values`.
		 * @param {Object} values - A container with texture parameters.
		 */
		setValues( values ) {

			for ( const key in values ) {

				const newValue = values[ key ];

				if ( newValue === undefined ) {

					warn( `Texture.setValues(): parameter '${ key }' has value of undefined.` );
					continue;

				}

				const currentValue = this[ key ];

				if ( currentValue === undefined ) {

					warn( `Texture.setValues(): property '${ key }' does not exist.` );
					continue;

				}

				if ( ( currentValue && newValue ) && ( currentValue.isVector2 && newValue.isVector2 ) ) {

					currentValue.copy( newValue );

				} else if ( ( currentValue && newValue ) && ( currentValue.isVector3 && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else if ( ( currentValue && newValue ) && ( currentValue.isMatrix3 && newValue.isMatrix3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

		/**
		 * Serializes the texture into JSON.
		 *
		 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
		 * @return {Object} A JSON object representing the serialized texture.
		 * @see {@link ObjectLoader#parse}
		 */
		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			const output = {

				metadata: {
					version: 4.7,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				image: this.source.toJSON( meta ).uuid,

				mapping: this.mapping,
				channel: this.channel,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				internalFormat: this.internalFormat,
				type: this.type,
				colorSpace: this.colorSpace,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				generateMipmaps: this.generateMipmaps,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		}

		/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 *
		 * @fires Texture#dispose
		 */
		dispose() {

			/**
			 * Fires when the texture has been disposed of.
			 *
			 * @event Texture#dispose
			 * @type {Object}
			 */
			this.dispatchEvent( { type: 'dispose' } );

		}

		/**
		 * Transforms the given uv vector with the textures uv transformation matrix.
		 *
		 * @param {Vector2} uv - The uv vector.
		 * @return {Vector2} The transformed uv vector.
		 */
		transformUv( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}

						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}

						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

		/**
		 * Setting this property to `true` indicates the engine the texture
		 * must be updated in the next render. This triggers a texture upload
		 * to the GPU and ensures correct texture parameter configuration.
		 *
		 * @type {boolean}
		 * @default false
		 * @param {boolean} value
		 */
		set needsUpdate( value ) {

			if ( value === true ) {

				this.version ++;
				this.source.needsUpdate = true;

			}

		}

		/**
		 * Setting this property to `true` indicates the engine the PMREM
		 * must be regenerated.
		 *
		 * @type {boolean}
		 * @default false
		 * @param {boolean} value
		 */
		set needsPMREMUpdate( value ) {

			if ( value === true ) {

				this.pmremVersion ++;

			}

		}

	}

	/**
	 * The default image for all textures.
	 *
	 * @static
	 * @type {?Image}
	 * @default null
	 */
	Texture.DEFAULT_IMAGE = null;

	/**
	 * The default mapping for all textures.
	 *
	 * @static
	 * @type {number}
	 * @default UVMapping
	 */
	Texture.DEFAULT_MAPPING = UVMapping;

	/**
	 * The default anisotropy value for all textures.
	 *
	 * @static
	 * @type {number}
	 * @default 1
	 */
	Texture.DEFAULT_ANISOTROPY = 1;

	/**
	 * A render target is a buffer where the video card draws pixels for a scene
	 * that is being rendered in the background. It is used in different effects,
	 * such as applying postprocessing to a rendered image before displaying it
	 * on the screen.
	 *
	 * @augments EventDispatcher
	 */
	class RenderTarget extends EventDispatcher {

		/**
		 * Render target options.
		 *
		 * @typedef {Object} RenderTarget~Options
		 * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
		 * @property {number} [magFilter=LinearFilter] - The mag filter.
		 * @property {number} [minFilter=LinearFilter] - The min filter.
		 * @property {number} [format=RGBAFormat] - The texture format.
		 * @property {number} [type=UnsignedByteType] - The texture type.
		 * @property {?string} [internalFormat=null] - The texture's internal format.
		 * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
		 * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
		 * @property {number} [anisotropy=1] - The texture's anisotropy value.
		 * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
		 * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
		 * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
		 * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
		 * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
		 * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
		 * @property {number} [samples=0] - The MSAA samples count.
		 * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
		 * @property {number} [depth=1] - The texture depth.
		 * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
		 */

		/**
		 * Constructs a new render target.
		 *
		 * @param {number} [width=1] - The width of the render target.
		 * @param {number} [height=1] - The height of the render target.
		 * @param {RenderTarget~Options} [options] - The configuration object.
		 */
		constructor( width = 1, height = 1, options = {} ) {

			super();

			options = Object.assign( {
				generateMipmaps: false,
				internalFormat: null,
				minFilter: LinearFilter,
				depthBuffer: true,
				stencilBuffer: false,
				resolveDepthBuffer: true,
				resolveStencilBuffer: true,
				depthTexture: null,
				samples: 0,
				count: 1,
				depth: 1,
				multiview: false
			}, options );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isRenderTarget = true;

			/**
			 * The width of the render target.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.width = width;

			/**
			 * The height of the render target.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.height = height;

			/**
			 * The depth of the render target.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.depth = options.depth;

			/**
			 * A rectangular area inside the render target's viewport. Fragments that are
			 * outside the area will be discarded.
			 *
			 * @type {Vector4}
			 * @default (0,0,width,height)
			 */
			this.scissor = new Vector4( 0, 0, width, height );

			/**
			 * Indicates whether the scissor test should be enabled when rendering into
			 * this render target or not.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.scissorTest = false;

			/**
			 * A rectangular area representing the render target's viewport.
			 *
			 * @type {Vector4}
			 * @default (0,0,width,height)
			 */
			this.viewport = new Vector4( 0, 0, width, height );

			const image = { width: width, height: height, depth: options.depth };

			const texture = new Texture( image );

			/**
			 * An array of textures. Each color attachment is represented as a separate texture.
			 * Has at least a single entry for the default color attachment.
			 *
			 * @type {Array<Texture>}
			 */
			this.textures = [];

			const count = options.count;
			for ( let i = 0; i < count; i ++ ) {

				this.textures[ i ] = texture.clone();
				this.textures[ i ].isRenderTargetTexture = true;
				this.textures[ i ].renderTarget = this;

			}

			this._setTextureOptions( options );

			/**
			 * Whether to allocate a depth buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.depthBuffer = options.depthBuffer;

			/**
			 * Whether to allocate a stencil buffer or not.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.stencilBuffer = options.stencilBuffer;

			/**
			 * Whether to resolve the depth buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.resolveDepthBuffer = options.resolveDepthBuffer;

			/**
			 * Whether to resolve the stencil buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.resolveStencilBuffer = options.resolveStencilBuffer;

			this._depthTexture = null;
			this.depthTexture = options.depthTexture;

			/**
			 * The number of MSAA samples.
			 *
			 * A value of `0` disables MSAA.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.samples = options.samples;

			/**
			 * Whether to this target is used in multiview rendering.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.multiview = options.multiview;

		}

		_setTextureOptions( options = {} ) {

			const values = {
				minFilter: LinearFilter,
				generateMipmaps: false,
				flipY: false,
				internalFormat: null
			};

			if ( options.mapping !== undefined ) values.mapping = options.mapping;
			if ( options.wrapS !== undefined ) values.wrapS = options.wrapS;
			if ( options.wrapT !== undefined ) values.wrapT = options.wrapT;
			if ( options.wrapR !== undefined ) values.wrapR = options.wrapR;
			if ( options.magFilter !== undefined ) values.magFilter = options.magFilter;
			if ( options.minFilter !== undefined ) values.minFilter = options.minFilter;
			if ( options.format !== undefined ) values.format = options.format;
			if ( options.type !== undefined ) values.type = options.type;
			if ( options.anisotropy !== undefined ) values.anisotropy = options.anisotropy;
			if ( options.colorSpace !== undefined ) values.colorSpace = options.colorSpace;
			if ( options.flipY !== undefined ) values.flipY = options.flipY;
			if ( options.generateMipmaps !== undefined ) values.generateMipmaps = options.generateMipmaps;
			if ( options.internalFormat !== undefined ) values.internalFormat = options.internalFormat;

			for ( let i = 0; i < this.textures.length; i ++ ) {

				const texture = this.textures[ i ];
				texture.setValues( values );

			}

		}

		/**
		 * The texture representing the default color attachment.
		 *
		 * @type {Texture}
		 */
		get texture() {

			return this.textures[ 0 ];

		}

		set texture( value ) {

			this.textures[ 0 ] = value;

		}

		set depthTexture( current ) {

			if ( this._depthTexture !== null ) this._depthTexture.renderTarget = null;
			if ( current !== null ) current.renderTarget = this;

			this._depthTexture = current;

		}

		/**
		 * Instead of saving the depth in a renderbuffer, a texture
		 * can be used instead which is useful for further processing
		 * e.g. in context of post-processing.
		 *
		 * @type {?DepthTexture}
		 * @default null
		 */
		get depthTexture() {

			return this._depthTexture;

		}

		/**
		 * Sets the size of this render target.
		 *
		 * @param {number} width - The width.
		 * @param {number} height - The height.
		 * @param {number} [depth=1] - The depth.
		 */
		setSize( width, height, depth = 1 ) {

			if ( this.width !== width || this.height !== height || this.depth !== depth ) {

				this.width = width;
				this.height = height;
				this.depth = depth;

				for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

					this.textures[ i ].image.width = width;
					this.textures[ i ].image.height = height;
					this.textures[ i ].image.depth = depth;

					if ( this.textures[ i ].isData3DTexture !== true ) { // Fix for #31693

						// TODO: Reconsider setting isArrayTexture flag here and in the ctor of Texture.
						// Maybe a method `isArrayTexture()` or just a getter could replace a flag since
						// both are evaluated on each call?

						this.textures[ i ].isArrayTexture = this.textures[ i ].image.depth > 1;

					}

				}

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		}

		/**
		 * Returns a new render target with copied values from this instance.
		 *
		 * @return {RenderTarget} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

		/**
		 * Copies the settings of the given render target. This is a structural copy so
		 * no resources are shared between render targets after the copy. That includes
		 * all MRT textures and the depth texture.
		 *
		 * @param {RenderTarget} source - The render target to copy.
		 * @return {RenderTarget} A reference to this instance.
		 */
		copy( source ) {

			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;

			this.scissor.copy( source.scissor );
			this.scissorTest = source.scissorTest;

			this.viewport.copy( source.viewport );

			this.textures.length = 0;

			for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

				this.textures[ i ] = source.textures[ i ].clone();
				this.textures[ i ].isRenderTargetTexture = true;
				this.textures[ i ].renderTarget = this;

				// ensure image object is not shared, see #20328

				const image = Object.assign( {}, source.textures[ i ].image );
				this.textures[ i ].source = new Source( image );

			}

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;

			this.resolveDepthBuffer = source.resolveDepthBuffer;
			this.resolveStencilBuffer = source.resolveStencilBuffer;

			if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

			this.samples = source.samples;

			return this;

		}

		/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 *
		 * @fires RenderTarget#dispose
		 */
		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	/**
	 * A render target used in context of {@link WebGLRenderer}.
	 *
	 * @augments RenderTarget
	 */
	class WebGLRenderTarget extends RenderTarget {

		/**
		 * Constructs a new 3D render target.
		 *
		 * @param {number} [width=1] - The width of the render target.
		 * @param {number} [height=1] - The height of the render target.
		 * @param {RenderTarget~Options} [options] - The configuration object.
		 */
		constructor( width = 1, height = 1, options = {} ) {

			super( width, height, options );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isWebGLRenderTarget = true;

		}

	}

	/**
	 * Abstract base class for cameras. This class should always be inherited
	 * when you build a new camera.
	 *
	 * @abstract
	 * @augments Object3D
	 */
	class Camera extends Object3D {

		/**
		 * Constructs a new camera.
		 */
		constructor() {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isCamera = true;

			this.type = 'Camera';

			/**
			 * The inverse of the camera's world matrix.
			 *
			 * @type {Matrix4}
			 */
			this.matrixWorldInverse = new Matrix4();

			/**
			 * The camera's projection matrix.
			 *
			 * @type {Matrix4}
			 */
			this.projectionMatrix = new Matrix4();

			/**
			 * The inverse of the camera's projection matrix.
			 *
			 * @type {Matrix4}
			 */
			this.projectionMatrixInverse = new Matrix4();

			/**
			 * The coordinate system in which the camera is used.
			 *
			 * @type {(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
			 */
			this.coordinateSystem = WebGLCoordinateSystem;

			this._reversedDepth = false;

		}

		/**
		 * The flag that indicates whether the camera uses a reversed depth buffer.
		 *
		 * @type {boolean}
		 * @default false
		 */
		get reversedDepth() {

			return this._reversedDepth;

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			this.coordinateSystem = source.coordinateSystem;

			return this;

		}

		/**
		 * Returns a vector representing the ("look") direction of the 3D object in world space.
		 *
		 * This method is overwritten since cameras have a different forward vector compared to other
		 * 3D objects. A camera looks down its local, negative z-axis by default.
		 *
		 * @param {Vector3} target - The target vector the result is stored to.
		 * @return {Vector3} The 3D object's direction in world space.
		 */
		getWorldDirection( target ) {

			return super.getWorldDirection( target ).negate();

		}

		updateMatrixWorld( force ) {

			super.updateMatrixWorld( force );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		updateWorldMatrix( updateParents, updateChildren ) {

			super.updateWorldMatrix( updateParents, updateChildren );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _v3 = /*@__PURE__*/ new Vector3();
	const _minTarget = /*@__PURE__*/ new Vector2();
	const _maxTarget = /*@__PURE__*/ new Vector2();

	/**
	 * Camera that uses [perspective projection]{@link https://en.wikipedia.org/wiki/Perspective_(graphical)}.
	 *
	 * This projection mode is designed to mimic the way the human eye sees. It
	 * is the most common projection mode used for rendering a 3D scene.
	 *
	 * ```js
	 * const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
	 * scene.add( camera );
	 * ```
	 *
	 * @augments Camera
	 */
	class PerspectiveCamera extends Camera {

		/**
		 * Constructs a new perspective camera.
		 *
		 * @param {number} [fov=50] - The vertical field of view.
		 * @param {number} [aspect=1] - The aspect ratio.
		 * @param {number} [near=0.1] - The camera's near plane.
		 * @param {number} [far=2000] - The camera's far plane.
		 */
		constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isPerspectiveCamera = true;

			this.type = 'PerspectiveCamera';

			/**
			 * The vertical field of view, from bottom to top of view,
			 * in degrees.
			 *
			 * @type {number}
			 * @default 50
			 */
			this.fov = fov;

			/**
			 * The zoom factor of the camera.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.zoom = 1;

			/**
			 * The camera's near plane. The valid range is greater than `0`
			 * and less than the current value of {@link PerspectiveCamera#far}.
			 *
			 * Note that, unlike for the {@link OrthographicCamera}, `0` is <em>not</em> a
			 * valid value for a perspective camera's near plane.
			 *
			 * @type {number}
			 * @default 0.1
			 */
			this.near = near;

			/**
			 * The camera's far plane. Must be greater than the
			 * current value of {@link PerspectiveCamera#near}.
			 *
			 * @type {number}
			 * @default 2000
			 */
			this.far = far;

			/**
			 * Object distance used for stereoscopy and depth-of-field effects. This
			 * parameter does not influence the projection matrix unless a
			 * {@link StereoCamera} is being used.
			 *
			 * @type {number}
			 * @default 10
			 */
			this.focus = 10;

			/**
			 * The aspect ratio, usually the canvas width / canvas height.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.aspect = aspect;

			/**
			 * Represents the frustum window specification. This property should not be edited
			 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
			 *
			 * @type {?Object}
			 * @default null
			 */
			this.view = null;

			/**
			 * Film size used for the larger axis. Default is `35` (millimeters). This
			 * parameter does not influence the projection matrix unless {@link PerspectiveCamera#filmOffset}
			 * is set to a nonzero value.
			 *
			 * @type {number}
			 * @default 35
			 */
			this.filmGauge = 35;

			/**
			 * Horizontal off-center offset in the same unit as {@link PerspectiveCamera#filmGauge}.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.filmOffset = 0;

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		}

		/**
		 * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength( focalLength ) {

			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		}

		/**
		 * Returns the focal length from the current {@link PerspectiveCamera#fov} and
		 * {@link PerspectiveCamera#filmGauge}.
		 *
		 * @return {number} The computed focal length.
		 */
		getFocalLength() {

			const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		}

		/**
		 * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
		 *
		 * @return {number} The effective FOV.
		 */
		getEffectiveFOV() {

			return RAD2DEG * 2 * Math.atan(
				Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

		}

		/**
		 * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
		 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
		 *
		 * @return {number} The film width.
		 */
		getFilmWidth() {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		}

		/**
		 * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
		 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
		 *
		 * @return {number} The film width.
		 */
		getFilmHeight() {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		}

		/**
		 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
		 * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
		 *
		 * @param {number} distance - The viewing distance.
		 * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
		 * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
		 */
		getViewBounds( distance, minTarget, maxTarget ) {

			_v3.set( -1, -1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

			minTarget.set( _v3.x, _v3.y ).multiplyScalar( - distance / _v3.z );

			_v3.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

			maxTarget.set( _v3.x, _v3.y ).multiplyScalar( - distance / _v3.z );

		}

		/**
		 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
		 *
		 * @param {number} distance - The viewing distance.
		 * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
		 * @returns {Vector2} The view size.
		 */
		getViewSize( distance, target ) {

			this.getViewBounds( distance, _minTarget, _maxTarget );

			return target.subVectors( _maxTarget, _minTarget );

		}

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *```
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *```
		 * then for each monitor you would call it like this:
		 *```js
		 * const w = 1920;
		 * const h = 1080;
		 * const fullWidth = w * 3;
		 * const fullHeight = h * 2;
		 *
		 * // --A--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 * // --B--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 * // --C--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 * // --D--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 * // --E--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 * // --F--
		 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 * ```
		 *
		 * Note there is no reason monitors have to be the same size or in a grid.
		 *
		 * @param {number} fullWidth - The full width of multiview setup.
		 * @param {number} fullHeight - The full height of multiview setup.
		 * @param {number} x - The horizontal offset of the subcamera.
		 * @param {number} y - The vertical offset of the subcamera.
		 * @param {number} width - The width of subcamera.
		 * @param {number} height - The height of subcamera.
		 */
		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		/**
		 * Removes the view offset from the projection matrix.
		 */
		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		/**
		 * Updates the camera's projection matrix. Must be called after any change of
		 * camera properties.
		 */
		updateProjectionMatrix() {

			const near = this.near;
			let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = -0.5 * width;
			const view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				const fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			const skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem, this.reversedDepth );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	}

	const fov = -90; // negative fov is not an error
	const aspect = 1;

	/**
	 * A special type of camera that is positioned in 3D space to render its surroundings into a
	 * cube render target. The render target can then be used as an environment map for rendering
	 * realtime reflections in your scene.
	 *
	 * ```js
	 * // Create cube render target
	 * const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );
	 *
	 * // Create cube camera
	 * const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );
	 * scene.add( cubeCamera );
	 *
	 * // Create car
	 * const chromeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: cubeRenderTarget.texture } );
	 * const car = new THREE.Mesh( carGeometry, chromeMaterial );
	 * scene.add( car );
	 *
	 * // Update the render target cube
	 * car.visible = false;
	 * cubeCamera.position.copy( car.position );
	 * cubeCamera.update( renderer, scene );
	 *
	 * // Render the scene
	 * car.visible = true;
	 * renderer.render( scene, camera );
	 * ```
	 *
	 * @augments Object3D
	 */
	class CubeCamera extends Object3D {

		/**
		 * Constructs a new cube camera.
		 *
		 * @param {number} near - The camera's near plane.
		 * @param {number} far - The camera's far plane.
		 * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
		 */
		constructor( near, far, renderTarget ) {

			super();

			this.type = 'CubeCamera';

			/**
			 * A reference to the cube render target.
			 *
			 * @type {WebGLCubeRenderTarget}
			 */
			this.renderTarget = renderTarget;

			/**
			 * The current active coordinate system.
			 *
			 * @type {?(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
			 * @default null
			 */
			this.coordinateSystem = null;

			/**
			 * The current active mipmap level
			 *
			 * @type {number}
			 * @default 0
			 */
			this.activeMipmapLevel = 0;

			const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.layers = this.layers;
			this.add( cameraPX );

			const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.layers = this.layers;
			this.add( cameraNX );

			const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.layers = this.layers;
			this.add( cameraPY );

			const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.layers = this.layers;
			this.add( cameraNY );

			const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.layers = this.layers;
			this.add( cameraPZ );

			const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.layers = this.layers;
			this.add( cameraNZ );

		}

		/**
		 * Must be called when the coordinate system of the cube camera is changed.
		 */
		updateCoordinateSystem() {

			const coordinateSystem = this.coordinateSystem;

			const cameras = this.children.concat();

			const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

			for ( const camera of cameras ) this.remove( camera );

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				cameraPX.up.set( 0, 1, 0 );
				cameraPX.lookAt( 1, 0, 0 );

				cameraNX.up.set( 0, 1, 0 );
				cameraNX.lookAt( -1, 0, 0 );

				cameraPY.up.set( 0, 0, -1 );
				cameraPY.lookAt( 0, 1, 0 );

				cameraNY.up.set( 0, 0, 1 );
				cameraNY.lookAt( 0, -1, 0 );

				cameraPZ.up.set( 0, 1, 0 );
				cameraPZ.lookAt( 0, 0, 1 );

				cameraNZ.up.set( 0, 1, 0 );
				cameraNZ.lookAt( 0, 0, -1 );

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				cameraPX.up.set( 0, -1, 0 );
				cameraPX.lookAt( -1, 0, 0 );

				cameraNX.up.set( 0, -1, 0 );
				cameraNX.lookAt( 1, 0, 0 );

				cameraPY.up.set( 0, 0, 1 );
				cameraPY.lookAt( 0, 1, 0 );

				cameraNY.up.set( 0, 0, -1 );
				cameraNY.lookAt( 0, -1, 0 );

				cameraPZ.up.set( 0, -1, 0 );
				cameraPZ.lookAt( 0, 0, 1 );

				cameraNZ.up.set( 0, -1, 0 );
				cameraNZ.lookAt( 0, 0, -1 );

			} else {

				throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

			}

			for ( const camera of cameras ) {

				this.add( camera );

				camera.updateMatrixWorld();

			}

		}

		/**
		 * Calling this method will render the given scene with the given renderer
		 * into the cube render target of the camera.
		 *
		 * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
		 * @param {Scene} scene - The scene to render.
		 */
		update( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			const { renderTarget, activeMipmapLevel } = this;

			if ( this.coordinateSystem !== renderer.coordinateSystem ) {

				this.coordinateSystem = renderer.coordinateSystem;

				this.updateCoordinateSystem();

			}

			const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

			const currentRenderTarget = renderer.getRenderTarget();
			const currentActiveCubeFace = renderer.getActiveCubeFace();
			const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

			const currentXrEnabled = renderer.xr.enabled;

			renderer.xr.enabled = false;

			const generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
			renderer.render( scene, cameraPZ );

			// mipmaps are generated during the last call of render()
			// at this point, all sides of the cube render target are defined

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

			renderer.xr.enabled = currentXrEnabled;

			renderTarget.texture.needsPMREMUpdate = true;

		}

	}

	/**
	 * Creates a cube texture made up of six images.
	 *
	 * ```js
	 * const loader = new THREE.CubeTextureLoader();
	 * loader.setPath( 'textures/cube/pisa/' );
	 *
	 * const textureCube = loader.load( [
	 * 	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
	 * ] );
	 *
	 * const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
	 * ```
	 *
	 * @augments Texture
	 */
	class CubeTexture extends Texture {

		/**
		 * Constructs a new cube texture.
		 *
		 * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
		 * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
		 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
		 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
		 * @param {number} [magFilter=LinearFilter] - The mag filter value.
		 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
		 * @param {number} [format=RGBAFormat] - The texture format.
		 * @param {number} [type=UnsignedByteType] - The texture type.
		 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
		 * @param {string} [colorSpace=NoColorSpace] - The color space value.
		 */
		constructor( images = [], mapping = CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

			super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isCubeTexture = true;

			/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.flipY = false;

		}

		/**
		 * Alias for {@link CubeTexture#image}.
		 *
		 * @type {Array<Image>}
		 */
		get images() {

			return this.image;

		}

		set images( value ) {

			this.image = value;

		}

	}

	/**
	 * A cube render target used in context of {@link WebGLRenderer}.
	 *
	 * @augments WebGLRenderTarget
	 */
	class WebGLCubeRenderTarget extends WebGLRenderTarget {

		/**
		 * Constructs a new cube render target.
		 *
		 * @param {number} [size=1] - The size of the render target.
		 * @param {RenderTarget~Options} [options] - The configuration object.
		 */
		constructor( size = 1, options = {} ) {

			super( size, size, options );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isWebGLCubeRenderTarget = true;

			const image = { width: size, height: size, depth: 1 };
			const images = [ image, image, image, image, image, image ];

			/**
			 * Overwritten with a different texture type.
			 *
			 * @type {DataArrayTexture}
			 */
			this.texture = new CubeTexture( images );
			this._setTextureOptions( options );

			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			this.texture.isRenderTargetTexture = true;

		}

		/**
		 * Converts the given equirectangular texture to a cube map.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {Texture} texture - The equirectangular texture.
		 * @return {WebGLCubeRenderTarget} A reference to this cube render target.
		 */
		fromEquirectangularTexture( renderer, texture ) {

			this.texture.type = texture.type;
			this.texture.colorSpace = texture.colorSpace;

			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;

			const shader = {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

				fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};

			const geometry = new BoxGeometry( 5, 5, 5 );

			const material = new ShaderMaterial( {

				name: 'CubemapFromEquirect',

				uniforms: cloneUniforms( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending

			} );

			material.uniforms.tEquirect.value = texture;

			const mesh = new Mesh( geometry, material );

			const currentMinFilter = texture.minFilter;

			// Avoid blurred poles
			if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

			const camera = new CubeCamera( 1, 10, this );
			camera.update( renderer, mesh );

			texture.minFilter = currentMinFilter;

			mesh.geometry.dispose();
			mesh.material.dispose();

			return this;

		}

		/**
		 * Clears this cube render target.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
		 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
		 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
		 */
		clear( renderer, color = true, depth = true, stencil = true ) {

			const currentRenderTarget = renderer.getRenderTarget();

			for ( let i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( this, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		}

	}

	function WebGLCubeMaps( renderer ) {

		let cubemaps = new WeakMap();

		function mapTextureMapping( texture, mapping ) {

			if ( mapping === EquirectangularReflectionMapping ) {

				texture.mapping = CubeReflectionMapping;

			} else if ( mapping === EquirectangularRefractionMapping ) {

				texture.mapping = CubeRefractionMapping;

			}

			return texture;

		}

		function get( texture ) {

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					if ( cubemaps.has( texture ) ) {

						const cubemap = cubemaps.get( texture ).texture;
						return mapTextureMapping( cubemap, texture.mapping );

					} else {

						const image = texture.image;

						if ( image && image.height > 0 ) {

							const renderTarget = new WebGLCubeRenderTarget( image.height );
							renderTarget.fromEquirectangularTexture( renderer, texture );
							cubemaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return mapTextureMapping( renderTarget.texture, texture.mapping );

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

			return texture;

		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemap = cubemaps.get( texture );

			if ( cubemap !== undefined ) {

				cubemaps.delete( texture );
				cubemap.dispose();

			}

		}

		function dispose() {

			cubemaps = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * Camera that uses [orthographic projection]{@link https://en.wikipedia.org/wiki/Orthographic_projection}.
	 *
	 * In this projection mode, an object's size in the rendered image stays
	 * constant regardless of its distance from the camera. This can be useful
	 * for rendering 2D scenes and UI elements, amongst other things.
	 *
	 * ```js
	 * const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
	 * scene.add( camera );
	 * ```
	 *
	 * @augments Camera
	 */
	class OrthographicCamera extends Camera {

		/**
		 * Constructs a new orthographic camera.
		 *
		 * @param {number} [left=-1] - The left plane of the camera's frustum.
		 * @param {number} [right=1] - The right plane of the camera's frustum.
		 * @param {number} [top=1] - The top plane of the camera's frustum.
		 * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
		 * @param {number} [near=0.1] - The camera's near plane.
		 * @param {number} [far=2000] - The camera's far plane.
		 */
		constructor( left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000 ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isOrthographicCamera = true;

			this.type = 'OrthographicCamera';

			/**
			 * The zoom factor of the camera.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.zoom = 1;

			/**
			 * Represents the frustum window specification. This property should not be edited
			 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
			 *
			 * @type {?Object}
			 * @default null
			 */
			this.view = null;

			/**
			 * The left plane of the camera's frustum.
			 *
			 * @type {number}
			 * @default -1
			 */
			this.left = left;

			/**
			 * The right plane of the camera's frustum.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.right = right;

			/**
			 * The top plane of the camera's frustum.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.top = top;

			/**
			 * The bottom plane of the camera's frustum.
			 *
			 * @type {number}
			 * @default -1
			 */
			this.bottom = bottom;

			/**
			 * The camera's near plane. The valid range is greater than `0`
			 * and less than the current value of {@link OrthographicCamera#far}.
			 *
			 * Note that, unlike for the {@link PerspectiveCamera}, `0` is a
			 * valid value for an orthographic camera's near plane.
			 *
			 * @type {number}
			 * @default 0.1
			 */
			this.near = near;

			/**
			 * The camera's far plane. Must be greater than the
			 * current value of {@link OrthographicCamera#near}.
			 *
			 * @type {number}
			 * @default 2000
			 */
			this.far = far;

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		}

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * @param {number} fullWidth - The full width of multiview setup.
		 * @param {number} fullHeight - The full height of multiview setup.
		 * @param {number} x - The horizontal offset of the subcamera.
		 * @param {number} y - The vertical offset of the subcamera.
		 * @param {number} width - The width of subcamera.
		 * @param {number} height - The height of subcamera.
		 * @see {@link PerspectiveCamera#setViewOffset}
		 */
		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		/**
		 * Removes the view offset from the projection matrix.
		 */
		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		/**
		 * Updates the camera's projection matrix. Must be called after any change of
		 * camera properties.
		 */
		updateProjectionMatrix() {

			const dx = ( this.right - this.left ) / ( 2 * this.zoom );
			const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			const cx = ( this.right + this.left ) / 2;
			const cy = ( this.top + this.bottom ) / 2;

			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
				const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem, this.reversedDepth );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	}

	const LOD_MIN = 4;

	// The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.
	const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

	// The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.
	const MAX_SAMPLES = 20;

	const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
	const _clearColor = /*@__PURE__*/ new Color();
	let _oldTarget = null;
	let _oldActiveCubeFace = 0;
	let _oldActiveMipmapLevel = 0;
	let _oldXrEnabled = false;

	// Golden Ratio
	const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
	const INV_PHI = 1 / PHI;

	// Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.
	const _axisDirections = [
		/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
		/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
		/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
		/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
		/*@__PURE__*/ new Vector3( -1, 1, -1 ),
		/*@__PURE__*/ new Vector3( 1, 1, -1 ),
		/*@__PURE__*/ new Vector3( -1, 1, 1 ),
		/*@__PURE__*/ new Vector3( 1, 1, 1 ) ];

	const _origin = /*@__PURE__*/ new Vector3();

	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting:
	 * {@link https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view}
	*/
	class PMREMGenerator {

		/**
		 * Constructs a new PMREM generator.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 */
		constructor( renderer ) {

			this._renderer = renderer;
			this._pingPongRenderTarget = null;

			this._lodMax = 0;
			this._cubeSize = 0;
			this._lodPlanes = [];
			this._sizeLods = [];
			this._sigmas = [];

			this._blurMaterial = null;
			this._cubemapMaterial = null;
			this._equirectMaterial = null;

			this._compileMaterial( this._blurMaterial );

		}

		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety.
		 *
		 * @param {Scene} scene - The scene to be captured.
		 * @param {number} [sigma=0] - The blur radius in radians.
		 * @param {number} [near=0.1] - The near plane distance.
		 * @param {number} [far=100] - The far plane distance.
		 * @param {Object} [options={}] - The configuration options.
		 * @param {number} [options.size=256] - The texture size of the PMREM.
		 * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
		 * @return {WebGLRenderTarget} The resulting PMREM.
		 */
		fromScene( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {

			const {
				size = 256,
				position = _origin,
			} = options;

			_oldTarget = this._renderer.getRenderTarget();
			_oldActiveCubeFace = this._renderer.getActiveCubeFace();
			_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
			_oldXrEnabled = this._renderer.xr.enabled;

			this._renderer.xr.enabled = false;

			this._setSize( size );

			const cubeUVRenderTarget = this._allocateTargets();
			cubeUVRenderTarget.depthBuffer = true;

			this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position );

			if ( sigma > 0 ) {

				this._blur( cubeUVRenderTarget, 0, 0, sigma );

			}

			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * or HDR. The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 *
		 * @param {Texture} equirectangular - The equirectangular texture to be converted.
		 * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
		 * @return {WebGLRenderTarget} The resulting PMREM.
		 */
		fromEquirectangular( equirectangular, renderTarget = null ) {

			return this._fromTexture( equirectangular, renderTarget );

		}

		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * or HDR. The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 *
		 * @param {Texture} cubemap - The cubemap texture to be converted.
		 * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
		 * @return {WebGLRenderTarget} The resulting PMREM.
		 */
		fromCubemap( cubemap, renderTarget = null ) {

			return this._fromTexture( cubemap, renderTarget );

		}

		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileCubemapShader() {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();
				this._compileMaterial( this._cubemapMaterial );

			}

		}

		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileEquirectangularShader() {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();
				this._compileMaterial( this._equirectMaterial );

			}

		}

		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */
		dispose() {

			this._dispose();

			if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
			if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

		}

		// private interface

		_setSize( cubeSize ) {

			this._lodMax = Math.floor( Math.log2( cubeSize ) );
			this._cubeSize = Math.pow( 2, this._lodMax );

		}

		_dispose() {

			if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

			if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

			for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

				this._lodPlanes[ i ].dispose();

			}

		}

		_cleanup( outputTarget ) {

			this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
			this._renderer.xr.enabled = _oldXrEnabled;

			outputTarget.scissorTest = false;
			_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

		}

		_fromTexture( texture, renderTarget ) {

			if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

				this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

			} else { // Equirectangular

				this._setSize( texture.image.width / 4 );

			}

			_oldTarget = this._renderer.getRenderTarget();
			_oldActiveCubeFace = this._renderer.getActiveCubeFace();
			_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
			_oldXrEnabled = this._renderer.xr.enabled;

			this._renderer.xr.enabled = false;

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();
			this._textureToCubeUV( texture, cubeUVRenderTarget );
			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		_allocateTargets() {

			const width = 3 * Math.max( this._cubeSize, 16 * 7 );
			const height = 4 * this._cubeSize;

			const params = {
				magFilter: LinearFilter,
				minFilter: LinearFilter,
				generateMipmaps: false,
				type: HalfFloatType,
				format: RGBAFormat,
				colorSpace: LinearSRGBColorSpace,
				depthBuffer: false
			};

			const cubeUVRenderTarget = _createRenderTarget( width, height, params );

			if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

				if ( this._pingPongRenderTarget !== null ) {

					this._dispose();

				}

				this._pingPongRenderTarget = _createRenderTarget( width, height, params );

				const { _lodMax } = this;
				( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

				this._blurMaterial = _getBlurShader( _lodMax, width, height );

			}

			return cubeUVRenderTarget;

		}

		_compileMaterial( material ) {

			const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
			this._renderer.compile( tmpMesh, _flatCamera );

		}

		_sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position ) {

			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
			const upSign = [ 1, -1, 1, 1, 1, 1 ];
			const forwardSign = [ 1, 1, 1, -1, -1, -1 ];
			const renderer = this._renderer;

			const originalAutoClear = renderer.autoClear;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor( _clearColor );

			renderer.toneMapping = NoToneMapping;
			renderer.autoClear = false;

			// https://github.com/mrdoob/three.js/issues/31413#issuecomment-3095966812
			const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();

			if ( reversedDepthBuffer ) {

				renderer.setRenderTarget( cubeUVRenderTarget );
				renderer.clearDepth();
				renderer.setRenderTarget( null );

			}

			const backgroundMaterial = new MeshBasicMaterial( {
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false,
			} );

			const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

			let useSolidColor = false;
			const background = scene.background;

			if ( background ) {

				if ( background.isColor ) {

					backgroundMaterial.color.copy( background );
					scene.background = null;
					useSolidColor = true;

				}

			} else {

				backgroundMaterial.color.copy( _clearColor );
				useSolidColor = true;

			}

			for ( let i = 0; i < 6; i ++ ) {

				const col = i % 3;

				if ( col === 0 ) {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.position.set( position.x, position.y, position.z );
					cubeCamera.lookAt( position.x + forwardSign[ i ], position.y, position.z );

				} else if ( col === 1 ) {

					cubeCamera.up.set( 0, 0, upSign[ i ] );
					cubeCamera.position.set( position.x, position.y, position.z );
					cubeCamera.lookAt( position.x, position.y + forwardSign[ i ], position.z );


				} else {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.position.set( position.x, position.y, position.z );
					cubeCamera.lookAt( position.x, position.y, position.z + forwardSign[ i ] );

				}

				const size = this._cubeSize;

				_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

				renderer.setRenderTarget( cubeUVRenderTarget );

				if ( useSolidColor ) {

					renderer.render( backgroundBox, cubeCamera );

				}

				renderer.render( scene, cubeCamera );

			}

			backgroundBox.geometry.dispose();
			backgroundBox.material.dispose();

			renderer.toneMapping = toneMapping;
			renderer.autoClear = originalAutoClear;
			scene.background = background;

		}

		_textureToCubeUV( texture, cubeUVRenderTarget ) {

			const renderer = this._renderer;

			const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

			if ( isCubeTexture ) {

				if ( this._cubemapMaterial === null ) {

					this._cubemapMaterial = _getCubemapMaterial();

				}

				this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? -1 : 1;

			} else {

				if ( this._equirectMaterial === null ) {

					this._equirectMaterial = _getEquirectMaterial();

				}

			}

			const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
			const mesh = new Mesh( this._lodPlanes[ 0 ], material );

			const uniforms = material.uniforms;

			uniforms[ 'envMap' ].value = texture;

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

			renderer.setRenderTarget( cubeUVRenderTarget );
			renderer.render( mesh, _flatCamera );

		}

		_applyPMREM( cubeUVRenderTarget ) {

			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;
			const n = this._lodPlanes.length;

			for ( let i = 1; i < n; i ++ ) {

				const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

				const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

				this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

			}

			renderer.autoClear = autoClear;

		}

		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 *
		 * @private
		 * @param {WebGLRenderTarget} cubeUVRenderTarget
		 * @param {number} lodIn
		 * @param {number} lodOut
		 * @param {number} sigma
		 * @param {Vector3} [poleAxis]
		 */
		_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

			const pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(
				cubeUVRenderTarget,
				pingPongRenderTarget,
				lodIn,
				lodOut,
				sigma,
				'latitudinal',
				poleAxis );

			this._halfBlur(
				pingPongRenderTarget,
				cubeUVRenderTarget,
				lodOut,
				lodOut,
				sigma,
				'longitudinal',
				poleAxis );

		}

		_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;

			if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

				error(
					'blur direction must be either latitudinal or longitudinal!' );

			}

			// Number of standard deviations at which to cut off the discrete approximation.
			const STANDARD_DEVIATIONS = 3;

			const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
			const blurUniforms = blurMaterial.uniforms;

			const pixels = this._sizeLods[ lodIn ] - 1;
			const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

			if ( samples > MAX_SAMPLES ) {

				warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

			}

			const weights = [];
			let sum = 0;

			for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

				const x = i / sigmaPixels;
				const weight = Math.exp( - x * x / 2 );
				weights.push( weight );

				if ( i === 0 ) {

					sum += weight;

				} else if ( i < samples ) {

					sum += 2 * weight;

				}

			}

			for ( let i = 0; i < weights.length; i ++ ) {

				weights[ i ] = weights[ i ] / sum;

			}

			blurUniforms[ 'envMap' ].value = targetIn.texture;
			blurUniforms[ 'samples' ].value = samples;
			blurUniforms[ 'weights' ].value = weights;
			blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

			if ( poleAxis ) {

				blurUniforms[ 'poleAxis' ].value = poleAxis;

			}

			const { _lodMax } = this;
			blurUniforms[ 'dTheta' ].value = radiansPerPixel;
			blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

			const outputSize = this._sizeLods[ lodOut ];
			const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
			const y = 4 * ( this._cubeSize - outputSize );

			_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
			renderer.setRenderTarget( targetOut );
			renderer.render( blurMesh, _flatCamera );

		}

	}



	function _createPlanes( lodMax ) {

		const lodPlanes = [];
		const sizeLods = [];
		const sigmas = [];

		let lod = lodMax;

		const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

		for ( let i = 0; i < totalLods; i ++ ) {

			const sizeLod = Math.pow( 2, lod );
			sizeLods.push( sizeLod );
			let sigma = 1.0 / sizeLod;

			if ( i > lodMax - LOD_MIN ) {

				sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

			} else if ( i === 0 ) {

				sigma = 0;

			}

			sigmas.push( sigma );

			const texelSize = 1.0 / ( sizeLod - 2 );
			const min = - texelSize;
			const max = 1 + texelSize;
			const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;

			const position = new Float32Array( positionSize * vertices * cubeFaces );
			const uv = new Float32Array( uvSize * vertices * cubeFaces );
			const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

			for ( let face = 0; face < cubeFaces; face ++ ) {

				const x = ( face % 3 ) * 2 / 3 - 1;
				const y = face > 2 ? 0 : -1;
				const coordinates = [
					x, y, 0,
					x + 2 / 3, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y + 1, 0
				];
				position.set( coordinates, positionSize * vertices * face );
				uv.set( uv1, uvSize * vertices * face );
				const fill = [ face, face, face, face, face, face ];
				faceIndex.set( fill, faceIndexSize * vertices * face );

			}

			const planes = new BufferGeometry();
			planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
			planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
			planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
			lodPlanes.push( planes );

			if ( lod > LOD_MIN ) {

				lod --;

			}

		}

		return { lodPlanes, sizeLods, sigmas };

	}

	function _createRenderTarget( width, height, params ) {

		const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;

	}

	function _setViewport( target, x, y, width, height ) {

		target.viewport.set( x, y, width, height );
		target.scissor.set( x, y, width, height );

	}

	function _getBlurShader( lodMax, width, height ) {

		const weights = new Float32Array( MAX_SAMPLES );
		const poleAxis = new Vector3( 0, 1, 0 );
		const shaderMaterial = new ShaderMaterial( {

			name: 'SphericalGaussianBlur',

			defines: {
				'n': MAX_SAMPLES,
				'CUBEUV_TEXEL_WIDTH': 1.0 / width,
				'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
				'CUBEUV_MAX_MIP': `${lodMax}.0`,
			},

			uniforms: {
				'envMap': { value: null },
				'samples': { value: 1 },
				'weights': { value: weights },
				'latitudinal': { value: false },
				'dTheta': { value: 0 },
				'mipInt': { value: 0 },
				'poleAxis': { value: poleAxis }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

		return shaderMaterial;

	}

	function _getEquirectMaterial() {

		return new ShaderMaterial( {

			name: 'EquirectangularToCubeUV',

			uniforms: {
				'envMap': { value: null }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCubemapMaterial() {

		return new ShaderMaterial( {

			name: 'CubemapToCubeUV',

			uniforms: {
				'envMap': { value: null },
				'flipEnvMap': { value: -1 }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCommonVertexShader() {

		return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

	}

	function WebGLCubeUVMaps( renderer ) {

		let cubeUVmaps = new WeakMap();

		let pmremGenerator = null;

		function get( texture ) {

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
				const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

				// equirect/cube map to cubeUV conversion

				if ( isEquirectMap || isCubeMap ) {

					let renderTarget = cubeUVmaps.get( texture );

					const currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;

					if ( texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion ) {

						if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

						renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
						renderTarget.texture.pmremVersion = texture.pmremVersion;

						cubeUVmaps.set( texture, renderTarget );

						return renderTarget.texture;

					} else {

						if ( renderTarget !== undefined ) {

							return renderTarget.texture;

						} else {

							const image = texture.image;

							if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

								if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

								renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
								renderTarget.texture.pmremVersion = texture.pmremVersion;

								cubeUVmaps.set( texture, renderTarget );

								texture.addEventListener( 'dispose', onTextureDispose );

								return renderTarget.texture;

							} else {

								// image not yet ready. try the conversion next frame

								return null;

							}

						}

					}

				}

			}

			return texture;

		}

		function isCubeTextureComplete( image ) {

			let count = 0;
			const length = 6;

			for ( let i = 0; i < length; i ++ ) {

				if ( image[ i ] !== undefined ) count ++;

			}

			return count === length;


		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemapUV = cubeUVmaps.get( texture );

			if ( cubemapUV !== undefined ) {

				cubeUVmaps.delete( texture );
				cubemapUV.dispose();

			}

		}

		function dispose() {

			cubeUVmaps = new WeakMap();

			if ( pmremGenerator !== null ) {

				pmremGenerator.dispose();
				pmremGenerator = null;

			}

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function WebGLExtensions( gl ) {

		const extensions = {};

		function getExtension( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			let extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			extensions[ name ] = extension;

			return extension;

		}

		return {

			has: function ( name ) {

				return getExtension( name ) !== null;

			},

			init: function () {

				getExtension( 'EXT_color_buffer_float' );
				getExtension( 'WEBGL_clip_cull_distance' );
				getExtension( 'OES_texture_float_linear' );
				getExtension( 'EXT_color_buffer_half_float' );
				getExtension( 'WEBGL_multisampled_render_to_texture' );
				getExtension( 'WEBGL_render_shared_exponent' );

			},

			get: function ( name ) {

				const extension = getExtension( name );

				if ( extension === null ) {

					warnOnce( 'WebGLRenderer: ' + name + ' extension not supported.' );

				}

				return extension;

			}

		};

	}

	function WebGLGeometries( gl, attributes, info, bindingStates ) {

		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose( event ) {

			const geometry = event.target;

			if ( geometry.index !== null ) {

				attributes.remove( geometry.index );

			}

			for ( const name in geometry.attributes ) {

				attributes.remove( geometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			const attribute = wireframeAttributes.get( geometry );

			if ( attribute ) {

				attributes.remove( attribute );
				wireframeAttributes.delete( geometry );

			}

			bindingStates.releaseStatesOfGeometry( geometry );

			if ( geometry.isInstancedBufferGeometry === true ) {

				delete geometry._maxInstanceCount;

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			if ( geometries[ geometry.id ] === true ) return geometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			geometries[ geometry.id ] = true;

			info.memory.geometries ++;

			return geometry;

		}

		function update( geometry ) {

			const geometryAttributes = geometry.attributes;

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for ( const name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

			}

		}

		function updateWireframeAttribute( geometry ) {

			const indices = [];

			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if ( geometryIndex !== null ) {

				const array = geometryIndex.array;
				version = geometryIndex.version;

				for ( let i = 0, l = array.length; i < l; i += 3 ) {

					const a = array[ i + 0 ];
					const b = array[ i + 1 ];
					const c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else if ( geometryPosition !== undefined ) {

				const array = geometryPosition.array;
				version = geometryPosition.version;

				for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					const a = i + 0;
					const b = i + 1;
					const c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			} else {

				return;

			}

			const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
			attribute.version = version;

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			const previousAttribute = wireframeAttributes.get( geometry );

			if ( previousAttribute ) attributes.remove( previousAttribute );

			//

			wireframeAttributes.set( geometry, attribute );

		}

		function getWireframeAttribute( geometry ) {

			const currentAttribute = wireframeAttributes.get( geometry );

			if ( currentAttribute ) {

				const geometryIndex = geometry.index;

				if ( geometryIndex !== null ) {

					// if the attribute is obsolete, create a new one

					if ( currentAttribute.version < geometryIndex.version ) {

						updateWireframeAttribute( geometry );

					}

				}

			} else {

				updateWireframeAttribute( geometry );

			}

			return wireframeAttributes.get( geometry );

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	function WebGLIndexedBufferRenderer( gl, extensions, info ) {

		let mode;

		function setMode( value ) {

			mode = value;

		}

		let type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			gl.drawElementsInstanced( mode, count, type, start * bytesPerElement, primcount );

			info.update( count, mode, primcount );

		}

		function renderMultiDraw( starts, counts, drawCount ) {

			if ( drawCount === 0 ) return;

			const extension = extensions.get( 'WEBGL_multi_draw' );
			extension.multiDrawElementsWEBGL( mode, counts, 0, type, starts, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			info.update( elementCount, mode, 1 );


		}

		function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

			if ( drawCount === 0 ) return;

			const extension = extensions.get( 'WEBGL_multi_draw' );

			if ( extension === null ) {

				for ( let i = 0; i < starts.length; i ++ ) {

					renderInstances( starts[ i ] / bytesPerElement, counts[ i ], primcount[ i ] );

				}

			} else {

				extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, type, starts, 0, primcount, 0, drawCount );

				let elementCount = 0;
				for ( let i = 0; i < drawCount; i ++ ) {

					elementCount += counts[ i ] * primcount[ i ];

				}

				info.update( elementCount, mode, 1 );

			}

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
		this.renderMultiDraw = renderMultiDraw;
		this.renderMultiDrawInstances = renderMultiDrawInstances;

	}

	function WebGLInfo( gl ) {

		const memory = {
			geometries: 0,
			textures: 0
		};

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			render.calls ++;

			switch ( mode ) {

				case gl.TRIANGLES:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case gl.LINES:
					render.lines += instanceCount * ( count / 2 );
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * ( count - 1 );
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					error( 'WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	/**
	 * Creates an array of textures directly from raw buffer data.
	 *
	 * @augments Texture
	 */
	class DataArrayTexture extends Texture {

		/**
		 * Constructs a new data array texture.
		 *
		 * @param {?TypedArray} [data=null] - The buffer data.
		 * @param {number} [width=1] - The width of the texture.
		 * @param {number} [height=1] - The height of the texture.
		 * @param {number} [depth=1] - The depth of the texture.
		 */
		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			super( null );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isDataArrayTexture = true;

			/**
			 * The image definition of a data texture.
			 *
			 * @type {{data:TypedArray,width:number,height:number,depth:number}}
			 */
			this.image = { data, width, height, depth };

			/**
			 * How the texture is sampled when a texel covers more than one pixel.
			 *
			 * Overwritten and set to `NearestFilter` by default.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default NearestFilter
			 */
			this.magFilter = NearestFilter;

			/**
			 * How the texture is sampled when a texel covers less than one pixel.
			 *
			 * Overwritten and set to `NearestFilter` by default.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default NearestFilter
			 */
			this.minFilter = NearestFilter;

			/**
			 * This defines how the texture is wrapped in the depth and corresponds to
			 * *W* in UVW mapping.
			 *
			 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
			 * @default ClampToEdgeWrapping
			 */
			this.wrapR = ClampToEdgeWrapping;

			/**
			 * Whether to generate mipmaps (if possible) for a texture.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.generateMipmaps = false;

			/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.flipY = false;

			/**
			 * Specifies the alignment requirements for the start of each pixel row in memory.
			 *
			 * Overwritten and set to `1` by default.
			 *
			 * @type {boolean}
			 * @default 1
			 */
			this.unpackAlignment = 1;

			/**
			 * A set of all layers which need to be updated in the texture.
			 *
			 * @type {Set<number>}
			 */
			this.layerUpdates = new Set();

		}

		/**
		 * Describes that a specific layer of the texture needs to be updated.
		 * Normally when {@link Texture#needsUpdate} is set to `true`, the
		 * entire data texture array is sent to the GPU. Marking specific
		 * layers will only transmit subsets of all mipmaps associated with a
		 * specific depth in the array which is often much more performant.
		 *
		 * @param {number} layerIndex - The layer index that should be updated.
		 */
		addLayerUpdate( layerIndex ) {

			this.layerUpdates.add( layerIndex );

		}

		/**
		 * Resets the layer updates registry.
		 */
		clearLayerUpdates() {

			this.layerUpdates.clear();

		}

	}

	function WebGLMorphtargets( gl, capabilities, textures ) {

		const morphTextures = new WeakMap();
		const morph = new Vector4();

		function update( object, geometry, program ) {

			const objectInfluences = object.morphTargetInfluences;

			// the following encodes morph targets into an array of data textures. Each layer represents a single morph target.

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			let entry = morphTextures.get( geometry );

			if ( entry === undefined || entry.count !== morphTargetsCount ) {

				if ( entry !== undefined ) entry.texture.dispose();

				const hasMorphPosition = geometry.morphAttributes.position !== undefined;
				const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
				const hasMorphColors = geometry.morphAttributes.color !== undefined;

				const morphTargets = geometry.morphAttributes.position || [];
				const morphNormals = geometry.morphAttributes.normal || [];
				const morphColors = geometry.morphAttributes.color || [];

				let vertexDataCount = 0;

				if ( hasMorphPosition === true ) vertexDataCount = 1;
				if ( hasMorphNormals === true ) vertexDataCount = 2;
				if ( hasMorphColors === true ) vertexDataCount = 3;

				let width = geometry.attributes.position.count * vertexDataCount;
				let height = 1;

				if ( width > capabilities.maxTextureSize ) {

					height = Math.ceil( width / capabilities.maxTextureSize );
					width = capabilities.maxTextureSize;

				}

				const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

				const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
				texture.type = FloatType;
				texture.needsUpdate = true;

				// fill buffer

				const vertexDataStride = vertexDataCount * 4;

				for ( let i = 0; i < morphTargetsCount; i ++ ) {

					const morphTarget = morphTargets[ i ];
					const morphNormal = morphNormals[ i ];
					const morphColor = morphColors[ i ];

					const offset = width * height * 4 * i;

					for ( let j = 0; j < morphTarget.count; j ++ ) {

						const stride = j * vertexDataStride;

						if ( hasMorphPosition === true ) {

							morph.fromBufferAttribute( morphTarget, j );

							buffer[ offset + stride + 0 ] = morph.x;
							buffer[ offset + stride + 1 ] = morph.y;
							buffer[ offset + stride + 2 ] = morph.z;
							buffer[ offset + stride + 3 ] = 0;

						}

						if ( hasMorphNormals === true ) {

							morph.fromBufferAttribute( morphNormal, j );

							buffer[ offset + stride + 4 ] = morph.x;
							buffer[ offset + stride + 5 ] = morph.y;
							buffer[ offset + stride + 6 ] = morph.z;
							buffer[ offset + stride + 7 ] = 0;

						}

						if ( hasMorphColors === true ) {

							morph.fromBufferAttribute( morphColor, j );

							buffer[ offset + stride + 8 ] = morph.x;
							buffer[ offset + stride + 9 ] = morph.y;
							buffer[ offset + stride + 10 ] = morph.z;
							buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

						}

					}

				}

				entry = {
					count: morphTargetsCount,
					texture: texture,
					size: new Vector2( width, height )
				};

				morphTextures.set( geometry, entry );

				function disposeTexture() {

					texture.dispose();

					morphTextures.delete( geometry );

					geometry.removeEventListener( 'dispose', disposeTexture );

				}

				geometry.addEventListener( 'dispose', disposeTexture );

			}

			//
			if ( object.isInstancedMesh === true && object.morphTexture !== null ) {

				program.getUniforms().setValue( gl, 'morphTexture', object.morphTexture, textures );

			} else {

				let morphInfluencesSum = 0;

				for ( let i = 0; i < objectInfluences.length; i ++ ) {

					morphInfluencesSum += objectInfluences[ i ];

				}

				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;


				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

			}

			program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
			program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );

		}

		return {

			update: update

		};

	}

	function WebGLObjects( gl, geometries, attributes, info ) {

		let updateMap = new WeakMap();

		function update( object ) {

			const frame = info.render.frame;

			const geometry = object.geometry;
			const buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateMap.get( buffergeometry ) !== frame ) {

				geometries.update( buffergeometry );

				updateMap.set( buffergeometry, frame );

			}

			if ( object.isInstancedMesh ) {

				if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

					object.addEventListener( 'dispose', onInstancedMeshDispose );

				}

				if ( updateMap.get( object ) !== frame ) {

					attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

					if ( object.instanceColor !== null ) {

						attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

					}

					updateMap.set( object, frame );

				}

			}

			if ( object.isSkinnedMesh ) {

				const skeleton = object.skeleton;

				if ( updateMap.get( skeleton ) !== frame ) {

					skeleton.update();

					updateMap.set( skeleton, frame );

				}

			}

			return buffergeometry;

		}

		function dispose() {

			updateMap = new WeakMap();

		}

		function onInstancedMeshDispose( event ) {

			const instancedMesh = event.target;

			instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

			attributes.remove( instancedMesh.instanceMatrix );

			if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	/**
	 * Creates a three-dimensional texture from raw data, with parameters to
	 * divide it into width, height, and depth.
	 *
	 * @augments Texture
	 */
	class Data3DTexture extends Texture {

		/**
		 * Constructs a new data array texture.
		 *
		 * @param {?TypedArray} [data=null] - The buffer data.
		 * @param {number} [width=1] - The width of the texture.
		 * @param {number} [height=1] - The height of the texture.
		 * @param {number} [depth=1] - The depth of the texture.
		 */
		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in Data3DTexture directly.
			//
			//	const texture = new THREE.Data3DTexture( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839

			super( null );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isData3DTexture = true;

			/**
			 * The image definition of a data texture.
			 *
			 * @type {{data:TypedArray,width:number,height:number,depth:number}}
			 */
			this.image = { data, width, height, depth };

			/**
			 * How the texture is sampled when a texel covers more than one pixel.
			 *
			 * Overwritten and set to `NearestFilter` by default.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default NearestFilter
			 */
			this.magFilter = NearestFilter;

			/**
			 * How the texture is sampled when a texel covers less than one pixel.
			 *
			 * Overwritten and set to `NearestFilter` by default.
			 *
			 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
			 * @default NearestFilter
			 */
			this.minFilter = NearestFilter;

			/**
			 * This defines how the texture is wrapped in the depth and corresponds to
			 * *W* in UVW mapping.
			 *
			 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
			 * @default ClampToEdgeWrapping
			 */
			this.wrapR = ClampToEdgeWrapping;

			/**
			 * Whether to generate mipmaps (if possible) for a texture.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.generateMipmaps = false;

			/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.flipY = false;

			/**
			 * Specifies the alignment requirements for the start of each pixel row in memory.
			 *
			 * Overwritten and set to `1` by default.
			 *
			 * @type {boolean}
			 * @default 1
			 */
			this.unpackAlignment = 1;

		}

	}

	/**
	 * This class can be used to automatically save the depth information of a
	 * rendering into a texture.
	 *
	 * @augments Texture
	 */
	class DepthTexture extends Texture {

		/**
		 * Constructs a new depth texture.
		 *
		 * @param {number} width - The width of the texture.
		 * @param {number} height - The height of the texture.
		 * @param {number} [type=UnsignedIntType] - The texture type.
		 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
		 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
		 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
		 * @param {number} [magFilter=LinearFilter] - The mag filter value.
		 * @param {number} [minFilter=LinearFilter] - The min filter value.
		 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
		 * @param {number} [format=DepthFormat] - The texture format.
		 * @param {number} [depth=1] - The depth of the texture.
		 */
		constructor( width, height, type = UnsignedIntType, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, format = DepthFormat, depth = 1 ) {

			if ( format !== DepthFormat && format !== DepthStencilFormat ) {

				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

			}

			const image = { width: width, height: height, depth: depth };

			super( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isDepthTexture = true;

			/**
			 * If set to `true`, the texture is flipped along the vertical axis when
			 * uploaded to the GPU.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.flipY = false;

			/**
			 * Whether to generate mipmaps (if possible) for a texture.
			 *
			 * Overwritten and set to `false` by default.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.generateMipmaps = false;

			/**
			 * Code corresponding to the depth compare function.
			 *
			 * @type {?(NeverCompare|LessCompare|EqualCompare|LessEqualCompare|GreaterCompare|NotEqualCompare|GreaterEqualCompare|AlwaysCompare)}
			 * @default null
			 */
			this.compareFunction = null;

		}


		copy( source ) {

			super.copy( source );

			this.source = new Source( Object.assign( {}, source.image ) ); // see #30540
			this.compareFunction = source.compareFunction;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

			return data;

		}

	}

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */


	const emptyTexture = /*@__PURE__*/ new Texture();

	const emptyShadowTexture = /*@__PURE__*/ new DepthTexture( 1, 1 );

	const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
	const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
	const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array( 16 );
	const mat3array = new Float32Array( 9 );
	const mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		const firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( let i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( let i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		let r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( let i = 0; i !== n; ++ i ) {

			r[ i ] = textures.allocateTextureUnit();

		}

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or THREE.MatrixN)

	function setValueM2( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValueM3( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValueM4( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single integer / boolean

	function setValueV1i( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single integer / boolean vector (from flat array or THREE.VectorN)

	function setValueV2i( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2i( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2iv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3i( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3i( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3iv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4i( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4iv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single unsigned integer

	function setValueV1ui( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1ui( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single unsigned integer vector (from flat array or THREE.VectorN)

	function setValueV2ui( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2ui( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2uiv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3ui( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3ui( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3uiv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4ui( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4uiv( this.addr, v );

			copyArray( cache, v );

		}

	}


	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		let emptyTexture2D;

		if ( this.type === gl.SAMPLER_2D_SHADOW ) {

			emptyShadowTexture.compareFunction = LessEqualCompare; // #28670
			emptyTexture2D = emptyShadowTexture;

		} else {

			emptyTexture2D = emptyTexture;

		}

		textures.setTexture2D( v || emptyTexture2D, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || empty3dTexture, unit );

	}

	function setValueT6( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTextureCube( v || emptyCubeTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyArrayTexture, unit );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1f; // FLOAT
			case 0x8b50: return setValueV2f; // _VEC2
			case 0x8b51: return setValueV3f; // _VEC3
			case 0x8b52: return setValueV4f; // _VEC4

			case 0x8b5a: return setValueM2; // _MAT2
			case 0x8b5b: return setValueM3; // _MAT3
			case 0x8b5c: return setValueM4; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

			case 0x1405: return setValueV1ui; // UINT
			case 0x8dc6: return setValueV2ui; // _VEC2
			case 0x8dc7: return setValueV3ui; // _VEC3
			case 0x8dc8: return setValueV4ui; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;

		}

	}


	// Array of scalars

	function setValueV1fArray( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}

	// Array of vectors (from flat array or array of THREE.VectorN)

	function setValueV2fArray( gl, v ) {

		const data = flatten( v, this.size, 2 );

		gl.uniform2fv( this.addr, data );

	}

	function setValueV3fArray( gl, v ) {

		const data = flatten( v, this.size, 3 );

		gl.uniform3fv( this.addr, data );

	}

	function setValueV4fArray( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniform4fv( this.addr, data );

	}

	// Array of matrices (from flat array or array of THREE.MatrixN)

	function setValueM2Array( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniformMatrix2fv( this.addr, false, data );

	}

	function setValueM3Array( gl, v ) {

		const data = flatten( v, this.size, 9 );

		gl.uniformMatrix3fv( this.addr, false, data );

	}

	function setValueM4Array( gl, v ) {

		const data = flatten( v, this.size, 16 );

		gl.uniformMatrix4fv( this.addr, false, data );

	}

	// Array of integer / boolean

	function setValueV1iArray( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	// Array of integer / boolean vectors (from flat array)

	function setValueV2iArray( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValueV3iArray( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValueV4iArray( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}

	// Array of unsigned integer

	function setValueV1uiArray( gl, v ) {

		gl.uniform1uiv( this.addr, v );

	}

	// Array of unsigned integer vectors (from flat array)

	function setValueV2uiArray( gl, v ) {

		gl.uniform2uiv( this.addr, v );

	}

	function setValueV3uiArray( gl, v ) {

		gl.uniform3uiv( this.addr, v );

	}

	function setValueV4uiArray( gl, v ) {

		gl.uniform4uiv( this.addr, v );

	}


	// Array of textures (2D / 3D / Cube / 2DArray)

	function setValueT1Array( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT3DArray( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

		}

	}

	function setValueT6Array( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	function setValueT2DArrayArray( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

		}

	}


	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1fArray; // FLOAT
			case 0x8b50: return setValueV2fArray; // _VEC2
			case 0x8b51: return setValueV3fArray; // _VEC3
			case 0x8b52: return setValueV4fArray; // _VEC4

			case 0x8b5a: return setValueM2Array; // _MAT2
			case 0x8b5b: return setValueM3Array; // _MAT3
			case 0x8b5c: return setValueM4Array; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

			case 0x1405: return setValueV1uiArray; // UINT
			case 0x8dc6: return setValueV2uiArray; // _VEC2
			case 0x8dc7: return setValueV3uiArray; // _VEC3
			case 0x8dc8: return setValueV4uiArray; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3DArray;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArrayArray;

		}

	}

	// --- Uniform Classes ---

	class SingleUniform {

		constructor( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.type = activeInfo.type;
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

	}

	class PureArrayUniform {

		constructor( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.type = activeInfo.type;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

	}

	class StructuredUniform {

		constructor( id ) {

			this.id = id;

			this.seq = [];
			this.map = {};

		}

		setValue( gl, value, textures ) {

			const seq = this.seq;

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ];
				u.setValue( gl, value[ u.id ], textures );

			}

		}

	}

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart = /(\w+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		const path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			const match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex;

			let id = match[ 1 ];
			const idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				const map = container.map;
				let next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	class WebGLUniforms {

		constructor( gl, program ) {

			this.seq = [];
			this.map = {};

			const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( let i = 0; i < n; ++ i ) {

				const info = gl.getActiveUniform( program, i ),
					addr = gl.getUniformLocation( program, info.name );

				parseUniform( info, addr, this );

			}

		}

		setValue( gl, name, value, textures ) {

			const u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, value, textures );

		}

		setOptional( gl, object, name ) {

			const v = object[ name ];

			if ( v !== undefined ) this.setValue( gl, name, v );

		}

		static upload( gl, seq, values, textures ) {

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ],
					v = values[ u.id ];

				if ( v.needsUpdate !== false ) {

					// note: always updating when .needsUpdate is undefined
					u.setValue( gl, v.value, textures );

				}

			}

		}

		static seqWithValue( seq, values ) {

			const r = [];

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ];
				if ( u.id in values ) r.push( u );

			}

			return r;

		}

	}

	function WebGLShader( gl, type, string ) {

		const shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		return shader;

	}

	// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
	const COMPLETION_STATUS_KHR = 0x91B1;

	let programIdCount = 0;

	function handleSource( string, errorLine ) {

		const lines = string.split( '\n' );
		const lines2 = [];

		const from = Math.max( errorLine - 6, 0 );
		const to = Math.min( errorLine + 6, lines.length );

		for ( let i = from; i < to; i ++ ) {

			const line = i + 1;
			lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

		}

		return lines2.join( '\n' );

	}

	const _m0 = /*@__PURE__*/ new Matrix3();

	function getEncodingComponents( colorSpace ) {

		ColorManagement._getMatrix( _m0, ColorManagement.workingColorSpace, colorSpace );

		const encodingMatrix = `mat3( ${ _m0.elements.map( ( v ) => v.toFixed( 4 ) ) } )`;

		switch ( ColorManagement.getTransfer( colorSpace ) ) {

			case LinearTransfer:
				return [ encodingMatrix, 'LinearTransferOETF' ];

			case SRGBTransfer:
				return [ encodingMatrix, 'sRGBTransferOETF' ];

			default:
				warn( 'WebGLProgram: Unsupported color space: ', colorSpace );
				return [ encodingMatrix, 'LinearTransferOETF' ];

		}

	}

	function getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );

		const shaderInfoLog = gl.getShaderInfoLog( shader ) || '';
		const errors = shaderInfoLog.trim();

		if ( status && errors === '' ) return '';

		const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
		if ( errorMatches ) {

			// --enable-privileged-webgl-extension
			// log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			const errorLine = parseInt( errorMatches[ 1 ] );
			return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

		} else {

			return errors;

		}

	}

	function getTexelEncodingFunction( functionName, colorSpace ) {

		const components = getEncodingComponents( colorSpace );

		return [

			`vec4 ${functionName}( vec4 value ) {`,

			`	return ${components[ 1 ]}( vec4( value.rgb * ${components[ 0 ]}, value.a ) );`,

			'}',

		].join( '\n' );

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		let toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'Cineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case AgXToneMapping:
				toneMappingName = 'AgX';
				break;

			case NeutralToneMapping:
				toneMappingName = 'Neutral';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				warn( 'WebGLProgram: Unsupported toneMapping:', toneMapping );
				toneMappingName = 'Linear';

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	const _v0 = /*@__PURE__*/ new Vector3();

	function getLuminanceFunction() {

		ColorManagement.getLuminanceCoefficients( _v0 );

		const r = _v0.x.toFixed( 4 );
		const g = _v0.y.toFixed( 4 );
		const b = _v0.z.toFixed( 4 );

		return [

			'float luminance( const in vec3 rgb ) {',

			`	const vec3 weights = vec3( ${ r }, ${ g }, ${ b } );`,

			'	return dot( weights, rgb );',

			'}'

		].join( '\n' );

	}

	function generateVertexExtensions( parameters ) {

		const chunks = [
			parameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
			parameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		const chunks = [];

		for ( const name in defines ) {

			const value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		const attributes = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( let i = 0; i < n; i ++ ) {

			const info = gl.getActiveAttrib( program, i );
			const name = info.name;

			let locationSize = 1;
			if ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;
			if ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;
			if ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;

			// log( 'WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = {
				type: info.type,
				location: gl.getAttribLocation( program, name ),
				locationSize: locationSize
			};

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
			.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
			.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
			.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
			.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
			.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	// Resolve Includes

	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes( string ) {

		return string.replace( includePattern, includeReplacer );

	}

	const shaderChunkMap = new Map();

	function includeReplacer( match, include ) {

		let string = ShaderChunk[ include ];

		if ( string === undefined ) {

			const newInclude = shaderChunkMap.get( include );

			if ( newInclude !== undefined ) {

				string = ShaderChunk[ newInclude ];
				warn( 'WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude );

			} else {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

		}

		return resolveIncludes( string );

	}

	// Unroll Loops

	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops( string ) {

		return string.replace( unrollLoopPattern, loopReplacer );

	}

	function loopReplacer( match, start, end, snippet ) {

		let string = '';

		for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

			string += snippet
				.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
				.replace( /UNROLLED_LOOP_INDEX/g, i );

		}

		return string;

	}

	//

	function generatePrecision( parameters ) {

		let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;

		if ( parameters.precision === 'highp' ) {

			precisionstring += '\n#define HIGH_PRECISION';

		} else if ( parameters.precision === 'mediump' ) {

			precisionstring += '\n#define MEDIUM_PRECISION';

		} else if ( parameters.precision === 'lowp' ) {

			precisionstring += '\n#define LOW_PRECISION';

		}

		return precisionstring;

	}

	function generateShadowMapTypeDefine( parameters ) {

		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		} else if ( parameters.shadowMapType === VSMShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

		}

		return shadowMapTypeDefine;

	}

	function generateEnvMapTypeDefine( parameters ) {

		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

			}

		}

		return envMapTypeDefine;

	}

	function generateEnvMapModeDefine( parameters ) {

		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeRefractionMapping:

					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

		}

		return envMapModeDefine;

	}

	function generateEnvMapBlendingDefine( parameters ) {

		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if ( parameters.envMap ) {

			switch ( parameters.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		return envMapBlendingDefine;

	}

	function generateCubeUVSize( parameters ) {

		const imageHeight = parameters.envMapCubeUVHeight;

		if ( imageHeight === null ) return null;

		const maxMip = Math.log2( imageHeight ) - 2;

		const texelHeight = 1.0 / imageHeight;

		const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

		return { texelWidth, texelHeight, maxMip };

	}

	function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

		// TODO Send this event to Three.js DevTools
		// log( 'WebGLProgram', cacheKey );

		const gl = renderer.getContext();

		const defines = parameters.defines;

		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;

		const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
		const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
		const envMapModeDefine = generateEnvMapModeDefine( parameters );
		const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
		const envMapCubeUVSize = generateCubeUVSize( parameters );

		const customVertexExtensions = generateVertexExtensions( parameters );

		const customDefines = generateDefines( defines );

		const program = gl.createProgram();

		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if ( parameters.isRawShaderMaterial ) {

			prefixVertex = [

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				generatePrecision( parameters ),

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
				parameters.batching ? '#define USE_BATCHING' : '',
				parameters.batchingColor ? '#define USE_BATCHING_COLOR' : '',
				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
				parameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',

				parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
				parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
				parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
				parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

				parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
				parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

				//

				parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',
				parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',
				parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',
				parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',
				parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',
				parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',
				parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',
				parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',

				parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',
				parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',

				parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',

				parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',
				parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',
				parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',

				parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',
				parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',

				parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',
				parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',

				parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',
				parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',
				parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',

				parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',
				parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',

				//

				parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUv1s ? '#define USE_UV1' : '',
				parameters.vertexUv2s ? '#define USE_UV2' : '',
				parameters.vertexUv3s ? '#define USE_UV3' : '',

				parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				( parameters.morphColors ) ? '#define USE_MORPHCOLORS' : '',
				( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
				( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGARITHMIC_DEPTH_BUFFER' : '',
				parameters.reversedDepthBuffer ? '#define USE_REVERSED_DEPTH_BUFFER' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'#ifdef USE_INSTANCING_MORPH',

				'	uniform sampler2D morphTexture;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_UV1',

				'	attribute vec2 uv1;',

				'#endif',

				'#ifdef USE_UV2',

				'	attribute vec2 uv2;',

				'#endif',

				'#ifdef USE_UV3',

				'	attribute vec2 uv3;',

				'#endif',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#if defined( USE_COLOR_ALPHA )',

				'	attribute vec4 color;',

				'#elif defined( USE_COLOR )',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				generatePrecision( parameters ),

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
				parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

				parameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
				envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
				parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

				parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
				parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

				parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.dispersion ? '#define USE_DISPERSION' : '',

				parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.alphaTest ? '#define USE_ALPHATEST' : '',
				parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUv1s ? '#define USE_UV1' : '',
				parameters.vertexUv2s ? '#define USE_UV2' : '',
				parameters.vertexUv3s ? '#define USE_UV3' : '',

				parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

				parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
				parameters.decodeVideoTextureEmissive ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGARITHMIC_DEPTH_BUFFER' : '',
				parameters.reversedDepthBuffer ? '#define USE_REVERSED_DEPTH_BUFFER' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',
				parameters.opaque ? '#define OPAQUE' : '',

				ShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
				getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),
				getLuminanceFunction(),

				parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = resolveIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = resolveIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( parameters.isRawShaderMaterial !== true ) {

			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n';

			prefixVertex = [
				customVertexExtensions,
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#define varying in',
				( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
				( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader;

		// log( '*VERTEX*', vertexGlsl );
		// log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( parameters.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		function onFirstUse( self ) {

			// check for link errors
			if ( renderer.debug.checkShaderErrors ) {

				const programInfoLog = gl.getProgramInfoLog( program ) || '';
				const vertexShaderInfoLog = gl.getShaderInfoLog( glVertexShader ) || '';
				const fragmentShaderInfoLog = gl.getShaderInfoLog( glFragmentShader ) || '';

				const programLog = programInfoLog.trim();
				const vertexLog = vertexShaderInfoLog.trim();
				const fragmentLog = fragmentShaderInfoLog.trim();

				let runnable = true;
				let haveDiagnostics = true;

				if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

					runnable = false;

					if ( typeof renderer.debug.onShaderError === 'function' ) {

						renderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );

					} else {

						// default error reporting

						const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
						const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

						error(
							'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
							'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\n\n' +
							'Material Name: ' + self.name + '\n' +
							'Material Type: ' + self.type + '\n\n' +
							'Program Info Log: ' + programLog + '\n' +
							vertexErrors + '\n' +
							fragmentErrors
						);

					}

				} else if ( programLog !== '' ) {

					warn( 'WebGLProgram: Program Info Log:', programLog );

				} else if ( vertexLog === '' || fragmentLog === '' ) {

					haveDiagnostics = false;

				}

				if ( haveDiagnostics ) {

					self.diagnostics = {

						runnable: runnable,

						programLog: programLog,

						vertexShader: {

							log: vertexLog,
							prefix: prefixVertex

						},

						fragmentShader: {

							log: fragmentLog,
							prefix: prefixFragment

						}

					};

				}

			}

			// Clean up

			// Crashes in iOS9 and iOS10. #18402
			// gl.detachShader( program, glVertexShader );
			// gl.detachShader( program, glFragmentShader );

			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );

			cachedUniforms = new WebGLUniforms( gl, program );
			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		// set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				// Populates cachedUniforms and cachedAttributes
				onFirstUse( this );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		let cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				// Populates cachedAttributes and cachedUniforms
				onFirstUse( this );

			}

			return cachedAttributes;

		};

		// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
		// flag the program as ready immediately. It may cause a stall when it's first used.

		let programReady = ( parameters.rendererExtensionParallelShaderCompile === false );

		this.isReady = function () {

			if ( programReady === false ) {

				programReady = gl.getProgramParameter( program, COMPLETION_STATUS_KHR );

			}

			return programReady;

		};

		// free resource

		this.destroy = function () {

			bindingStates.releaseStatesOfProgram( this );

			gl.deleteProgram( program );
			this.program = undefined;

		};

		//

		this.type = parameters.shaderType;
		this.name = parameters.shaderName;
		this.id = programIdCount ++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	let _id = 0;

	class WebGLShaderCache {

		constructor() {

			this.shaderCache = new Map();
			this.materialCache = new Map();

		}

		update( material ) {

			const vertexShader = material.vertexShader;
			const fragmentShader = material.fragmentShader;

			const vertexShaderStage = this._getShaderStage( vertexShader );
			const fragmentShaderStage = this._getShaderStage( fragmentShader );

			const materialShaders = this._getShaderCacheForMaterial( material );

			if ( materialShaders.has( vertexShaderStage ) === false ) {

				materialShaders.add( vertexShaderStage );
				vertexShaderStage.usedTimes ++;

			}

			if ( materialShaders.has( fragmentShaderStage ) === false ) {

				materialShaders.add( fragmentShaderStage );
				fragmentShaderStage.usedTimes ++;

			}

			return this;

		}

		remove( material ) {

			const materialShaders = this.materialCache.get( material );

			for ( const shaderStage of materialShaders ) {

				shaderStage.usedTimes --;

				if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

			}

			this.materialCache.delete( material );

			return this;

		}

		getVertexShaderID( material ) {

			return this._getShaderStage( material.vertexShader ).id;

		}

		getFragmentShaderID( material ) {

			return this._getShaderStage( material.fragmentShader ).id;

		}

		dispose() {

			this.shaderCache.clear();
			this.materialCache.clear();

		}

		_getShaderCacheForMaterial( material ) {

			const cache = this.materialCache;
			let set = cache.get( material );

			if ( set === undefined ) {

				set = new Set();
				cache.set( material, set );

			}

			return set;

		}

		_getShaderStage( code ) {

			const cache = this.shaderCache;
			let stage = cache.get( code );

			if ( stage === undefined ) {

				stage = new WebGLShaderStage( code );
				cache.set( code, stage );

			}

			return stage;

		}

	}

	class WebGLShaderStage {

		constructor( code ) {

			this.id = _id ++;

			this.code = code;
			this.usedTimes = 0;

		}

	}

	function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

		const _programLayers = new Layers();
		const _customShaders = new WebGLShaderCache();
		const _activeChannels = new Set();
		const programs = [];

		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;

		let precision = capabilities.precision;

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		function getChannel( value ) {

			_activeChannels.add( value );

			if ( value === 0 ) return 'uv';

			return `uv${ value }`;

		}

		function getParameters( material, lights, shadows, scene, object ) {

			const fog = scene.fog;
			const geometry = object.geometry;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;

			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

			const shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					warn( 'WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			//

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			let morphTextureStride = 0;

			if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
			if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
			if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

			//

			let vertexShader, fragmentShader;
			let customVertexShaderID, customFragmentShaderID;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];

				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;

			} else {

				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;

				_customShaders.update( material );

				customVertexShaderID = _customShaders.getVertexShaderID( material );
				customFragmentShaderID = _customShaders.getFragmentShaderID( material );

			}

			const currentRenderTarget = renderer.getRenderTarget();
			const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();

			const IS_INSTANCEDMESH = object.isInstancedMesh === true;
			const IS_BATCHEDMESH = object.isBatchedMesh === true;

			const HAS_MAP = !! material.map;
			const HAS_MATCAP = !! material.matcap;
			const HAS_ENVMAP = !! envMap;
			const HAS_AOMAP = !! material.aoMap;
			const HAS_LIGHTMAP = !! material.lightMap;
			const HAS_BUMPMAP = !! material.bumpMap;
			const HAS_NORMALMAP = !! material.normalMap;
			const HAS_DISPLACEMENTMAP = !! material.displacementMap;
			const HAS_EMISSIVEMAP = !! material.emissiveMap;

			const HAS_METALNESSMAP = !! material.metalnessMap;
			const HAS_ROUGHNESSMAP = !! material.roughnessMap;

			const HAS_ANISOTROPY = material.anisotropy > 0;
			const HAS_CLEARCOAT = material.clearcoat > 0;
			const HAS_DISPERSION = material.dispersion > 0;
			const HAS_IRIDESCENCE = material.iridescence > 0;
			const HAS_SHEEN = material.sheen > 0;
			const HAS_TRANSMISSION = material.transmission > 0;

			const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;

			const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;
			const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;
			const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;

			const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;
			const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;

			const HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;
			const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;

			const HAS_SPECULARMAP = !! material.specularMap;
			const HAS_SPECULAR_COLORMAP = !! material.specularColorMap;
			const HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;

			const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;
			const HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;

			const HAS_GRADIENTMAP = !! material.gradientMap;

			const HAS_ALPHAMAP = !! material.alphaMap;

			const HAS_ALPHATEST = material.alphaTest > 0;

			const HAS_ALPHAHASH = !! material.alphaHash;

			const HAS_EXTENSIONS = !! material.extensions;

			let toneMapping = NoToneMapping;

			if ( material.toneMapped ) {

				if ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {

					toneMapping = renderer.toneMapping;

				}

			}

			const parameters = {

				shaderID: shaderID,
				shaderType: material.type,
				shaderName: material.name,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				customVertexShaderID: customVertexShaderID,
				customFragmentShaderID: customFragmentShaderID,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				batching: IS_BATCHEDMESH,
				batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
				instancing: IS_INSTANCEDMESH,
				instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
				instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,

				supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
				outputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),
				alphaToCoverage: !! material.alphaToCoverage,

				map: HAS_MAP,
				matcap: HAS_MATCAP,
				envMap: HAS_ENVMAP,
				envMapMode: HAS_ENVMAP && envMap.mapping,
				envMapCubeUVHeight: envMapCubeUVHeight,
				aoMap: HAS_AOMAP,
				lightMap: HAS_LIGHTMAP,
				bumpMap: HAS_BUMPMAP,
				normalMap: HAS_NORMALMAP,
				displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
				emissiveMap: HAS_EMISSIVEMAP,

				normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
				normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,

				metalnessMap: HAS_METALNESSMAP,
				roughnessMap: HAS_ROUGHNESSMAP,

				anisotropy: HAS_ANISOTROPY,
				anisotropyMap: HAS_ANISOTROPYMAP,

				clearcoat: HAS_CLEARCOAT,
				clearcoatMap: HAS_CLEARCOATMAP,
				clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
				clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,

				dispersion: HAS_DISPERSION,

				iridescence: HAS_IRIDESCENCE,
				iridescenceMap: HAS_IRIDESCENCEMAP,
				iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,

				sheen: HAS_SHEEN,
				sheenColorMap: HAS_SHEEN_COLORMAP,
				sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,

				specularMap: HAS_SPECULARMAP,
				specularColorMap: HAS_SPECULAR_COLORMAP,
				specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,

				transmission: HAS_TRANSMISSION,
				transmissionMap: HAS_TRANSMISSIONMAP,
				thicknessMap: HAS_THICKNESSMAP,

				gradientMap: HAS_GRADIENTMAP,

				opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,

				alphaMap: HAS_ALPHAMAP,
				alphaTest: HAS_ALPHATEST,
				alphaHash: HAS_ALPHAHASH,

				combine: material.combine,

				//

				mapUv: HAS_MAP && getChannel( material.map.channel ),
				aoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),
				lightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),
				bumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),
				normalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),
				displacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),
				emissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),

				metalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),
				roughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),

				anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),

				clearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),
				clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),
				clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),

				iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),
				iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),

				sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),
				sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),

				specularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),
				specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),
				specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),

				transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),
				thicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),

				alphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),

				//

				vertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,

				pointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),

				fog: !! fog,
				useFog: material.fog === true,
				fogExp2: ( !! fog && fog.isFogExp2 ),

				flatShading: ( material.flatShading === true && material.wireframe === false ),

				sizeAttenuation: material.sizeAttenuation === true,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
				reversedDepthBuffer: reversedDepthBuffer,

				skinning: object.isSkinnedMesh === true,

				morphTargets: geometry.morphAttributes.position !== undefined,
				morphNormals: geometry.morphAttributes.normal !== undefined,
				morphColors: geometry.morphAttributes.color !== undefined,
				morphTargetsCount: morphTargetsCount,
				morphTextureStride: morphTextureStride,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numSpotLightMaps: lights.spotLightMap.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

				numLightProbes: lights.numLightProbes,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: toneMapping,

				decodeVideoTexture: HAS_MAP && ( material.map.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.map.colorSpace ) === SRGBTransfer ),
				decodeVideoTextureEmissive: HAS_EMISSIVEMAP && ( material.emissiveMap.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.emissiveMap.colorSpace ) === SRGBTransfer ),

				premultipliedAlpha: material.premultipliedAlpha,

				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				useDepthPacking: material.depthPacking >= 0,
				depthPacking: material.depthPacking || 0,

				index0AttributeName: material.index0AttributeName,

				extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has( 'WEBGL_clip_cull_distance' ),
				extensionMultiDraw: ( HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH ) && extensions.has( 'WEBGL_multi_draw' ),

				rendererExtensionParallelShaderCompile: extensions.has( 'KHR_parallel_shader_compile' ),

				customProgramCacheKey: material.customProgramCacheKey()

			};

			// the usage of getChannel() determines the active texture channels for this shader

			parameters.vertexUv1s = _activeChannels.has( 1 );
			parameters.vertexUv2s = _activeChannels.has( 2 );
			parameters.vertexUv3s = _activeChannels.has( 3 );

			_activeChannels.clear();

			return parameters;

		}

		function getProgramCacheKey( parameters ) {

			const array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( parameters.customVertexShaderID );
				array.push( parameters.customFragmentShaderID );

			}

			if ( parameters.defines !== undefined ) {

				for ( const name in parameters.defines ) {

					array.push( name );
					array.push( parameters.defines[ name ] );

				}

			}

			if ( parameters.isRawShaderMaterial === false ) {

				getProgramCacheKeyParameters( array, parameters );
				getProgramCacheKeyBooleans( array, parameters );
				array.push( renderer.outputColorSpace );

			}

			array.push( parameters.customProgramCacheKey );

			return array.join();

		}

		function getProgramCacheKeyParameters( array, parameters ) {

			array.push( parameters.precision );
			array.push( parameters.outputColorSpace );
			array.push( parameters.envMapMode );
			array.push( parameters.envMapCubeUVHeight );
			array.push( parameters.mapUv );
			array.push( parameters.alphaMapUv );
			array.push( parameters.lightMapUv );
			array.push( parameters.aoMapUv );
			array.push( parameters.bumpMapUv );
			array.push( parameters.normalMapUv );
			array.push( parameters.displacementMapUv );
			array.push( parameters.emissiveMapUv );
			array.push( parameters.metalnessMapUv );
			array.push( parameters.roughnessMapUv );
			array.push( parameters.anisotropyMapUv );
			array.push( parameters.clearcoatMapUv );
			array.push( parameters.clearcoatNormalMapUv );
			array.push( parameters.clearcoatRoughnessMapUv );
			array.push( parameters.iridescenceMapUv );
			array.push( parameters.iridescenceThicknessMapUv );
			array.push( parameters.sheenColorMapUv );
			array.push( parameters.sheenRoughnessMapUv );
			array.push( parameters.specularMapUv );
			array.push( parameters.specularColorMapUv );
			array.push( parameters.specularIntensityMapUv );
			array.push( parameters.transmissionMapUv );
			array.push( parameters.thicknessMapUv );
			array.push( parameters.combine );
			array.push( parameters.fogExp2 );
			array.push( parameters.sizeAttenuation );
			array.push( parameters.morphTargetsCount );
			array.push( parameters.morphAttributeCount );
			array.push( parameters.numDirLights );
			array.push( parameters.numPointLights );
			array.push( parameters.numSpotLights );
			array.push( parameters.numSpotLightMaps );
			array.push( parameters.numHemiLights );
			array.push( parameters.numRectAreaLights );
			array.push( parameters.numDirLightShadows );
			array.push( parameters.numPointLightShadows );
			array.push( parameters.numSpotLightShadows );
			array.push( parameters.numSpotLightShadowsWithMaps );
			array.push( parameters.numLightProbes );
			array.push( parameters.shadowMapType );
			array.push( parameters.toneMapping );
			array.push( parameters.numClippingPlanes );
			array.push( parameters.numClipIntersection );
			array.push( parameters.depthPacking );

		}

		function getProgramCacheKeyBooleans( array, parameters ) {

			_programLayers.disableAll();

			if ( parameters.supportsVertexTextures )
				_programLayers.enable( 0 );
			if ( parameters.instancing )
				_programLayers.enable( 1 );
			if ( parameters.instancingColor )
				_programLayers.enable( 2 );
			if ( parameters.instancingMorph )
				_programLayers.enable( 3 );
			if ( parameters.matcap )
				_programLayers.enable( 4 );
			if ( parameters.envMap )
				_programLayers.enable( 5 );
			if ( parameters.normalMapObjectSpace )
				_programLayers.enable( 6 );
			if ( parameters.normalMapTangentSpace )
				_programLayers.enable( 7 );
			if ( parameters.clearcoat )
				_programLayers.enable( 8 );
			if ( parameters.iridescence )
				_programLayers.enable( 9 );
			if ( parameters.alphaTest )
				_programLayers.enable( 10 );
			if ( parameters.vertexColors )
				_programLayers.enable( 11 );
			if ( parameters.vertexAlphas )
				_programLayers.enable( 12 );
			if ( parameters.vertexUv1s )
				_programLayers.enable( 13 );
			if ( parameters.vertexUv2s )
				_programLayers.enable( 14 );
			if ( parameters.vertexUv3s )
				_programLayers.enable( 15 );
			if ( parameters.vertexTangents )
				_programLayers.enable( 16 );
			if ( parameters.anisotropy )
				_programLayers.enable( 17 );
			if ( parameters.alphaHash )
				_programLayers.enable( 18 );
			if ( parameters.batching )
				_programLayers.enable( 19 );
			if ( parameters.dispersion )
				_programLayers.enable( 20 );
			if ( parameters.batchingColor )
				_programLayers.enable( 21 );
			if ( parameters.gradientMap )
				_programLayers.enable( 22 );

			array.push( _programLayers.mask );
			_programLayers.disableAll();

			if ( parameters.fog )
				_programLayers.enable( 0 );
			if ( parameters.useFog )
				_programLayers.enable( 1 );
			if ( parameters.flatShading )
				_programLayers.enable( 2 );
			if ( parameters.logarithmicDepthBuffer )
				_programLayers.enable( 3 );
			if ( parameters.reversedDepthBuffer )
				_programLayers.enable( 4 );
			if ( parameters.skinning )
				_programLayers.enable( 5 );
			if ( parameters.morphTargets )
				_programLayers.enable( 6 );
			if ( parameters.morphNormals )
				_programLayers.enable( 7 );
			if ( parameters.morphColors )
				_programLayers.enable( 8 );
			if ( parameters.premultipliedAlpha )
				_programLayers.enable( 9 );
			if ( parameters.shadowMapEnabled )
				_programLayers.enable( 10 );
			if ( parameters.doubleSided )
				_programLayers.enable( 11 );
			if ( parameters.flipSided )
				_programLayers.enable( 12 );
			if ( parameters.useDepthPacking )
				_programLayers.enable( 13 );
			if ( parameters.dithering )
				_programLayers.enable( 14 );
			if ( parameters.transmission )
				_programLayers.enable( 15 );
			if ( parameters.sheen )
				_programLayers.enable( 16 );
			if ( parameters.opaque )
				_programLayers.enable( 17 );
			if ( parameters.pointsUvs )
				_programLayers.enable( 18 );
			if ( parameters.decodeVideoTexture )
				_programLayers.enable( 19 );
			if ( parameters.decodeVideoTextureEmissive )
				_programLayers.enable( 20 );
			if ( parameters.alphaToCoverage )
				_programLayers.enable( 21 );

			array.push( _programLayers.mask );

		}

		function getUniforms( material ) {

			const shaderID = shaderIDs[ material.type ];
			let uniforms;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];
				uniforms = UniformsUtils.clone( shader.uniforms );

			} else {

				uniforms = material.uniforms;

			}

			return uniforms;

		}

		function acquireProgram( parameters, cacheKey ) {

			let program;

			// Check if code has been already compiled
			for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

				const preexistingProgram = programs[ p ];

				if ( preexistingProgram.cacheKey === cacheKey ) {

					program = preexistingProgram;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
				programs.push( program );

			}

			return program;

		}

		function releaseProgram( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				const i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		}

		function releaseShaderCache( material ) {

			_customShaders.remove( material );

		}

		function dispose() {

			_customShaders.dispose();

		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			releaseShaderCache: releaseShaderCache,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs,
			dispose: dispose
		};

	}

	function WebGLProperties() {

		let properties = new WeakMap();

		function has( object ) {

			return properties.has( object );

		}

		function get( object ) {

			let map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			has: has,
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList() {

		const renderItems = [];
		let renderItemsIndex = 0;

		const opaque = [];
		const transmissive = [];
		const transparent = [];

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			let renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.push( renderItem );

			} else if ( material.transparent === true ) {

				transparent.push( renderItem );

			} else {

				opaque.push( renderItem );

			}

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.unshift( renderItem );

			} else if ( material.transparent === true ) {

				transparent.unshift( renderItem );

			} else {

				opaque.unshift( renderItem );

			}

		}

		function sort( customOpaqueSort, customTransparentSort ) {

			if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
			if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
			if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

		}

		function finish() {

			// Clear references from inactive renderItems in the list

			for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

				const renderItem = renderItems[ i ];

				if ( renderItem.id === null ) break;

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.group = null;

			}

		}

		return {

			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		let lists = new WeakMap();

		function get( scene, renderCallDepth ) {

			const listArray = lists.get( scene );
			let list;

			if ( listArray === undefined ) {

				list = new WebGLRenderList();
				lists.set( scene, [ list ] );

			} else {

				if ( renderCallDepth >= listArray.length ) {

					list = new WebGLRenderList();
					listArray.push( list );

				} else {

					list = listArray[ renderCallDepth ];

				}

			}

			return list;

		}

		function dispose() {

			lists = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function UniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	function ShadowUniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							shadowIntensity: 1,
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowIntensity: 1,
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowIntensity: 1,
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					// TODO (abelnation): set RectAreaLight shadow uniforms

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}



	let nextVersion = 0;

	function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

		return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

	}

	function WebGLLights( extensions ) {

		const cache = new UniformsCache();

		const shadowCache = ShadowUniformsCache();

		const state = {

			version: 0,

			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,

				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1,
				numSpotMaps: -1,

				numLightProbes: -1
			},

			ambient: [ 0, 0, 0 ],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotLightMap: [],
			spotShadow: [],
			spotShadowMap: [],
			spotLightMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
			numSpotLightShadowsWithMaps: 0,
			numLightProbes: 0

		};

		for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup( lights ) {

			let r = 0, g = 0, b = 0;

			for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;
			let numSpotMaps = 0;
			let numSpotShadowsWithMaps = 0;

			let numLightProbes = 0;

			// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
			lights.sort( shadowCastingAndTexturingLightsFirst );

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;

				const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isLightProbe ) {

					for ( let j = 0; j < 9; j ++ ) {

						state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

					}

					numLightProbes ++;

				} else if ( light.isDirectionalLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowIntensity = shadow.intensity;
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.directionalShadow[ directionalLength ] = shadowUniforms;
						state.directionalShadowMap[ directionalLength ] = shadowMap;
						state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

						numDirectionalShadows ++;

					}

					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );

					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;

					state.spot[ spotLength ] = uniforms;

					const shadow = light.shadow;

					if ( light.map ) {

						state.spotLightMap[ numSpotMaps ] = light.map;
						numSpotMaps ++;

						// make sure the lightMatrix is up to date
						// TODO : do it if required only
						shadow.updateMatrices( light );

						if ( light.castShadow ) numSpotShadowsWithMaps ++;

					}

					state.spotLightMatrix[ spotLength ] = shadow.matrix;

					if ( light.castShadow ) {

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowIntensity = shadow.intensity;
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.spotShadow[ spotLength ] = shadowUniforms;
						state.spotShadowMap[ spotLength ] = shadowMap;

						numSpotShadows ++;

					}

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowIntensity = shadow.intensity;
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;

						state.pointShadow[ pointLength ] = shadowUniforms;
						state.pointShadowMap[ pointLength ] = shadowMap;
						state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

						numPointShadows ++;

					}

					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = cache.get( light );

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			if ( rectAreaLength > 0 ) {

				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else {

					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			const hash = state.hash;

			if ( hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ||
				hash.numSpotMaps !== numSpotMaps ||
				hash.numLightProbes !== numLightProbes ) {

				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;

				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
				state.spotLightMap.length = numSpotMaps;
				state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
				state.numLightProbes = numLightProbes;

				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;

				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				hash.numSpotMaps = numSpotMaps;

				hash.numLightProbes = numLightProbes;

				state.version = nextVersion ++;

			}

		}

		function setupView( lights, camera ) {

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			const viewMatrix = camera.matrixWorldInverse;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				if ( light.isDirectionalLight ) {

					const uniforms = state.directional[ directionalLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = state.spot[ spotLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = state.rectArea[ rectAreaLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = state.point[ pointLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = state.hemi[ hemiLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );

					hemiLength ++;

				}

			}

		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};

	}

	function WebGLRenderState( extensions ) {

		const lights = new WebGLLights( extensions );

		const lightsArray = [];
		const shadowsArray = [];

		function init( camera ) {

			state.camera = camera;

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights() {

			lights.setup( lightsArray );

		}

		function setupLightsView( camera ) {

			lights.setupView( lightsArray, camera );

		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			camera: null,

			lights: lights,

			transmissionRenderTarget: {}
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates( extensions ) {

		let renderStates = new WeakMap();

		function get( scene, renderCallDepth = 0 ) {

			const renderStateArray = renderStates.get( scene );
			let renderState;

			if ( renderStateArray === undefined ) {

				renderState = new WebGLRenderState( extensions );
				renderStates.set( scene, [ renderState ] );

			} else {

				if ( renderCallDepth >= renderStateArray.length ) {

					renderState = new WebGLRenderState( extensions );
					renderStateArray.push( renderState );

				} else {

					renderState = renderStateArray[ renderCallDepth ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * A material for drawing geometry by depth. Depth is based off of the camera
	 * near and far plane. White is nearest, black is farthest.
	 *
	 * @augments Material
	 */
	class MeshDepthMaterial extends Material$1 {

		/**
		 * Constructs a new mesh depth material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */
		constructor( parameters ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMeshDepthMaterial = true;

			this.type = 'MeshDepthMaterial';

			/**
			 * Type for depth packing.
			 *
			 * @type {(BasicDepthPacking|RGBADepthPacking|RGBDepthPacking|RGDepthPacking)}
			 * @default BasicDepthPacking
			 */
			this.depthPacking = BasicDepthPacking;

			/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.map = null;

			/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.alphaMap = null;

			/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.displacementMap = null;

			/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementScale = 1;

			/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementBias = 0;

			/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.wireframe = false;

			/**
			 * Controls the thickness of the wireframe.
			 *
			 * WebGL and WebGPU ignore this property and always render
			 * 1 pixel wide lines.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.wireframeLinewidth = 1;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.depthPacking = source.depthPacking;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		}

	}

	/**
	 * A material used internally for implementing shadow mapping with
	 * point lights.
	 *
	 * Can also be used to customize the shadow casting of an object by assigning
	 * an instance of `MeshDistanceMaterial` to {@link Object3D#customDistanceMaterial}.
	 * The following examples demonstrates this approach in order to ensure
	 * transparent parts of objects do not cast shadows.
	 *
	 * @augments Material
	 */
	class MeshDistanceMaterial extends Material$1 {

		/**
		 * Constructs a new mesh distance material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */
		constructor( parameters ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMeshDistanceMaterial = true;

			this.type = 'MeshDistanceMaterial';

			/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.map = null;

			/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.alphaMap = null;

			/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.displacementMap = null;

			/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementScale = 1;

			/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementBias = 0;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			return this;

		}

	}

	const vertex = /* glsl */`
void main() {

	gl_Position = vec4( position, 1.0 );

}
`;

	const fragment = /* glsl */`
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	const float samples = float( VSM_SAMPLES );

	float mean = 0.0;
	float squared_mean = 0.0;

	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {

		float uvOffset = uvStart + i * uvStride;

		#ifdef HORIZONTAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean / samples;
	squared_mean = squared_mean / samples;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`;

	function WebGLShadowMap( renderer, objects, capabilities ) {

		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),

			_viewport = new Vector4(),

			_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
			_distanceMaterial = new MeshDistanceMaterial(),

			_materialCache = {},

			_maxTextureSize = capabilities.maxTextureSize;

		const shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };

		const shadowMaterialVertical = new ShaderMaterial( {
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vertex,
			fragmentShader: fragment

		} );

		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array( [ -1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5 ] ),
				3
			)
		);

		const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

		const scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;
		let _previousType = this.type;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			const currentRenderTarget = renderer.getRenderTarget();
			const activeCubeFace = renderer.getActiveCubeFace();
			const activeMipmapLevel = renderer.getActiveMipmapLevel();

			const _state = renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );

			if ( _state.buffers.depth.getReversed() === true ) {

				_state.buffers.color.setClear( 0, 0, 0, 0 );

			} else {

				_state.buffers.color.setClear( 1, 1, 1, 1 );

			}

			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// check for shadow map type changes

			const toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );
			const fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );

			// render depth map

			for ( let i = 0, il = lights.length; i < il; i ++ ) {

				const light = lights[ i ];
				const shadow = light.shadow;

				if ( shadow === undefined ) {

					warn( 'WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

				_shadowMapSize.copy( shadow.mapSize );

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply( shadowFrameExtents );

				_viewportSize.copy( shadow.mapSize );

				if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

					if ( _shadowMapSize.x > _maxTextureSize ) {

						_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;

					}

					if ( _shadowMapSize.y > _maxTextureSize ) {

						_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;

					}

				}

				if ( shadow.map === null || toVSM === true || fromVSM === true ) {

					const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

					if ( shadow.map !== null ) {

						shadow.map.dispose();

					}

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.camera.updateProjectionMatrix();

				}

				renderer.setRenderTarget( shadow.map );
				renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for ( let vp = 0; vp < viewportCount; vp ++ ) {

					const viewport = shadow.getViewport( vp );

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);

					_state.viewport( _viewport );

					shadow.updateMatrices( light, vp );

					_frustum = shadow.getFrustum();

					renderObject( scene, camera, shadow.camera, light, this.type );

				}

				// do blur pass for VSM

				if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

					VSMPass( shadow, camera );

				}

				shadow.needsUpdate = false;

			}

			_previousType = this.type;

			scope.needsUpdate = false;

			renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

		};

		function VSMPass( shadow, camera ) {

			const geometry = objects.update( fullScreenMesh );

			if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

				shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
				shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

				shadowMaterialVertical.needsUpdate = true;
				shadowMaterialHorizontal.needsUpdate = true;

			}

			if ( shadow.mapPass === null ) {

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

			}

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			renderer.setRenderTarget( shadow.mapPass );
			renderer.clear();
			renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			renderer.setRenderTarget( shadow.map );
			renderer.clear();
			renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

		}

		function getDepthMaterial( object, material, light, type ) {

			let result = null;

			const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

			if ( customMaterial !== undefined ) {

				result = customMaterial;

			} else {

				result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

				if ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
					( material.displacementMap && material.displacementScale !== 0 ) ||
					( material.alphaMap && material.alphaTest > 0 ) ||
					( material.map && material.alphaTest > 0 ) ||
					( material.alphaToCoverage === true ) ) {

					// in this case we need a unique material instance reflecting the
					// appropriate state

					const keyA = result.uuid, keyB = material.uuid;

					let materialsForVariant = _materialCache[ keyA ];

					if ( materialsForVariant === undefined ) {

						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;

					}

					let cachedMaterial = materialsForVariant[ keyB ];

					if ( cachedMaterial === undefined ) {

						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;
						material.addEventListener( 'dispose', onMaterialDispose );

					}

					result = cachedMaterial;

				}

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if ( type === VSMShadowMap ) {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

			} else {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

			}

			result.alphaMap = material.alphaMap;
			result.alphaTest = ( material.alphaToCoverage === true ) ? 0.5 : material.alphaTest; // approximate alphaToCoverage by using a fixed alphaTest value
			result.map = material.map;

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.displacementMap = material.displacementMap;
			result.displacementScale = material.displacementScale;
			result.displacementBias = material.displacementBias;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

				const materialProperties = renderer.properties.get( result );
				materialProperties.light = light;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, light, type ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					const geometry = objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

							const group = groups[ k ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								const depthMaterial = getDepthMaterial( object, groupMaterial, light, type );

								object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

								renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

								object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

							}

						}

					} else if ( material.visible ) {

						const depthMaterial = getDepthMaterial( object, material, light, type );

						object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

						renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

						object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, light, type );

			}

		}

		function onMaterialDispose( event ) {

			const material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			// make sure to remove the unique distance/depth materials used for shadow map rendering

			for ( const id in _materialCache ) {

				const cache = _materialCache[ id ];

				const uuid = event.target.uuid;

				if ( uuid in cache ) {

					const shadowMaterial = cache[ uuid ];
					shadowMaterial.dispose();
					delete cache[ uuid ];

				}

			}

		}

	}

	const reversedFuncs = {
		[ NeverDepth ]: AlwaysDepth,
		[ LessDepth ]: GreaterDepth,
		[ EqualDepth ]: NotEqualDepth,
		[ LessEqualDepth ]: GreaterEqualDepth,

		[ AlwaysDepth ]: NeverDepth,
		[ GreaterDepth ]: LessDepth,
		[ NotEqualDepth ]: EqualDepth,
		[ GreaterEqualDepth ]: LessEqualDepth,
	};

	function WebGLState( gl, extensions ) {

		function ColorBuffer() {

			let locked = false;

			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( -1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			let locked = false;

			let currentReversed = false;
			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;

			return {

				setReversed: function ( reversed ) {

					if ( currentReversed !== reversed ) {

						const ext = extensions.get( 'EXT_clip_control' );

						if ( reversed ) {

							ext.clipControlEXT( ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT );

						} else {

							ext.clipControlEXT( ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT );

						}

						currentReversed = reversed;

						const oldDepth = currentDepthClear;
						currentDepthClear = null;
						this.setClear( oldDepth );

					}

				},

				getReversed: function () {

					return currentReversed;

				},

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( gl.DEPTH_TEST );

					} else {

						disable( gl.DEPTH_TEST );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentReversed ) depthFunc = reversedFuncs[ depthFunc ];

					if ( currentDepthFunc !== depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( gl.NEVER );
								break;

							case AlwaysDepth:

								gl.depthFunc( gl.ALWAYS );
								break;

							case LessDepth:

								gl.depthFunc( gl.LESS );
								break;

							case LessEqualDepth:

								gl.depthFunc( gl.LEQUAL );
								break;

							case EqualDepth:

								gl.depthFunc( gl.EQUAL );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( gl.GEQUAL );
								break;

							case GreaterDepth:

								gl.depthFunc( gl.GREATER );
								break;

							case NotEqualDepth:

								gl.depthFunc( gl.NOTEQUAL );
								break;

							default:

								gl.depthFunc( gl.LEQUAL );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						if ( currentReversed ) {

							depth = 1 - depth;

						}

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
					currentReversed = false;

				}

			};

		}

		function StencilBuffer() {

			let locked = false;

			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( ! locked ) {

						if ( stencilTest ) {

							enable( gl.STENCIL_TEST );

						} else {

							disable( gl.STENCIL_TEST );

						}

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef !== stencilRef ||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail !== stencilFail ||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();

		const uboBindings = new WeakMap();
		const uboProgramMap = new WeakMap();

		let enabledCapabilities = {};

		let currentBoundFramebuffers = {};
		let currentDrawbuffers = new WeakMap();
		let defaultDrawbuffers = [];

		let currentProgram = null;

		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentBlendColor = new Color( 0, 0, 0 );
		let currentBlendAlpha = 0;
		let currentPremultipledAlpha = false;

		let currentFlipSided = null;
		let currentCullFace = null;

		let currentLineWidth = null;

		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;

		const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter( gl.VERSION );

		if ( glVersion.indexOf( 'WebGL' ) !== -1 ) {

			version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== -1 ) {

			version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};

		const scissorParam = gl.getParameter( gl.SCISSOR_BOX );
		const viewportParam = gl.getParameter( gl.VIEWPORT );

		const currentScissor = new Vector4().fromArray( scissorParam );
		const currentViewport = new Vector4().fromArray( viewportParam );

		function createTexture( type, target, count, dimensions ) {

			const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			for ( let i = 0; i < count; i ++ ) {

				if ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) {

					gl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

				} else {

					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

				}

			}

			return texture;

		}

		const emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
		emptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );
		emptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		setBlending( NoBlending );

		//

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function bindFramebuffer( target, framebuffer ) {

			if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

				gl.bindFramebuffer( target, framebuffer );

				currentBoundFramebuffers[ target ] = framebuffer;

				// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

				if ( target === gl.DRAW_FRAMEBUFFER ) {

					currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

				}

				if ( target === gl.FRAMEBUFFER ) {

					currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

				}

				return true;

			}

			return false;

		}

		function drawBuffers( renderTarget, framebuffer ) {

			let drawBuffers = defaultDrawbuffers;

			let needsUpdate = false;

			if ( renderTarget ) {

				drawBuffers = currentDrawbuffers.get( framebuffer );

				if ( drawBuffers === undefined ) {

					drawBuffers = [];
					currentDrawbuffers.set( framebuffer, drawBuffers );

				}

				const textures = renderTarget.textures;

				if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

					for ( let i = 0, il = textures.length; i < il; i ++ ) {

						drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

					}

					drawBuffers.length = textures.length;

					needsUpdate = true;

				}

			} else {

				if ( drawBuffers[ 0 ] !== gl.BACK ) {

					drawBuffers[ 0 ] = gl.BACK;

					needsUpdate = true;

				}

			}

			if ( needsUpdate ) {

				gl.drawBuffers( drawBuffers );

			}

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		const equationToGL = {
			[ AddEquation ]: gl.FUNC_ADD,
			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
		};

		equationToGL[ MinEquation ] = gl.MIN;
		equationToGL[ MaxEquation ] = gl.MAX;

		const factorToGL = {
			[ ZeroFactor ]: gl.ZERO,
			[ OneFactor ]: gl.ONE,
			[ SrcColorFactor ]: gl.SRC_COLOR,
			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
			[ DstColorFactor ]: gl.DST_COLOR,
			[ DstAlphaFactor ]: gl.DST_ALPHA,
			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA,
			[ ConstantColorFactor ]: gl.CONSTANT_COLOR,
			[ OneMinusConstantColorFactor ]: gl.ONE_MINUS_CONSTANT_COLOR,
			[ ConstantAlphaFactor ]: gl.CONSTANT_ALPHA,
			[ OneMinusConstantAlphaFactor ]: gl.ONE_MINUS_CONSTANT_ALPHA
		};

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled === true ) {

					disable( gl.BLEND );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( currentBlendingEnabled === false ) {

				enable( gl.BLEND );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( gl.FUNC_ADD );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFunc( gl.ONE, gl.ONE );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE );
								break;

							default:
								error( 'WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE );
								break;

							case SubtractiveBlending:
								error( 'WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true' );
								break;

							case MultiplyBlending:
								error( 'WebGLState: MultiplyBlending requires material.premultipliedAlpha = true' );
								break;

							default:
								error( 'WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
					currentBlendColor.set( 0, 0, 0 );
					currentBlendAlpha = 0;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			if ( blendColor.equals( currentBlendColor ) === false || blendAlpha !== currentBlendAlpha ) {

				gl.blendColor( blendColor.r, blendColor.g, blendColor.b, blendAlpha );

				currentBlendColor.copy( blendColor );
				currentBlendAlpha = blendAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = false;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );

			let flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest( stencilWrite );
			if ( stencilWrite ) {

				stencilBuffer.setMask( material.stencilWriteMask );
				stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
				stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

			}

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			material.alphaToCoverage === true
				? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
				: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( gl.CULL_FACE );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( gl.BACK );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( gl.FRONT );

					} else {

						gl.cullFace( gl.FRONT_AND_BACK );

					}

				}

			} else {

				disable( gl.CULL_FACE );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( gl.POLYGON_OFFSET_FILL );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( gl.POLYGON_OFFSET_FILL );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( gl.SCISSOR_TEST );

			} else {

				disable( gl.SCISSOR_TEST );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture, webglSlot ) {

			if ( webglSlot === undefined ) {

				if ( currentTextureSlot === null ) {

					webglSlot = gl.TEXTURE0 + maxTextures - 1;

				} else {

					webglSlot = currentTextureSlot;

				}

			}

			let boundTexture = currentBoundTextures[ webglSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ webglSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				if ( currentTextureSlot !== webglSlot ) {

					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;

				}

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function unbindTexture() {

			const boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

				gl.bindTexture( boundTexture.type, null );

				boundTexture.type = undefined;
				boundTexture.texture = undefined;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		function compressedTexImage3D() {

			try {

				gl.compressedTexImage3D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		function texSubImage2D() {

			try {

				gl.texSubImage2D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		function texSubImage3D() {

			try {

				gl.texSubImage3D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		function compressedTexSubImage2D() {

			try {

				gl.compressedTexSubImage2D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		function compressedTexSubImage3D() {

			try {

				gl.compressedTexSubImage3D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		function texStorage2D() {

			try {

				gl.texStorage2D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		function texStorage3D() {

			try {

				gl.texStorage3D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D( ...arguments );

			} catch ( error ) {

				error( 'WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		function updateUBOMapping( uniformsGroup, program ) {

			let mapping = uboProgramMap.get( program );

			if ( mapping === undefined ) {

				mapping = new WeakMap();

				uboProgramMap.set( program, mapping );

			}

			let blockIndex = mapping.get( uniformsGroup );

			if ( blockIndex === undefined ) {

				blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

				mapping.set( uniformsGroup, blockIndex );

			}

		}

		function uniformBlockBinding( uniformsGroup, program ) {

			const mapping = uboProgramMap.get( program );
			const blockIndex = mapping.get( uniformsGroup );

			if ( uboBindings.get( program ) !== blockIndex ) {

				// bind shader specific block index to global block point
				gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

				uboBindings.set( program, blockIndex );

			}

		}

		//

		function reset() {

			// reset state

			gl.disable( gl.BLEND );
			gl.disable( gl.CULL_FACE );
			gl.disable( gl.DEPTH_TEST );
			gl.disable( gl.POLYGON_OFFSET_FILL );
			gl.disable( gl.SCISSOR_TEST );
			gl.disable( gl.STENCIL_TEST );
			gl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.ONE, gl.ZERO );
			gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );
			gl.blendColor( 0, 0, 0, 0 );

			gl.colorMask( true, true, true, true );
			gl.clearColor( 0, 0, 0, 0 );

			gl.depthMask( true );
			gl.depthFunc( gl.LESS );

			depthBuffer.setReversed( false );

			gl.clearDepth( 1 );

			gl.stencilMask( 0xffffffff );
			gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
			gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
			gl.clearStencil( 0 );

			gl.cullFace( gl.BACK );
			gl.frontFace( gl.CCW );

			gl.polygonOffset( 0, 0 );

			gl.activeTexture( gl.TEXTURE0 );

			gl.bindFramebuffer( gl.FRAMEBUFFER, null );
			gl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );
			gl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );

			gl.useProgram( null );

			gl.lineWidth( 1 );

			gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
			gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

			// reset internals

			enabledCapabilities = {};

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentBoundFramebuffers = {};
			currentDrawbuffers = new WeakMap();
			defaultDrawbuffers = [];

			currentProgram = null;

			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentBlendColor = new Color( 0, 0, 0 );
			currentBlendAlpha = 0;
			currentPremultipledAlpha = false;

			currentFlipSided = null;
			currentCullFace = null;

			currentLineWidth = null;

			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;

			currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
			currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			bindFramebuffer: bindFramebuffer,
			drawBuffers: drawBuffers,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			compressedTexImage3D: compressedTexImage3D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			updateUBOMapping: updateUBOMapping,
			uniformBlockBinding: uniformBlockBinding,

			texStorage2D: texStorage2D,
			texStorage3D: texStorage3D,
			texSubImage2D: texSubImage2D,
			texSubImage3D: texSubImage3D,
			compressedTexSubImage2D: compressedTexSubImage2D,
			compressedTexSubImage3D: compressedTexSubImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	/**
	 * Determines how many bytes must be used to represent the texture.
	 *
	 * @param {number} width - The width of the texture.
	 * @param {number} height - The height of the texture.
	 * @param {number} format - The texture's format.
	 * @param {number} type - The texture's type.
	 * @return {number} The byte length.
	 */
	function getByteLength( width, height, format, type ) {

		const typeByteLength = getTextureTypeByteLength( type );

		switch ( format ) {

			// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
			case AlphaFormat:
				return width * height;
			case RedFormat:
				return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
			case RedIntegerFormat:
				return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
			case RGFormat:
				return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
			case RGIntegerFormat:
				return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
			case RGBFormat:
				return ( ( width * height * 3 ) / typeByteLength.components ) * typeByteLength.byteLength;
			case RGBAFormat:
				return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;
			case RGBAIntegerFormat:
				return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;

			// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
			case RGB_S3TC_DXT1_Format:
			case RGBA_S3TC_DXT1_Format:
				return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
			case RGBA_S3TC_DXT3_Format:
			case RGBA_S3TC_DXT5_Format:
				return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

			// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
			case RGB_PVRTC_2BPPV1_Format:
			case RGBA_PVRTC_2BPPV1_Format:
				return ( Math.max( width, 16 ) * Math.max( height, 8 ) ) / 4;
			case RGB_PVRTC_4BPPV1_Format:
			case RGBA_PVRTC_4BPPV1_Format:
				return ( Math.max( width, 8 ) * Math.max( height, 8 ) ) / 2;

			// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
			case RGB_ETC1_Format:
			case RGB_ETC2_Format:
				return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
			case RGBA_ETC2_EAC_Format:
				return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

			// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
			case RGBA_ASTC_4x4_Format:
				return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
			case RGBA_ASTC_5x4_Format:
				return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
			case RGBA_ASTC_5x5_Format:
				return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
			case RGBA_ASTC_6x5_Format:
				return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
			case RGBA_ASTC_6x6_Format:
				return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
			case RGBA_ASTC_8x5_Format:
				return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
			case RGBA_ASTC_8x6_Format:
				return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
			case RGBA_ASTC_8x8_Format:
				return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
			case RGBA_ASTC_10x5_Format:
				return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
			case RGBA_ASTC_10x6_Format:
				return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
			case RGBA_ASTC_10x8_Format:
				return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
			case RGBA_ASTC_10x10_Format:
				return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
			case RGBA_ASTC_12x10_Format:
				return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
			case RGBA_ASTC_12x12_Format:
				return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 11 ) / 12 ) * 16;

			// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
			case RGBA_BPTC_Format:
			case RGB_BPTC_SIGNED_Format:
			case RGB_BPTC_UNSIGNED_Format:
				return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

			// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
			case RED_RGTC1_Format:
			case SIGNED_RED_RGTC1_Format:
				return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 8;
			case RED_GREEN_RGTC2_Format:
			case SIGNED_RED_GREEN_RGTC2_Format:
				return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

		}

		throw new Error(
			`Unable to determine texture byte length for ${format} format.`,
		);

	}

	function getTextureTypeByteLength( type ) {

		switch ( type ) {

			case UnsignedByteType:
			case ByteType:
				return { byteLength: 1, components: 1 };
			case UnsignedShortType:
			case ShortType:
			case HalfFloatType:
				return { byteLength: 2, components: 1 };
			case UnsignedShort4444Type:
			case UnsignedShort5551Type:
				return { byteLength: 2, components: 4 };
			case UnsignedIntType:
			case IntType:
			case FloatType:
				return { byteLength: 4, components: 1 };
			case UnsignedInt5999Type:
			case UnsignedInt101111Type:
				return { byteLength: 4, components: 3 };

		}

		throw new Error( `Unknown texture type ${type}.` );

	}

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
		const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

		const _imageDimensions = new Vector2();
		const _videoTextures = new WeakMap();
		let _canvas;

		const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		let useOffscreenCanvas = false;

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				// eslint-disable-next-line compat/compat
				&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

		} catch ( err ) {

			// Ignore any errors

		}

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				// eslint-disable-next-line compat/compat
				new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

		}

		function resizeImage( image, needsNewCanvas, maxSize ) {

			let scale = 1;

			const dimensions = getDimensions( image );

			// handle case if texture exceeds max size

			if ( dimensions.width > maxSize || dimensions.height > maxSize ) {

				scale = maxSize / Math.max( dimensions.width, dimensions.height );

			}

			// only perform resize if necessary

			if ( scale < 1 ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||
					( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) ) {

					const width = Math.floor( scale * dimensions.width );
					const height = Math.floor( scale * dimensions.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					const context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					warn( 'WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						warn( 'WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function textureNeedsGenerateMipmaps( texture ) {

			return texture.generateMipmaps;

		}

		function generateMipmap( target ) {

			_gl.generateMipmap( target );

		}

		function getTargetType( texture ) {

			if ( texture.isWebGLCubeRenderTarget ) return _gl.TEXTURE_CUBE_MAP;
			if ( texture.isWebGL3DRenderTarget ) return _gl.TEXTURE_3D;
			if ( texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture ) return _gl.TEXTURE_2D_ARRAY;
			return _gl.TEXTURE_2D;

		}

		function getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

			if ( internalFormatName !== null ) {

				if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

				warn( 'WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

			}

			let internalFormat = glFormat;

			if ( glFormat === _gl.RED ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

			}

			if ( glFormat === _gl.RED_INTEGER ) {

				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;
				if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;
				if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;
				if ( glType === _gl.BYTE ) internalFormat = _gl.R8I;
				if ( glType === _gl.SHORT ) internalFormat = _gl.R16I;
				if ( glType === _gl.INT ) internalFormat = _gl.R32I;

			}

			if ( glFormat === _gl.RG ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;

			}

			if ( glFormat === _gl.RG_INTEGER ) {

				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8UI;
				if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RG16UI;
				if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RG32UI;
				if ( glType === _gl.BYTE ) internalFormat = _gl.RG8I;
				if ( glType === _gl.SHORT ) internalFormat = _gl.RG16I;
				if ( glType === _gl.INT ) internalFormat = _gl.RG32I;

			}

			if ( glFormat === _gl.RGB_INTEGER ) {

				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGB8UI;
				if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RGB16UI;
				if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RGB32UI;
				if ( glType === _gl.BYTE ) internalFormat = _gl.RGB8I;
				if ( glType === _gl.SHORT ) internalFormat = _gl.RGB16I;
				if ( glType === _gl.INT ) internalFormat = _gl.RGB32I;

			}

			if ( glFormat === _gl.RGBA_INTEGER ) {

				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGBA8UI;
				if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RGBA16UI;
				if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RGBA32UI;
				if ( glType === _gl.BYTE ) internalFormat = _gl.RGBA8I;
				if ( glType === _gl.SHORT ) internalFormat = _gl.RGBA16I;
				if ( glType === _gl.INT ) internalFormat = _gl.RGBA32I;

			}

			if ( glFormat === _gl.RGB ) {

				if ( glType === _gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = _gl.RGB9_E5;
				if ( glType === _gl.UNSIGNED_INT_10F_11F_11F_REV ) internalFormat = _gl.R11F_G11F_B10F;

			}

			if ( glFormat === _gl.RGBA ) {

				const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
				if ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;
				if ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;

			}

			if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
				internalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||
				internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

				extensions.get( 'EXT_color_buffer_float' );

			}

			return internalFormat;

		}

		function getInternalDepthFormat( useStencil, depthType ) {

			let glInternalFormat;
			if ( useStencil ) {

				if ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {

					glInternalFormat = _gl.DEPTH24_STENCIL8;

				} else if ( depthType === FloatType ) {

					glInternalFormat = _gl.DEPTH32F_STENCIL8;

				} else if ( depthType === UnsignedShortType ) {

					glInternalFormat = _gl.DEPTH24_STENCIL8;
					warn( 'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.' );

				}

			} else {

				if ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {

					glInternalFormat = _gl.DEPTH_COMPONENT24;

				} else if ( depthType === FloatType ) {

					glInternalFormat = _gl.DEPTH_COMPONENT32F;

				} else if ( depthType === UnsignedShortType ) {

					glInternalFormat = _gl.DEPTH_COMPONENT16;

				}

			}

			return glInternalFormat;

		}

		function getMipLevels( texture, image ) {

			if ( textureNeedsGenerateMipmaps( texture ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

				return Math.log2( Math.max( image.width, image.height ) ) + 1;

			} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

				// user-defined mipmaps

				return texture.mipmaps.length;

			} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

				return image.mipmaps.length;

			} else {

				// texture without mipmaps (only base level)

				return 1;

			}

		}

		//

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				_videoTextures.delete( texture );

			}

		}

		function onRenderTargetDispose( event ) {

			const renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

		}

		//

		function deallocateTexture( texture ) {

			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			// check if it's necessary to remove the WebGLTexture object

			const source = texture.source;
			const webglTextures = _sources.get( source );

			if ( webglTextures ) {

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];
				webglTexture.usedTimes --;

				// the WebGLTexture object is not used anymore, remove it

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

				// remove the weak map entry if no WebGLTexture uses the source anymore

				if ( Object.keys( webglTextures ).length === 0 ) {

					_sources.delete( source );

				}

			}

			properties.remove( texture );

		}

		function deleteTexture( texture ) {

			const textureProperties = properties.get( texture );
			_gl.deleteTexture( textureProperties.__webglTexture );

			const source = texture.source;
			const webglTextures = _sources.get( source );
			delete webglTextures[ textureProperties.__cacheKey ];

			info.memory.textures --;

		}

		function deallocateRenderTarget( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

				properties.remove( renderTarget.depthTexture );

			}

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				for ( let i = 0; i < 6; i ++ ) {

					if ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {

						for ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );

					} else {

						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );

					}

					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				if ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {

					for ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );

				} else {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );

				}

				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
				if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

				if ( renderTargetProperties.__webglColorRenderbuffer ) {

					for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

						if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

				}

				if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

			}

			const textures = renderTarget.textures;

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const attachmentProperties = properties.get( textures[ i ] );

				if ( attachmentProperties.__webglTexture ) {

					_gl.deleteTexture( attachmentProperties.__webglTexture );

					info.memory.textures --;

				}

				properties.remove( textures[ i ] );

			}

			properties.remove( renderTarget );

		}

		//

		let textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			const textureUnit = textureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				warn( 'WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		function getTextureCacheKey( texture ) {

			const array = [];

			array.push( texture.wrapS );
			array.push( texture.wrapT );
			array.push( texture.wrapR || 0 );
			array.push( texture.magFilter );
			array.push( texture.minFilter );
			array.push( texture.anisotropy );
			array.push( texture.internalFormat );
			array.push( texture.format );
			array.push( texture.type );
			array.push( texture.generateMipmaps );
			array.push( texture.premultiplyAlpha );
			array.push( texture.flipY );
			array.push( texture.unpackAlignment );
			array.push( texture.colorSpace );

			return array.join();

		}

		//

		function setTexture2D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.isRenderTargetTexture === false && texture.isExternalTexture !== true && texture.version > 0 && textureProperties.__version !== texture.version ) {

				const image = texture.image;

				if ( image === null ) {

					warn( 'WebGLRenderer: Texture marked for update but no image data found.' );

				} else if ( image.complete === false ) {

					warn( 'WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			} else if ( texture.isExternalTexture ) {

				textureProperties.__webglTexture = texture.sourceTexture ? texture.sourceTexture : null;

			}

			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		function setTexture2DArray( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			} else if ( texture.isExternalTexture ) {

				textureProperties.__webglTexture = texture.sourceTexture ? texture.sourceTexture : null;

			}

			state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		function setTexture3D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		function setTextureCube( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadCubeTexture( textureProperties, texture, slot );
				return;

			}

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		const wrappingToGL = {
			[ RepeatWrapping ]: _gl.REPEAT,
			[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
			[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
		};

		const filterToGL = {
			[ NearestFilter ]: _gl.NEAREST,
			[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
			[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

			[ LinearFilter ]: _gl.LINEAR,
			[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
			[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
		};

		const compareToGL = {
			[ NeverCompare ]: _gl.NEVER,
			[ AlwaysCompare ]: _gl.ALWAYS,
			[ LessCompare ]: _gl.LESS,
			[ LessEqualCompare ]: _gl.LEQUAL,
			[ EqualCompare ]: _gl.EQUAL,
			[ GreaterEqualCompare ]: _gl.GEQUAL,
			[ GreaterCompare ]: _gl.GREATER,
			[ NotEqualCompare ]: _gl.NOTEQUAL
		};

		function setTextureParameters( textureType, texture ) {

			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false &&
				( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
				texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter ) ) {

				warn( 'WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.' );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

			if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

			if ( texture.compareFunction ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );
				_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

			}

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				if ( texture.magFilter === NearestFilter ) return;
				if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
				if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			let forceUpload = false;

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

			}

			// create Source <-> WebGLTextures mapping if necessary

			const source = texture.source;
			let webglTextures = _sources.get( source );

			if ( webglTextures === undefined ) {

				webglTextures = {};
				_sources.set( source, webglTextures );

			}

			// check if there is already a WebGLTexture object for the given texture parameters

			const textureCacheKey = getTextureCacheKey( texture );

			if ( textureCacheKey !== textureProperties.__cacheKey ) {

				// if not, create a new instance of WebGLTexture

				if ( webglTextures[ textureCacheKey ] === undefined ) {

					// create new entry

					webglTextures[ textureCacheKey ] = {
						texture: _gl.createTexture(),
						usedTimes: 0
					};

					info.memory.textures ++;

					// when a new instance of WebGLTexture was created, a texture upload is required
					// even if the image contents are identical

					forceUpload = true;

				}

				webglTextures[ textureCacheKey ].usedTimes ++;

				// every time the texture cache key changes, it's necessary to check if an instance of
				// WebGLTexture can be deleted in order to avoid a memory leak.

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];

				if ( webglTexture !== undefined ) {

					webglTextures[ textureProperties.__cacheKey ].usedTimes --;

					if ( webglTexture.usedTimes === 0 ) {

						deleteTexture( texture );

					}

				}

				// store references to cache key and WebGLTexture object

				textureProperties.__cacheKey = textureCacheKey;
				textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

			}

			return forceUpload;

		}

		function getRow( index, rowLength, componentStride ) {

			return Math.floor( Math.floor( index / componentStride ) / rowLength );

		}

		function updateTexture( texture, image, glFormat, glType ) {

			const componentStride = 4; // only RGBA supported

			const updateRanges = texture.updateRanges;

			if ( updateRanges.length === 0 ) {

				state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

			} else {

				// Before applying update ranges, we merge any adjacent / overlapping
				// ranges to reduce load on `gl.texSubImage2D`. Empirically, this has led
				// to performance improvements for applications which make heavy use of
				// update ranges. Likely due to GPU command overhead.
				//
				// Note that to reduce garbage collection between frames, we merge the
				// update ranges in-place. This is safe because this method will clear the
				// update ranges once updated.

				updateRanges.sort( ( a, b ) => a.start - b.start );

				// To merge the update ranges in-place, we work from left to right in the
				// existing updateRanges array, merging ranges. This may result in a final
				// array which is smaller than the original. This index tracks the last
				// index representing a merged range, any data after this index can be
				// trimmed once the merge algorithm is completed.
				let mergeIndex = 0;

				for ( let i = 1; i < updateRanges.length; i ++ ) {

					const previousRange = updateRanges[ mergeIndex ];
					const range = updateRanges[ i ];

					// Only merge if in the same row and overlapping/adjacent
					const previousEnd = previousRange.start + previousRange.count;
					const currentRow = getRow( range.start, image.width, componentStride );
					const previousRow = getRow( previousRange.start, image.width, componentStride );

					// We add one here to merge adjacent ranges. This is safe because ranges
					// operate over positive integers.
					if (
						range.start <= previousEnd + 1 &&
						currentRow === previousRow &&
						getRow( range.start + range.count - 1, image.width, componentStride ) === currentRow // ensure range doesn't spill
					) {

						previousRange.count = Math.max(
							previousRange.count,
							range.start + range.count - previousRange.start
						);

					} else {

						++ mergeIndex;
						updateRanges[ mergeIndex ] = range;

					}


				}

				// Trim the array to only contain the merged ranges.
				updateRanges.length = mergeIndex + 1;

				const currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
				const currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
				const currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );

				_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );

				for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

					const range = updateRanges[ i ];

					const pixelStart = Math.floor( range.start / componentStride );
					const pixelCount = Math.ceil( range.count / componentStride );

					const x = pixelStart % image.width;
					const y = Math.floor( pixelStart / image.width );

					// Assumes update ranges refer to contiguous memory
					const width = pixelCount;
					const height = 1;

					_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, x );
					_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, y );

					state.texSubImage2D( _gl.TEXTURE_2D, 0, x, y, width, height, glFormat, glType, image.data );

				}

				texture.clearUpdateRanges();

				_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
				_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
				_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			let textureType = _gl.TEXTURE_2D;

			if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;
			if ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

			const sourceProperties = properties.get( source );

			if ( source.version !== sourceProperties.__version || forceUpload === true ) {

				state.activeTexture( _gl.TEXTURE0 + slot );

				const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
				const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
				const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
				_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

				let image = resizeImage( texture.image, false, capabilities.maxTextureSize );
				image = verifyColorSpace( texture, image );

				const glFormat = utils.convert( texture.format, texture.colorSpace );

				const glType = utils.convert( texture.type );
				let glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

				setTextureParameters( textureType, texture );

				let mipmap;
				const mipmaps = texture.mipmaps;

				const useTexStorage = ( texture.isVideoTexture !== true );
				const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
				const dataReady = source.dataReady;
				const levels = getMipLevels( texture, image );

				if ( texture.isDepthTexture ) {

					glInternalFormat = getInternalDepthFormat( texture.format === DepthStencilFormat, texture.type );

					//

					if ( allocateMemory ) {

						if ( useTexStorage ) {

							state.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );

						} else {

							state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

						}

					}

				} else if ( texture.isDataTexture ) {

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

							}

							if ( dataReady ) {

								updateTexture( texture, image, glFormat, glType );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

						}

					}

				} else if ( texture.isCompressedTexture ) {

					if ( texture.isCompressedArrayTexture ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										if ( dataReady ) {

											if ( texture.layerUpdates.size > 0 ) {

												const layerByteLength = getByteLength( mipmap.width, mipmap.height, texture.format, texture.type );

												for ( const layerIndex of texture.layerUpdates ) {

													const layerData = mipmap.data.subarray(
														layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
														( layerIndex + 1 ) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
													);
													state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData );

												}

												texture.clearLayerUpdates();

											} else {

												state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );

											}

										}

									} else {

										state.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

									}

								} else {

									warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

								}

							} else {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

									}

								} else {

									state.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					} else {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										if ( dataReady ) {

											state.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

										}

									} else {

										state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									}

								} else {

									warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

								}

							} else {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

				} else if ( texture.isDataArrayTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						if ( dataReady ) {

							if ( texture.layerUpdates.size > 0 ) {

								const layerByteLength = getByteLength( image.width, image.height, texture.format, texture.type );

								for ( const layerIndex of texture.layerUpdates ) {

									const layerData = image.data.subarray(
										layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
										( layerIndex + 1 ) * layerByteLength / image.data.BYTES_PER_ELEMENT
									);
									state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData );

								}

								texture.clearLayerUpdates();

							} else {

								state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

							}

						}

					} else {

						state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isData3DTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						if ( dataReady ) {

							state.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

						}

					} else {

						state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isFramebufferTexture ) {

					if ( allocateMemory ) {

						if ( useTexStorage ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

						} else {

							let width = image.width, height = image.height;

							for ( let i = 0; i < levels; i ++ ) {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );

								width >>= 1;
								height >>= 1;

							}

						}

					}

				} else {

					// regular Texture (image, video, canvas)

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 ) {

						if ( useTexStorage && allocateMemory ) {

							const dimensions = getDimensions( mipmaps[ 0 ] );

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								const dimensions = getDimensions( image );

								state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

							}

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture ) ) {

					generateMipmap( textureType );

				}

				sourceProperties.__version = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		function uploadCubeTexture( textureProperties, texture, slot ) {

			if ( texture.image.length !== 6 ) return;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

			const sourceProperties = properties.get( source );

			if ( source.version !== sourceProperties.__version || forceUpload === true ) {

				state.activeTexture( _gl.TEXTURE0 + slot );

				const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
				const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
				const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
				_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

				const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
				const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

				const cubeImage = [];

				for ( let i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = resizeImage( texture.image[ i ], true, capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

					cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

				}

				const image = cubeImage[ 0 ],
					glFormat = utils.convert( texture.format, texture.colorSpace ),
					glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

				const useTexStorage = ( texture.isVideoTexture !== true );
				const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
				const dataReady = source.dataReady;
				let levels = getMipLevels( texture, image );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

				let mipmaps;

				if ( isCompressed ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						mipmaps = cubeImage[ i ].mipmaps;

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										if ( dataReady ) {

											state.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

										}

									} else {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									}

								} else {

									warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

								}

							} else {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

				} else {

					mipmaps = texture.mipmaps;

					if ( useTexStorage && allocateMemory ) {

						// TODO: Uniformly handle mipmap definitions
						// Normal textures and compressed cube textures define base level + mips with their mipmap array
						// Uncompressed cube textures use their mipmap array only for mips (no base level)

						if ( mipmaps.length > 0 ) levels ++;

						const dimensions = getDimensions( cubeImage[ 0 ] );

						state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						if ( isDataTexture ) {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];
								const mipmapImage = mipmap.image[ i ].image;

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

								}

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

								}

							}

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture ) ) {

					// We assume images for cube map have the same size.
					generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				sourceProperties.__version = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {

			const glFormat = utils.convert( texture.format, texture.colorSpace );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			textureProperties.__renderTarget = renderTarget;

			if ( ! renderTargetProperties.__hasExternalTextures ) {

				const width = Math.max( 1, renderTarget.width >> level );
				const height = Math.max( 1, renderTarget.height >> level );

				if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

					state.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );

				} else {

					state.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );

				}

			}

			state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

			} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level );

			}

			state.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer ) {

				// retrieve the depth attachment types
				const depthTexture = renderTarget.depthTexture;
				const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
				const glInternalFormat = getInternalDepthFormat( renderTarget.stencilBuffer, depthType );
				const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

				// set up the attachment
				const samples = getRenderTargetSamples( renderTarget );
				const isUseMultisampledRTT = useMultisampledRTT( renderTarget );
				if ( isUseMultisampledRTT ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else if ( isMultisample ) {

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

			} else {

				const textures = renderTarget.textures;

				for ( let i = 0; i < textures.length; i ++ ) {

					const texture = textures[ i ];

					const glFormat = utils.convert( texture.format, texture.colorSpace );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
					const samples = getRenderTargetSamples( renderTarget );

					if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else if ( useMultisampledRTT( renderTarget ) ) {

						multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

					}

				}

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			const textureProperties = properties.get( renderTarget.depthTexture );
			textureProperties.__renderTarget = renderTarget;

			// upload an empty depth texture with framebuffer size
			if ( ! textureProperties.__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			const webglDepthTexture = textureProperties.__webglTexture;
			const samples = getRenderTargetSamples( renderTarget );

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				}

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				}

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );
			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

			// if the bound depth texture has changed
			if ( renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture ) {

				// fire the dispose event to get rid of stored state associated with the previously bound depth buffer
				const depthTexture = renderTarget.depthTexture;
				if ( renderTargetProperties.__depthDisposeCallback ) {

					renderTargetProperties.__depthDisposeCallback();

				}

				// set up dispose listeners to track when the currently attached buffer is implicitly unbound
				if ( depthTexture ) {

					const disposeEvent = () => {

						delete renderTargetProperties.__boundDepthTexture;
						delete renderTargetProperties.__depthDisposeCallback;
						depthTexture.removeEventListener( 'dispose', disposeEvent );

					};

					depthTexture.addEventListener( 'dispose', disposeEvent );
					renderTargetProperties.__depthDisposeCallback = disposeEvent;

				}

				renderTargetProperties.__boundDepthTexture = depthTexture;

			}

			if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				const mipmaps = renderTarget.texture.mipmaps;

				if ( mipmaps && mipmaps.length > 0 ) {

					setupDepthTexture( renderTargetProperties.__webglFramebuffer[ 0 ], renderTarget );

				} else {

					setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

				}

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( let i = 0; i < 6; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );

						if ( renderTargetProperties.__webglDepthbuffer[ i ] === undefined ) {

							renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

						} else {

							// attach buffer if it's been created already
							const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
							const renderbuffer = renderTargetProperties.__webglDepthbuffer[ i ];
							_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

						}

					}

				} else {

					const mipmaps = renderTarget.texture.mipmaps;

					if ( mipmaps && mipmaps.length > 0 ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ 0 ] );

					} else {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

					}

					if ( renderTargetProperties.__webglDepthbuffer === undefined ) {

						renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

					} else {

						// attach buffer if it's been created already
						const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
						const renderbuffer = renderTargetProperties.__webglDepthbuffer;
						_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

					}

				}

			}

			state.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// rebind framebuffer with external textures
		function rebindTextures( renderTarget, colorTexture, depthTexture ) {

			const renderTargetProperties = properties.get( renderTarget );

			if ( colorTexture !== undefined ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );

			}

			if ( depthTexture !== undefined ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			const textures = renderTarget.textures;

			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
			const isMultipleRenderTargets = ( textures.length > 1 );

			if ( ! isMultipleRenderTargets ) {

				if ( textureProperties.__webglTexture === undefined ) {

					textureProperties.__webglTexture = _gl.createTexture();

				}

				textureProperties.__version = texture.version;
				info.memory.textures ++;

			}

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

						renderTargetProperties.__webglFramebuffer[ i ] = [];

						for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

							renderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();

						}

					} else {

						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

					}

				}

			} else {

				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

					renderTargetProperties.__webglFramebuffer = [];

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						renderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();

					}

				} else {

					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				}

				if ( isMultipleRenderTargets ) {

					for ( let i = 0, il = textures.length; i < il; i ++ ) {

						const attachmentProperties = properties.get( textures[ i ] );

						if ( attachmentProperties.__webglTexture === undefined ) {

							attachmentProperties.__webglTexture = _gl.createTexture();

							info.memory.textures ++;

						}

					}

				}

				if ( ( renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = [];

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

					for ( let i = 0; i < textures.length; i ++ ) {

						const texture = textures[ i ];
						renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const glFormat = utils.convert( texture.format, texture.colorSpace );
						const glType = utils.convert( texture.type );
						const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );
						const samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

					_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					state.bindFramebuffer( _gl.FRAMEBUFFER, null );

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

				for ( let i = 0; i < 6; i ++ ) {

					if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

						for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

							setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );

						}

					} else {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );

					}

				}

				if ( textureNeedsGenerateMipmaps( texture ) ) {

					generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				state.unbindTexture();

			} else if ( isMultipleRenderTargets ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					const attachment = textures[ i ];
					const attachmentProperties = properties.get( attachment );

					let glTextureType = _gl.TEXTURE_2D;

					if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

						glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

					}

					state.bindTexture( glTextureType, attachmentProperties.__webglTexture );
					setTextureParameters( glTextureType, attachment );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, glTextureType, 0 );

					if ( textureNeedsGenerateMipmaps( attachment ) ) {

						generateMipmap( glTextureType );

					}

				}

				state.unbindTexture();

			} else {

				let glTextureType = _gl.TEXTURE_2D;

				if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

					glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

				}

				state.bindTexture( glTextureType, textureProperties.__webglTexture );
				setTextureParameters( glTextureType, texture );

				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );

					}

				} else {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );

				}

				if ( textureNeedsGenerateMipmaps( texture ) ) {

					generateMipmap( glTextureType );

				}

				state.unbindTexture();

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			const textures = renderTarget.textures;

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const texture = textures[ i ];

				if ( textureNeedsGenerateMipmaps( texture ) ) {

					const targetType = getTargetType( renderTarget );
					const webglTexture = properties.get( texture ).__webglTexture;

					state.bindTexture( targetType, webglTexture );
					generateMipmap( targetType );
					state.unbindTexture();

				}

			}

		}

		const invalidationArrayRead = [];
		const invalidationArrayDraw = [];

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( renderTarget.samples > 0 ) {

				if ( useMultisampledRTT( renderTarget ) === false ) {

					const textures = renderTarget.textures;
					const width = renderTarget.width;
					const height = renderTarget.height;
					let mask = _gl.COLOR_BUFFER_BIT;
					const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
					const renderTargetProperties = properties.get( renderTarget );
					const isMultipleRenderTargets = ( textures.length > 1 );

					// If MRT we need to remove FBO attachments
					if ( isMultipleRenderTargets ) {

						for ( let i = 0; i < textures.length; i ++ ) {

							state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );

							state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
							_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );

						}

					}

					state.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

					const mipmaps = renderTarget.texture.mipmaps;

					if ( mipmaps && mipmaps.length > 0 ) {

						state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ 0 ] );

					} else {

						state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

					}

					for ( let i = 0; i < textures.length; i ++ ) {

						if ( renderTarget.resolveDepthBuffer ) {

							if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;

							// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)

							if ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

						}

						if ( isMultipleRenderTargets ) {

							_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

							const webglTexture = properties.get( textures[ i ] ).__webglTexture;
							_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );

						}

						_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

						if ( supportsInvalidateFramebuffer === true ) {

							invalidationArrayRead.length = 0;
							invalidationArrayDraw.length = 0;

							invalidationArrayRead.push( _gl.COLOR_ATTACHMENT0 + i );

							if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false ) {

								invalidationArrayRead.push( depthStyle );
								invalidationArrayDraw.push( depthStyle );

								_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, invalidationArrayDraw );

							}

							_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArrayRead );

						}

					}

					state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

					// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
					if ( isMultipleRenderTargets ) {

						for ( let i = 0; i < textures.length; i ++ ) {

							state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

							const webglTexture = properties.get( textures[ i ] ).__webglTexture;

							state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
							_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );

						}

					}

					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

				} else {

					if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer ) {

						const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

						_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );

					}

				}

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return Math.min( capabilities.maxSamples, renderTarget.samples );

		}

		function useMultisampledRTT( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			return renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

		}

		function updateVideoTexture( texture ) {

			const frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures.get( texture ) !== frame ) {

				_videoTextures.set( texture, frame );
				texture.update();

			}

		}

		function verifyColorSpace( texture, image ) {

			const colorSpace = texture.colorSpace;
			const format = texture.format;
			const type = texture.type;

			if ( texture.isCompressedTexture === true || texture.isVideoTexture === true ) return image;

			if ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {

				// sRGB

				if ( ColorManagement.getTransfer( colorSpace ) === SRGBTransfer ) {

					// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

					if ( format !== RGBAFormat || type !== UnsignedByteType ) {

						warn( 'WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

					}

				} else {

					error( 'WebGLTextures: Unsupported texture color space:', colorSpace );

				}

			}

			return image;

		}

		function getDimensions( image ) {

			if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) {

				// if intrinsic data are not available, fallback to width/height

				_imageDimensions.width = image.naturalWidth || image.width;
				_imageDimensions.height = image.naturalHeight || image.height;

			} else if ( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) {

				_imageDimensions.width = image.displayWidth;
				_imageDimensions.height = image.displayHeight;

			} else {

				_imageDimensions.width = image.width;
				_imageDimensions.height = image.height;

			}

			return _imageDimensions;

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.rebindTextures = rebindTextures;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.setupDepthRenderbuffer = setupDepthRenderbuffer;
		this.setupFrameBufferTexture = setupFrameBufferTexture;
		this.useMultisampledRTT = useMultisampledRTT;

	}

	function WebGLUtils( gl, extensions ) {

		function convert( p, colorSpace = NoColorSpace ) {

			let extension;

			const transfer = ColorManagement.getTransfer( colorSpace );

			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;
			if ( p === UnsignedInt101111Type ) return gl.UNSIGNED_INT_10F_11F_11F_REV;

			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;
			if ( p === HalfFloatType ) return gl.HALF_FLOAT;

			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBFormat ) return gl.RGB;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

			// WebGL2 formats.

			if ( p === RedFormat ) return gl.RED;
			if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
			if ( p === RGFormat ) return gl.RG;
			if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
			if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

			// S3TC

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				if ( transfer === SRGBTransfer ) {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				} else {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				}

			}

			// PVRTC

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				} else {

					return null;

				}

			}

			// ETC

			if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc' );

				if ( extension !== null ) {

					if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
					if ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

				} else {

					return null;

				}

			}

			// ASTC

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					if ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

				} else {

					return null;

				}

			}

			// BPTC

			if ( p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format ) {

				extension = extensions.get( 'EXT_texture_compression_bptc' );

				if ( extension !== null ) {

					if ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
					if ( p === RGB_BPTC_SIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
					if ( p === RGB_BPTC_UNSIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;

				} else {

					return null;

				}

			}

			// RGTC

			if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

				extension = extensions.get( 'EXT_texture_compression_rgtc' );

				if ( extension !== null ) {

					if ( p === RED_RGTC1_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
					if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
					if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
					if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

				} else {

					return null;

				}

			}

			//

			if ( p === UnsignedInt248Type ) return gl.UNSIGNED_INT_24_8;

			// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

			return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

		}

		return { convert: convert };

	}

	/**
	 * This type of camera can be used in order to efficiently render a scene with a
	 * predefined set of cameras. This is an important performance aspect for
	 * rendering VR scenes.
	 *
	 * An instance of `ArrayCamera` always has an array of sub cameras. It's mandatory
	 * to define for each sub camera the `viewport` property which determines the
	 * part of the viewport that is rendered with this camera.
	 *
	 * @augments PerspectiveCamera
	 */
	class ArrayCamera extends PerspectiveCamera {

		/**
		 * Constructs a new array camera.
		 *
		 * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
		 */
		constructor( array = [] ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isArrayCamera = true;

			/**
			 * Whether this camera is used with multiview rendering or not.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default false
			 */
			this.isMultiViewCamera = false;

			/**
			 * An array of perspective sub cameras.
			 *
			 * @type {Array<PerspectiveCamera>}
			 */
			this.cameras = array;

		}

	}

	/**
	 * This is almost identical to an {@link Object3D}. Its purpose is to
	 * make working with groups of objects syntactically clearer.
	 *
	 * ```js
	 * // Create a group and add the two cubes.
	 * // These cubes can now be rotated / scaled etc as a group.
	 * const group = new THREE.Group();
	 *
	 * group.add( meshA );
	 * group.add( meshB );
	 *
	 * scene.add( group );
	 * ```
	 *
	 * @augments Object3D
	 */
	class Group extends Object3D {

		constructor() {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isGroup = true;

			this.type = 'Group';

		}

	}

	const _moveEvent = { type: 'move' };

	/**
	 * Class for representing a XR controller with its
	 * different coordinate systems.
	 *
	 * @private
	 */
	class WebXRController {

		/**
		 * Constructs a new XR controller.
		 */
		constructor() {

			/**
			 * A group representing the target ray space
			 * of the XR controller.
			 *
			 * @private
			 * @type {?Group}
			 * @default null
			 */
			this._targetRay = null;

			/**
			 * A group representing the grip space
			 * of the XR controller.
			 *
			 * @private
			 * @type {?Group}
			 * @default null
			 */
			this._grip = null;

			/**
			 * A group representing the hand space
			 * of the XR controller.
			 *
			 * @private
			 * @type {?Group}
			 * @default null
			 */
			this._hand = null;

		}

		/**
		 * Returns a group representing the hand space of the XR controller.
		 *
		 * @return {Group} A group representing the hand space of the XR controller.
		 */
		getHandSpace() {

			if ( this._hand === null ) {

				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;

				this._hand.joints = {};
				this._hand.inputState = { pinching: false };

			}

			return this._hand;

		}

		/**
		 * Returns a group representing the target ray space of the XR controller.
		 *
		 * @return {Group} A group representing the target ray space of the XR controller.
		 */
		getTargetRaySpace() {

			if ( this._targetRay === null ) {

				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();

			}

			return this._targetRay;

		}

		/**
		 * Returns a group representing the grip space of the XR controller.
		 *
		 * @return {Group} A group representing the grip space of the XR controller.
		 */
		getGripSpace() {

			if ( this._grip === null ) {

				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();

			}

			return this._grip;

		}

		/**
		 * Dispatches the given event to the groups representing
		 * the different coordinate spaces of the XR controller.
		 *
		 * @param {Object} event - The event to dispatch.
		 * @return {WebXRController} A reference to this instance.
		 */
		dispatchEvent( event ) {

			if ( this._targetRay !== null ) {

				this._targetRay.dispatchEvent( event );

			}

			if ( this._grip !== null ) {

				this._grip.dispatchEvent( event );

			}

			if ( this._hand !== null ) {

				this._hand.dispatchEvent( event );

			}

			return this;

		}

		/**
		 * Connects the controller with the given XR input source.
		 *
		 * @param {XRInputSource} inputSource - The input source.
		 * @return {WebXRController} A reference to this instance.
		 */
		connect( inputSource ) {

			if ( inputSource && inputSource.hand ) {

				const hand = this._hand;

				if ( hand ) {

					for ( const inputjoint of inputSource.hand.values() ) {

						// Initialize hand with joints when connected
						this._getHandJoint( hand, inputjoint );

					}

				}

			}

			this.dispatchEvent( { type: 'connected', data: inputSource } );

			return this;

		}

		/**
		 * Disconnects the controller from the given XR input source.
		 *
		 * @param {XRInputSource} inputSource - The input source.
		 * @return {WebXRController} A reference to this instance.
		 */
		disconnect( inputSource ) {

			this.dispatchEvent( { type: 'disconnected', data: inputSource } );

			if ( this._targetRay !== null ) {

				this._targetRay.visible = false;

			}

			if ( this._grip !== null ) {

				this._grip.visible = false;

			}

			if ( this._hand !== null ) {

				this._hand.visible = false;

			}

			return this;

		}

		/**
		 * Updates the controller with the given input source, XR frame and reference space.
		 * This updates the transformations of the groups that represent the different
		 * coordinate systems of the controller.
		 *
		 * @param {XRInputSource} inputSource - The input source.
		 * @param {XRFrame} frame - The XR frame.
		 * @param {XRReferenceSpace} referenceSpace - The reference space.
		 * @return {WebXRController} A reference to this instance.
		 */
		update( inputSource, frame, referenceSpace ) {

			let inputPose = null;
			let gripPose = null;
			let handPose = null;

			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

				if ( hand && inputSource.hand ) {

					handPose = true;

					for ( const inputjoint of inputSource.hand.values() ) {

						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose( inputjoint, referenceSpace );

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = this._getHandJoint( hand, inputjoint );

						if ( jointPose !== null ) {

							joint.matrix.fromArray( jointPose.transform.matrix );
							joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
							joint.matrixWorldNeedsUpdate = true;
							joint.jointRadius = jointPose.radius;

						}

						joint.visible = jointPose !== null;

					}

					// Custom events

					// Check pinchz
					const indexTip = hand.joints[ 'index-finger-tip' ];
					const thumbTip = hand.joints[ 'thumb-tip' ];
					const distance = indexTip.position.distanceTo( thumbTip.position );

					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

						hand.inputState.pinching = false;
						this.dispatchEvent( {
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						} );

					} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

						hand.inputState.pinching = true;
						this.dispatchEvent( {
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						} );

					}

				} else {

					if ( grip !== null && inputSource.gripSpace ) {

						gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

						if ( gripPose !== null ) {

							grip.matrix.fromArray( gripPose.transform.matrix );
							grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
							grip.matrixWorldNeedsUpdate = true;

							if ( gripPose.linearVelocity ) {

								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy( gripPose.linearVelocity );

							} else {

								grip.hasLinearVelocity = false;

							}

							if ( gripPose.angularVelocity ) {

								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy( gripPose.angularVelocity );

							} else {

								grip.hasAngularVelocity = false;

							}

						}

					}

				}

				if ( targetRay !== null ) {

					inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

					// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
					if ( inputPose === null && gripPose !== null ) {

						inputPose = gripPose;

					}

					if ( inputPose !== null ) {

						targetRay.matrix.fromArray( inputPose.transform.matrix );
						targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
						targetRay.matrixWorldNeedsUpdate = true;

						if ( inputPose.linearVelocity ) {

							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy( inputPose.linearVelocity );

						} else {

							targetRay.hasLinearVelocity = false;

						}

						if ( inputPose.angularVelocity ) {

							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy( inputPose.angularVelocity );

						} else {

							targetRay.hasAngularVelocity = false;

						}

						this.dispatchEvent( _moveEvent );

					}

				}


			}

			if ( targetRay !== null ) {

				targetRay.visible = ( inputPose !== null );

			}

			if ( grip !== null ) {

				grip.visible = ( gripPose !== null );

			}

			if ( hand !== null ) {

				hand.visible = ( handPose !== null );

			}

			return this;

		}

		/**
		 * Returns a group representing the hand joint for the given input joint.
		 *
		 * @private
		 * @param {Group} hand - The group representing the hand space.
		 * @param {XRJointSpace} inputjoint - The hand joint data.
		 * @return {Group} A group representing the hand joint for the given input joint.
		 */
		_getHandJoint( hand, inputjoint ) {

			if ( hand.joints[ inputjoint.jointName ] === undefined ) {

				const joint = new Group();
				joint.matrixAutoUpdate = false;
				joint.visible = false;
				hand.joints[ inputjoint.jointName ] = joint;

				hand.add( joint );

			}

			return hand.joints[ inputjoint.jointName ];

		}

	}

	/**
	 * Represents a texture created externally with the same renderer context.
	 *
	 * This may be a texture from a protected media stream, device camera feed,
	 * or other data feeds like a depth sensor.
	 *
	 * Note that this class is only supported in {@link WebGLRenderer}, and in
	 * the {@link WebGPURenderer} WebGPU backend.
	 *
	 * @augments Texture
	 */
	class ExternalTexture extends Texture {

		/**
		 * Creates a new raw texture.
		 *
		 * @param {?(WebGLTexture|GPUTexture)} [sourceTexture=null] - The external texture.
		 */
		constructor( sourceTexture = null ) {

			super();

			/**
			 * The external source texture.
			 *
			 * @type {?(WebGLTexture|GPUTexture)}
			 * @default null
			 */
			this.sourceTexture = sourceTexture;

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isExternalTexture = true;

		}

		copy( source ) {

			super.copy( source );

			this.sourceTexture = source.sourceTexture;

			return this;

		}

	}

	const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;

	const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;

	/**
	 * A XR module that manages the access to the Depth Sensing API.
	 */
	class WebXRDepthSensing {

		/**
		 * Constructs a new depth sensing module.
		 */
		constructor() {

			/**
			 * An opaque texture representing the depth of the user's environment.
			 *
			 * @type {?ExternalTexture}
			 */
			this.texture = null;

			/**
			 * A plane mesh for visualizing the depth texture.
			 *
			 * @type {?Mesh}
			 */
			this.mesh = null;

			/**
			 * The depth near value.
			 *
			 * @type {number}
			 */
			this.depthNear = 0;

			/**
			 * The depth near far.
			 *
			 * @type {number}
			 */
			this.depthFar = 0;

		}

		/**
		 * Inits the depth sensing module
		 *
		 * @param {XRWebGLDepthInformation} depthData - The XR depth data.
		 * @param {XRRenderState} renderState - The XR render state.
		 */
		init( depthData, renderState ) {

			if ( this.texture === null ) {

				const texture = new ExternalTexture( depthData.texture );

				if ( ( depthData.depthNear !== renderState.depthNear ) || ( depthData.depthFar !== renderState.depthFar ) ) {

					this.depthNear = depthData.depthNear;
					this.depthFar = depthData.depthFar;

				}

				this.texture = texture;

			}

		}

		/**
		 * Returns a plane mesh that visualizes the depth texture.
		 *
		 * @param {ArrayCamera} cameraXR - The XR camera.
		 * @return {?Mesh} The plane mesh.
		 */
		getMesh( cameraXR ) {

			if ( this.texture !== null ) {

				if ( this.mesh === null ) {

					const viewport = cameraXR.cameras[ 0 ].viewport;
					const material = new ShaderMaterial( {
						vertexShader: _occlusion_vertex,
						fragmentShader: _occlusion_fragment,
						uniforms: {
							depthColor: { value: this.texture },
							depthWidth: { value: viewport.z },
							depthHeight: { value: viewport.w }
						}
					} );

					this.mesh = new Mesh( new PlaneGeometry( 20, 20 ), material );

				}

			}

			return this.mesh;

		}

		/**
		 * Resets the module
		 */
		reset() {

			this.texture = null;
			this.mesh = null;

		}

		/**
		 * Returns a texture representing the depth of the user's environment.
		 *
		 * @return {?ExternalTexture} The depth texture.
		 */
		getDepthTexture() {

			return this.texture;

		}

	}

	/**
	 * This class represents an abstraction of the WebXR Device API and is
	 * internally used by {@link WebGLRenderer}. `WebXRManager` also provides a public
	 * interface that allows users to enable/disable XR and perform XR related
	 * tasks like for instance retrieving controllers.
	 *
	 * @augments EventDispatcher
	 * @hideconstructor
	 */
	class WebXRManager extends EventDispatcher {

		/**
		 * Constructs a new WebGL renderer.
		 *
		 * @param {WebGLRenderer} renderer - The renderer.
		 * @param {WebGL2RenderingContext} gl - The rendering context.
		 */
		constructor( renderer, gl ) {

			super();

			const scope = this;

			let session = null;

			let framebufferScaleFactor = 1.0;

			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';
			// Set default foveation to maximum.
			let foveation = 1.0;
			let customReferenceSpace = null;

			let pose = null;
			let glBinding = null;
			let glProjLayer = null;
			let glBaseLayer = null;
			let xrFrame = null;

			const supportsGlBinding = typeof XRWebGLBinding !== 'undefined';

			const depthSensing = new WebXRDepthSensing();
			const cameraAccessTextures = {};
			const attributes = gl.getContextAttributes();

			let initialRenderTarget = null;
			let newRenderTarget = null;

			const controllers = [];
			const controllerInputSources = [];

			const currentSize = new Vector2();
			let currentPixelRatio = null;

			//

			const cameraL = new PerspectiveCamera();
			cameraL.viewport = new Vector4();

			const cameraR = new PerspectiveCamera();
			cameraR.viewport = new Vector4();

			const cameras = [ cameraL, cameraR ];

			const cameraXR = new ArrayCamera();

			let _currentDepthNear = null;
			let _currentDepthFar = null;

			//

			/**
			 * Whether the manager's XR camera should be automatically updated or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.cameraAutoUpdate = true;

			/**
			 * This flag notifies the renderer to be ready for XR rendering. Set it to `true`
			 * if you are going to use XR in your app.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.enabled = false;

			/**
			 * Whether XR presentation is active or not.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default false
			 */
			this.isPresenting = false;

			/**
			 * Returns a group representing the `target ray` space of the XR controller.
			 * Use this space for visualizing 3D objects that support the user in pointing
			 * tasks like UI interaction.
			 *
			 * @param {number} index - The index of the controller.
			 * @return {Group} A group representing the `target ray` space.
			 */
			this.getController = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getTargetRaySpace();

			};

			/**
			 * Returns a group representing the `grip` space of the XR controller.
			 * Use this space for visualizing 3D objects that support the user in pointing
			 * tasks like UI interaction.
			 *
			 * Note: If you want to show something in the user's hand AND offer a
			 * pointing ray at the same time, you'll want to attached the handheld object
			 * to the group returned by `getControllerGrip()` and the ray to the
			 * group returned by `getController()`. The idea is to have two
			 * different groups in two different coordinate spaces for the same WebXR
			 * controller.
			 *
			 * @param {number} index - The index of the controller.
			 * @return {Group} A group representing the `grip` space.
			 */
			this.getControllerGrip = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getGripSpace();

			};

			/**
			 * Returns a group representing the `hand` space of the XR controller.
			 * Use this space for visualizing 3D objects that support the user in pointing
			 * tasks like UI interaction.
			 *
			 * @param {number} index - The index of the controller.
			 * @return {Group} A group representing the `hand` space.
			 */
			this.getHand = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getHandSpace();

			};

			//

			function onSessionEvent( event ) {

				const controllerIndex = controllerInputSources.indexOf( event.inputSource );

				if ( controllerIndex === -1 ) {

					return;

				}

				const controller = controllers[ controllerIndex ];

				if ( controller !== undefined ) {

					controller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );
					controller.dispatchEvent( { type: event.type, data: event.inputSource } );

				}

			}

			function onSessionEnd() {

				session.removeEventListener( 'select', onSessionEvent );
				session.removeEventListener( 'selectstart', onSessionEvent );
				session.removeEventListener( 'selectend', onSessionEvent );
				session.removeEventListener( 'squeeze', onSessionEvent );
				session.removeEventListener( 'squeezestart', onSessionEvent );
				session.removeEventListener( 'squeezeend', onSessionEvent );
				session.removeEventListener( 'end', onSessionEnd );
				session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

				for ( let i = 0; i < controllers.length; i ++ ) {

					const inputSource = controllerInputSources[ i ];

					if ( inputSource === null ) continue;

					controllerInputSources[ i ] = null;

					controllers[ i ].disconnect( inputSource );

				}

				_currentDepthNear = null;
				_currentDepthFar = null;

				depthSensing.reset();
				for ( const key in cameraAccessTextures ) {

					delete cameraAccessTextures[ key ];

				}

				// restore framebuffer/rendering state

				renderer.setRenderTarget( initialRenderTarget );

				glBaseLayer = null;
				glProjLayer = null;
				glBinding = null;
				session = null;
				newRenderTarget = null;

				//

				animation.stop();

				scope.isPresenting = false;

				renderer.setPixelRatio( currentPixelRatio );
				renderer.setSize( currentSize.width, currentSize.height, false );

				scope.dispatchEvent( { type: 'sessionend' } );

			}

			/**
			 * Sets the framebuffer scale factor.
			 *
			 * This method can not be used during a XR session.
			 *
			 * @param {number} value - The framebuffer scale factor.
			 */
			this.setFramebufferScaleFactor = function ( value ) {

				framebufferScaleFactor = value;

				if ( scope.isPresenting === true ) {

					warn( 'WebXRManager: Cannot change framebuffer scale while presenting.' );

				}

			};

			/**
			 * Sets the reference space type. Can be used to configure a spatial relationship with the user's physical
			 * environment. Depending on how the user moves in 3D space, setting an appropriate reference space can
			 * improve tracking. Default is `local-floor`. Valid values can be found here
			 * https://developer.mozilla.org/en-US/docs/Web/API/XRReferenceSpace#reference_space_types.
			 *
			 * This method can not be used during a XR session.
			 *
			 * @param {string} value - The reference space type.
			 */
			this.setReferenceSpaceType = function ( value ) {

				referenceSpaceType = value;

				if ( scope.isPresenting === true ) {

					warn( 'WebXRManager: Cannot change reference space type while presenting.' );

				}

			};

			/**
			 * Returns the XR reference space.
			 *
			 * @return {XRReferenceSpace} The XR reference space.
			 */
			this.getReferenceSpace = function () {

				return customReferenceSpace || referenceSpace;

			};

			/**
			 * Sets a custom XR reference space.
			 *
			 * @param {XRReferenceSpace} space - The XR reference space.
			 */
			this.setReferenceSpace = function ( space ) {

				customReferenceSpace = space;

			};

			/**
			 * Returns the current base layer.
			 *
			 * This is an `XRProjectionLayer` when the targeted XR device supports the
			 * WebXR Layers API, or an `XRWebGLLayer` otherwise.
			 *
			 * @return {?(XRWebGLLayer|XRProjectionLayer)} The XR base layer.
			 */
			this.getBaseLayer = function () {

				return glProjLayer !== null ? glProjLayer : glBaseLayer;

			};

			/**
			 * Returns the current XR binding.
			 *
			 * Creates a new binding if needed and the browser is
			 * capable of doing so.
			 *
			 * @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
			 */
			this.getBinding = function () {

				if ( glBinding === null && supportsGlBinding ) {

					glBinding = new XRWebGLBinding( session, gl );

				}

				return glBinding;

			};

			/**
			 * Returns the current XR frame.
			 *
			 * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
			 */
			this.getFrame = function () {

				return xrFrame;

			};

			/**
			 * Returns the current XR session.
			 *
			 * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
			 */
			this.getSession = function () {

				return session;

			};

			/**
			 * After a XR session has been requested usually with one of the `*Button` modules, it
			 * is injected into the renderer with this method. This method triggers the start of
			 * the actual XR rendering.
			 *
			 * @async
			 * @param {XRSession} value - The XR session to set.
			 * @return {Promise} A Promise that resolves when the session has been set.
			 */
			this.setSession = async function ( value ) {

				session = value;

				if ( session !== null ) {

					initialRenderTarget = renderer.getRenderTarget();

					session.addEventListener( 'select', onSessionEvent );
					session.addEventListener( 'selectstart', onSessionEvent );
					session.addEventListener( 'selectend', onSessionEvent );
					session.addEventListener( 'squeeze', onSessionEvent );
					session.addEventListener( 'squeezestart', onSessionEvent );
					session.addEventListener( 'squeezeend', onSessionEvent );
					session.addEventListener( 'end', onSessionEnd );
					session.addEventListener( 'inputsourceschange', onInputSourcesChange );

					if ( attributes.xrCompatible !== true ) {

						await gl.makeXRCompatible();

					}

					currentPixelRatio = renderer.getPixelRatio();
					renderer.getSize( currentSize );


					// Check that the browser implements the necessary APIs to use an
					// XRProjectionLayer rather than an XRWebGLLayer
					const supportsLayers = supportsGlBinding && 'createProjectionLayer' in XRWebGLBinding.prototype;

					if ( ! supportsLayers ) {

						const layerInit = {
							antialias: attributes.antialias,
							alpha: true,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						};

						glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

						session.updateRenderState( { baseLayer: glBaseLayer } );

						renderer.setPixelRatio( 1 );
						renderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );

						newRenderTarget = new WebGLRenderTarget(
							glBaseLayer.framebufferWidth,
							glBaseLayer.framebufferHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								colorSpace: renderer.outputColorSpace,
								stencilBuffer: attributes.stencil,
								resolveDepthBuffer: ( glBaseLayer.ignoreDepthValues === false ),
								resolveStencilBuffer: ( glBaseLayer.ignoreDepthValues === false )

							}
						);

					} else {

						let depthFormat = null;
						let depthType = null;
						let glDepthFormat = null;

						if ( attributes.depth ) {

							glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
							depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
							depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

						}

						const projectionlayerInit = {
							colorFormat: gl.RGBA8,
							depthFormat: glDepthFormat,
							scaleFactor: framebufferScaleFactor
						};

						glBinding = this.getBinding();

						glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

						session.updateRenderState( { layers: [ glProjLayer ] } );

						renderer.setPixelRatio( 1 );
						renderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );

						newRenderTarget = new WebGLRenderTarget(
							glProjLayer.textureWidth,
							glProjLayer.textureHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
								stencilBuffer: attributes.stencil,
								colorSpace: renderer.outputColorSpace,
								samples: attributes.antialias ? 4 : 0,
								resolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false ),
								resolveStencilBuffer: ( glProjLayer.ignoreDepthValues === false )
							} );

					}

					newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

					this.setFoveation( foveation );

					customReferenceSpace = null;
					referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

					animation.setContext( session );
					animation.start();

					scope.isPresenting = true;

					scope.dispatchEvent( { type: 'sessionstart' } );

				}

			};

			/**
			 * Returns the environment blend mode from the current XR session.
			 *
			 * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
			 */
			this.getEnvironmentBlendMode = function () {

				if ( session !== null ) {

					return session.environmentBlendMode;

				}

			};

			/**
			 * Returns the current depth texture computed via depth sensing.
			 *
			 * See {@link WebXRDepthSensing#getDepthTexture}.
			 *
			 * @return {?Texture} The depth texture.
			 */
			this.getDepthTexture = function () {

				return depthSensing.getDepthTexture();

			};

			function onInputSourcesChange( event ) {

				// Notify disconnected

				for ( let i = 0; i < event.removed.length; i ++ ) {

					const inputSource = event.removed[ i ];
					const index = controllerInputSources.indexOf( inputSource );

					if ( index >= 0 ) {

						controllerInputSources[ index ] = null;
						controllers[ index ].disconnect( inputSource );

					}

				}

				// Notify connected

				for ( let i = 0; i < event.added.length; i ++ ) {

					const inputSource = event.added[ i ];

					let controllerIndex = controllerInputSources.indexOf( inputSource );

					if ( controllerIndex === -1 ) {

						// Assign input source a controller that currently has no input source

						for ( let i = 0; i < controllers.length; i ++ ) {

							if ( i >= controllerInputSources.length ) {

								controllerInputSources.push( inputSource );
								controllerIndex = i;
								break;

							} else if ( controllerInputSources[ i ] === null ) {

								controllerInputSources[ i ] = inputSource;
								controllerIndex = i;
								break;

							}

						}

						// If all controllers do currently receive input we ignore new ones

						if ( controllerIndex === -1 ) break;

					}

					const controller = controllers[ controllerIndex ];

					if ( controller ) {

						controller.connect( inputSource );

					}

				}

			}

			//

			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();

			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 *
			 * @param {ArrayCamera} camera - The camera to update.
			 * @param {PerspectiveCamera} cameraL - The left camera.
			 * @param {PerspectiveCamera} cameraR - The right camera.
			 */
			function setProjectionFromUnion( camera, cameraL, cameraR ) {

				cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
				cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

				const ipd = cameraLPos.distanceTo( cameraRPos );

				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements;

				// VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.
				const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
				const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
				const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
				const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

				const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
				const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
				const left = near * leftFov;
				const right = near * rightFov;

				// Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.
				const zOffset = ipd / ( - leftFov + rightFov );
				const xOffset = zOffset * - leftFov;

				// TODO: Better way to apply this offset?
				cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
				camera.translateX( xOffset );
				camera.translateZ( zOffset );
				camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

				// Check if the projection uses an infinite far plane.
				if ( projL[ 10 ] === -1 ) {

					// Use the projection matrix from the left eye.
					// The camera offset is sufficient to include the view volumes
					// of both eyes (assuming symmetric projections).
					camera.projectionMatrix.copy( cameraL.projectionMatrix );
					camera.projectionMatrixInverse.copy( cameraL.projectionMatrixInverse );

				} else {

					// Find the union of the frustum values of the cameras and scale
					// the values so that the near plane's position does not change in world space,
					// although must now be relative to the new union camera.
					const near2 = near + zOffset;
					const far2 = far + zOffset;
					const left2 = left - xOffset;
					const right2 = right + ( ipd - xOffset );
					const top2 = topFov * far / far2 * near2;
					const bottom2 = bottomFov * far / far2 * near2;

					camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
					camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();

				}

			}

			function updateCamera( camera, parent ) {

				if ( parent === null ) {

					camera.matrixWorld.copy( camera.matrix );

				} else {

					camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

				}

				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			}

			/**
			 * Updates the state of the XR camera. Use this method on app level if you
			 * set `cameraAutoUpdate` to `false`. The method requires the non-XR
			 * camera of the scene as a parameter. The passed in camera's transformation
			 * is automatically adjusted to the position of the XR camera when calling
			 * this method.
			 *
			 * @param {Camera} camera - The camera.
			 */
			this.updateCamera = function ( camera ) {

				if ( session === null ) return;

				let depthNear = camera.near;
				let depthFar = camera.far;

				if ( depthSensing.texture !== null ) {

					if ( depthSensing.depthNear > 0 ) depthNear = depthSensing.depthNear;
					if ( depthSensing.depthFar > 0 ) depthFar = depthSensing.depthFar;

				}

				cameraXR.near = cameraR.near = cameraL.near = depthNear;
				cameraXR.far = cameraR.far = cameraL.far = depthFar;

				if ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {

					// Note that the new renderState won't apply until the next frame. See #18320

					session.updateRenderState( {
						depthNear: cameraXR.near,
						depthFar: cameraXR.far
					} );

					_currentDepthNear = cameraXR.near;
					_currentDepthFar = cameraXR.far;

				}

				// inherit camera layers and enable eye layers (1 = left, 2 = right)
				cameraXR.layers.mask = camera.layers.mask | 0b110;
				cameraL.layers.mask = cameraXR.layers.mask & 0b011;
				cameraR.layers.mask = cameraXR.layers.mask & 0b101;

				const parent = camera.parent;
				const cameras = cameraXR.cameras;

				updateCamera( cameraXR, parent );

				for ( let i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				// update projection matrix for proper view frustum culling

				if ( cameras.length === 2 ) {

					setProjectionFromUnion( cameraXR, cameraL, cameraR );

				} else {

					// assume single camera setup (AR)

					cameraXR.projectionMatrix.copy( cameraL.projectionMatrix );

				}

				// update user camera and its children

				updateUserCamera( camera, cameraXR, parent );

			};

			function updateUserCamera( camera, cameraXR, parent ) {

				if ( parent === null ) {

					camera.matrix.copy( cameraXR.matrixWorld );

				} else {

					camera.matrix.copy( parent.matrixWorld );
					camera.matrix.invert();
					camera.matrix.multiply( cameraXR.matrixWorld );

				}

				camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
				camera.updateMatrixWorld( true );

				camera.projectionMatrix.copy( cameraXR.projectionMatrix );
				camera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );

				if ( camera.isPerspectiveCamera ) {

					camera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );
					camera.zoom = 1;

				}

			}

			/**
			 * Returns an instance of {@link ArrayCamera} which represents the XR camera
			 * of the active XR session. For each view it holds a separate camera object.
			 *
			 * The camera's `fov` is currently not used and does not reflect the fov of
			 * the XR camera. If you need the fov on app level, you have to compute in
			 * manually from the XR camera's projection matrices.
			 *
			 * @return {ArrayCamera} The XR camera.
			 */
			this.getCamera = function () {

				return cameraXR;

			};

			/**
			 * Returns the amount of foveation used by the XR compositor for the projection layer.
			 *
			 * @return {number|undefined} The amount of foveation.
			 */
			this.getFoveation = function () {

				if ( glProjLayer === null && glBaseLayer === null ) {

					return undefined;

				}

				return foveation;

			};

			/**
			 * Sets the foveation value.
			 *
			 * @param {number} value - A number in the range `[0,1]` where `0` means no foveation (full resolution)
			 * and `1` means maximum foveation (the edges render at lower resolution).
			 */
			this.setFoveation = function ( value ) {

				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution

				foveation = value;

				if ( glProjLayer !== null ) {

					glProjLayer.fixedFoveation = value;

				}

				if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

					glBaseLayer.fixedFoveation = value;

				}

			};

			/**
			 * Returns `true` if depth sensing is supported.
			 *
			 * @return {boolean} Whether depth sensing is supported or not.
			 */
			this.hasDepthSensing = function () {

				return depthSensing.texture !== null;

			};

			/**
			 * Returns the depth sensing mesh.
			 *
			 * See {@link WebXRDepthSensing#getMesh}.
			 *
			 * @return {Mesh} The depth sensing mesh.
			 */
			this.getDepthSensingMesh = function () {

				return depthSensing.getMesh( cameraXR );

			};

			/**
			 * Retrieves an opaque texture from the view-aligned {@link XRCamera}.
			 * Only available during the current animation loop.
			 *
			 * @param {XRCamera} xrCamera - The camera to query.
			 * @return {?Texture} An opaque texture representing the current raw camera frame.
			 */
			this.getCameraTexture = function ( xrCamera ) {

				return cameraAccessTextures[ xrCamera ];

			};

			// Animation Loop

			let onAnimationFrameCallback = null;

			function onAnimationFrame( time, frame ) {

				pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
				xrFrame = frame;

				if ( pose !== null ) {

					const views = pose.views;

					if ( glBaseLayer !== null ) {

						renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
						renderer.setRenderTarget( newRenderTarget );

					}

					let cameraXRNeedsUpdate = false;

					// check if it's necessary to rebuild cameraXR's camera list

					if ( views.length !== cameraXR.cameras.length ) {

						cameraXR.cameras.length = 0;
						cameraXRNeedsUpdate = true;

					}

					for ( let i = 0; i < views.length; i ++ ) {

						const view = views[ i ];

						let viewport = null;

						if ( glBaseLayer !== null ) {

							viewport = glBaseLayer.getViewport( view );

						} else {

							const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
							viewport = glSubImage.viewport;

							// For side-by-side projection, we only produce a single texture for both eyes.
							if ( i === 0 ) {

								renderer.setRenderTargetTextures(
									newRenderTarget,
									glSubImage.colorTexture,
									glSubImage.depthStencilTexture );

								renderer.setRenderTarget( newRenderTarget );

							}

						}

						let camera = cameras[ i ];

						if ( camera === undefined ) {

							camera = new PerspectiveCamera();
							camera.layers.enable( i );
							camera.viewport = new Vector4();
							cameras[ i ] = camera;

						}

						camera.matrix.fromArray( view.transform.matrix );
						camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
						camera.projectionMatrix.fromArray( view.projectionMatrix );
						camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();
						camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

						if ( i === 0 ) {

							cameraXR.matrix.copy( camera.matrix );
							cameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );

						}

						if ( cameraXRNeedsUpdate === true ) {

							cameraXR.cameras.push( camera );

						}

					}

					//

					const enabledFeatures = session.enabledFeatures;
					const gpuDepthSensingEnabled = enabledFeatures &&
						enabledFeatures.includes( 'depth-sensing' ) &&
						session.depthUsage == 'gpu-optimized';

					if ( gpuDepthSensingEnabled && supportsGlBinding ) {

						glBinding = scope.getBinding();

						const depthData = glBinding.getDepthInformation( views[ 0 ] );

						if ( depthData && depthData.isValid && depthData.texture ) {

							depthSensing.init( depthData, session.renderState );

						}

					}

					const cameraAccessEnabled = enabledFeatures &&
					    enabledFeatures.includes( 'camera-access' );

					if ( cameraAccessEnabled && supportsGlBinding ) {

						renderer.state.unbindTexture();

						glBinding = scope.getBinding();

						for ( let i = 0; i < views.length; i ++ ) {

							const camera = views[ i ].camera;

							if ( camera ) {

								let cameraTex = cameraAccessTextures[ camera ];

								if ( ! cameraTex ) {

									cameraTex = new ExternalTexture();
									cameraAccessTextures[ camera ] = cameraTex;

								}

								const glTexture = glBinding.getCameraImage( camera );
								cameraTex.sourceTexture = glTexture;

							}

						}

					}

				}

				//

				for ( let i = 0; i < controllers.length; i ++ ) {

					const inputSource = controllerInputSources[ i ];
					const controller = controllers[ i ];

					if ( inputSource !== null && controller !== undefined ) {

						controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

					}

				}

				if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

				if ( frame.detectedPlanes ) {

					scope.dispatchEvent( { type: 'planesdetected', data: frame } );

				}

				xrFrame = null;

			}

			const animation = new WebGLAnimation();

			animation.setAnimationLoop( onAnimationFrame );

			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;

			};

			this.dispose = function () {};

		}

	}

	const _e1 = /*@__PURE__*/ new Euler();
	const _m1 = /*@__PURE__*/ new Matrix4();

	function WebGLMaterials( renderer, properties ) {

		function refreshTransformUniform( map, uniform ) {

			if ( map.matrixAutoUpdate === true ) {

				map.updateMatrix();

			}

			uniform.value.copy( map.matrix );

		}

		function refreshFogUniforms( uniforms, fog ) {

			fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsToon( uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsPhong( uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsStandard( uniforms, material );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsMatcap( uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDistance( uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( uniforms, material, pixelRatio, height );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( uniforms, material );

			} else if ( material.isShadowMaterial ) {

				uniforms.color.value.copy( material.color );
				uniforms.opacity.value = material.opacity;

			} else if ( material.isShaderMaterial ) {

				material.uniformsNeedUpdate = false; // #15581

			}

		}

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value.copy( material.color );

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.mapTransform );

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

				refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;

				refreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );

				uniforms.bumpScale.value = material.bumpScale;

				if ( material.side === BackSide ) {

					uniforms.bumpScale.value *= -1;

				}

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;

				refreshTransformUniform( material.normalMap, uniforms.normalMapTransform );

				uniforms.normalScale.value.copy( material.normalScale );

				if ( material.side === BackSide ) {

					uniforms.normalScale.value.negate();

				}

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;

				refreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );

				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

				refreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

				refreshTransformUniform( material.specularMap, uniforms.specularMapTransform );

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

			const materialProperties = properties.get( material );

			const envMap = materialProperties.envMap;
			const envMapRotation = materialProperties.envMapRotation;

			if ( envMap ) {

				uniforms.envMap.value = envMap;

				_e1.copy( envMapRotation );

				// accommodate left-handed frame
				_e1.x *= -1; _e1.y *= -1; _e1.z *= -1;

				if ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) {

					// environment maps which are not cube render targets or PMREMs follow a different convention
					_e1.y *= -1;
					_e1.z *= -1;

				}

				uniforms.envMapRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );

				uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? -1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.ior.value = material.ior;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

				refreshTransformUniform( material.lightMap, uniforms.lightMapTransform );

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

				refreshTransformUniform( material.aoMap, uniforms.aoMapTransform );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.mapTransform );

			}

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.uvTransform );

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

				refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.mapTransform );

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

				refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value.copy( material.specular );
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		}

		function refreshUniformsToon( uniforms, material ) {

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.metalness.value = material.metalness;

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

				refreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );

			}

			uniforms.roughness.value = material.roughness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

				refreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );

			}

			if ( material.envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common

				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

			uniforms.ior.value = material.ior; // also part of uniforms common

			if ( material.sheen > 0 ) {

				uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

				uniforms.sheenRoughness.value = material.sheenRoughness;

				if ( material.sheenColorMap ) {

					uniforms.sheenColorMap.value = material.sheenColorMap;

					refreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );

				}

				if ( material.sheenRoughnessMap ) {

					uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

					refreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );

				}

			}

			if ( material.clearcoat > 0 ) {

				uniforms.clearcoat.value = material.clearcoat;
				uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

				if ( material.clearcoatMap ) {

					uniforms.clearcoatMap.value = material.clearcoatMap;

					refreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );

				}

				if ( material.clearcoatRoughnessMap ) {

					uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

					refreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );

				}

				if ( material.clearcoatNormalMap ) {

					uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

					refreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );

					uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );

					if ( material.side === BackSide ) {

						uniforms.clearcoatNormalScale.value.negate();

					}

				}

			}

			if ( material.dispersion > 0 ) {

				uniforms.dispersion.value = material.dispersion;

			}

			if ( material.iridescence > 0 ) {

				uniforms.iridescence.value = material.iridescence;
				uniforms.iridescenceIOR.value = material.iridescenceIOR;
				uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
				uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

				if ( material.iridescenceMap ) {

					uniforms.iridescenceMap.value = material.iridescenceMap;

					refreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );

				}

				if ( material.iridescenceThicknessMap ) {

					uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

					refreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );

				}

			}

			if ( material.transmission > 0 ) {

				uniforms.transmission.value = material.transmission;
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

				if ( material.transmissionMap ) {

					uniforms.transmissionMap.value = material.transmissionMap;

					refreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );

				}

				uniforms.thickness.value = material.thickness;

				if ( material.thicknessMap ) {

					uniforms.thicknessMap.value = material.thicknessMap;

					refreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );

				}

				uniforms.attenuationDistance.value = material.attenuationDistance;
				uniforms.attenuationColor.value.copy( material.attenuationColor );

			}

			if ( material.anisotropy > 0 ) {

				uniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

				if ( material.anisotropyMap ) {

					uniforms.anisotropyMap.value = material.anisotropyMap;

					refreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );

				}

			}

			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularColor.value.copy( material.specularColor );

			if ( material.specularColorMap ) {

				uniforms.specularColorMap.value = material.specularColorMap;

				refreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );

			}

			if ( material.specularIntensityMap ) {

				uniforms.specularIntensityMap.value = material.specularIntensityMap;

				refreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );

			}

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			const light = properties.get( material ).light;

			uniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );
			uniforms.nearDistance.value = light.shadow.camera.near;
			uniforms.farDistance.value = light.shadow.camera.far;

		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};

	}

	function WebGLUniformsGroups( gl, info, capabilities, state ) {

		let buffers = {};
		let updateList = {};
		let allocatedBindingPoints = [];

		const maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program

		function bind( uniformsGroup, program ) {

			const webglProgram = program.program;
			state.uniformBlockBinding( uniformsGroup, webglProgram );

		}

		function update( uniformsGroup, program ) {

			let buffer = buffers[ uniformsGroup.id ];

			if ( buffer === undefined ) {

				prepareUniformsGroup( uniformsGroup );

				buffer = createBuffer( uniformsGroup );
				buffers[ uniformsGroup.id ] = buffer;

				uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

			}

			// ensure to update the binding points/block indices mapping for this program

			const webglProgram = program.program;
			state.updateUBOMapping( uniformsGroup, webglProgram );

			// update UBO once per frame

			const frame = info.render.frame;

			if ( updateList[ uniformsGroup.id ] !== frame ) {

				updateBufferData( uniformsGroup );

				updateList[ uniformsGroup.id ] = frame;

			}

		}

		function createBuffer( uniformsGroup ) {

			// the setup of an UBO is independent of a particular shader program but global

			const bindingPointIndex = allocateBindingPointIndex();
			uniformsGroup.__bindingPointIndex = bindingPointIndex;

			const buffer = gl.createBuffer();
			const size = uniformsGroup.__size;
			const usage = uniformsGroup.usage;

			gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );
			gl.bufferData( gl.UNIFORM_BUFFER, size, usage );
			gl.bindBuffer( gl.UNIFORM_BUFFER, null );
			gl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );

			return buffer;

		}

		function allocateBindingPointIndex() {

			for ( let i = 0; i < maxBindingPoints; i ++ ) {

				if ( allocatedBindingPoints.indexOf( i ) === -1 ) {

					allocatedBindingPoints.push( i );
					return i;

				}

			}

			error( 'WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

			return 0;

		}

		function updateBufferData( uniformsGroup ) {

			const buffer = buffers[ uniformsGroup.id ];
			const uniforms = uniformsGroup.uniforms;
			const cache = uniformsGroup.__cache;

			gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );

			for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

				const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

				for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

					const uniform = uniformArray[ j ];

					if ( hasUniformChanged( uniform, i, j, cache ) === true ) {

						const offset = uniform.__offset;

						const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

						let arrayOffset = 0;

						for ( let k = 0; k < values.length; k ++ ) {

							const value = values[ k ];

							const info = getUniformSize( value );

							// TODO add integer and struct support
							if ( typeof value === 'number' || typeof value === 'boolean' ) {

								uniform.__data[ 0 ] = value;
								gl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );

							} else if ( value.isMatrix3 ) {

								// manually converting 3x3 to 3x4

								uniform.__data[ 0 ] = value.elements[ 0 ];
								uniform.__data[ 1 ] = value.elements[ 1 ];
								uniform.__data[ 2 ] = value.elements[ 2 ];
								uniform.__data[ 3 ] = 0;
								uniform.__data[ 4 ] = value.elements[ 3 ];
								uniform.__data[ 5 ] = value.elements[ 4 ];
								uniform.__data[ 6 ] = value.elements[ 5 ];
								uniform.__data[ 7 ] = 0;
								uniform.__data[ 8 ] = value.elements[ 6 ];
								uniform.__data[ 9 ] = value.elements[ 7 ];
								uniform.__data[ 10 ] = value.elements[ 8 ];
								uniform.__data[ 11 ] = 0;

							} else {

								value.toArray( uniform.__data, arrayOffset );

								arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;

							}

						}

						gl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );

					}

				}

			}

			gl.bindBuffer( gl.UNIFORM_BUFFER, null );

		}

		function hasUniformChanged( uniform, index, indexArray, cache ) {

			const value = uniform.value;
			const indexString = index + '_' + indexArray;

			if ( cache[ indexString ] === undefined ) {

				// cache entry does not exist so far

				if ( typeof value === 'number' || typeof value === 'boolean' ) {

					cache[ indexString ] = value;

				} else {

					cache[ indexString ] = value.clone();

				}

				return true;

			} else {

				const cachedObject = cache[ indexString ];

				// compare current value with cached entry

				if ( typeof value === 'number' || typeof value === 'boolean' ) {

					if ( cachedObject !== value ) {

						cache[ indexString ] = value;
						return true;

					}

				} else {

					if ( cachedObject.equals( value ) === false ) {

						cachedObject.copy( value );
						return true;

					}

				}

			}

			return false;

		}

		function prepareUniformsGroup( uniformsGroup ) {

			// determine total buffer size according to the STD140 layout
			// Hint: STD140 is the only supported layout in WebGL 2

			const uniforms = uniformsGroup.uniforms;

			let offset = 0; // global buffer offset in bytes
			const chunkSize = 16; // size of a chunk in bytes

			for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

				const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

				for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

					const uniform = uniformArray[ j ];

					const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

					for ( let k = 0, kl = values.length; k < kl; k ++ ) {

						const value = values[ k ];

						const info = getUniformSize( value );

						const chunkOffset = offset % chunkSize; // offset in the current chunk
						const chunkPadding = chunkOffset % info.boundary; // required padding to match boundary
						const chunkStart = chunkOffset + chunkPadding; // the start position in the current chunk for the data

						offset += chunkPadding;

						// Check for chunk overflow
						if ( chunkStart !== 0 && ( chunkSize - chunkStart ) < info.storage ) {

							// Add padding and adjust offset
							offset += ( chunkSize - chunkStart );

						}

						// the following two properties will be used for partial buffer updates
						uniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );
						uniform.__offset = offset;

						// Update the global offset
						offset += info.storage;

					}

				}

			}

			// ensure correct final padding

			const chunkOffset = offset % chunkSize;

			if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

			//

			uniformsGroup.__size = offset;
			uniformsGroup.__cache = {};

			return this;

		}

		function getUniformSize( value ) {

			const info = {
				boundary: 0, // bytes
				storage: 0 // bytes
			};

			// determine sizes according to STD140

			if ( typeof value === 'number' || typeof value === 'boolean' ) {

				// float/int/bool

				info.boundary = 4;
				info.storage = 4;

			} else if ( value.isVector2 ) {

				// vec2

				info.boundary = 8;
				info.storage = 8;

			} else if ( value.isVector3 || value.isColor ) {

				// vec3

				info.boundary = 16;
				info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

			} else if ( value.isVector4 ) {

				// vec4

				info.boundary = 16;
				info.storage = 16;

			} else if ( value.isMatrix3 ) {

				// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

				info.boundary = 48;
				info.storage = 48;

			} else if ( value.isMatrix4 ) {

				// mat4

				info.boundary = 64;
				info.storage = 64;

			} else if ( value.isTexture ) {

				warn( 'WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

			} else {

				warn( 'WebGLRenderer: Unsupported uniform value type.', value );

			}

			return info;

		}

		function onUniformsGroupsDispose( event ) {

			const uniformsGroup = event.target;

			uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

			const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
			allocatedBindingPoints.splice( index, 1 );

			gl.deleteBuffer( buffers[ uniformsGroup.id ] );

			delete buffers[ uniformsGroup.id ];
			delete updateList[ uniformsGroup.id ];

		}

		function dispose() {

			for ( const id in buffers ) {

				gl.deleteBuffer( buffers[ id ] );

			}

			allocatedBindingPoints = [];
			buffers = {};
			updateList = {};

		}

		return {

			bind: bind,
			update: update,

			dispose: dispose

		};

	}

	/**
	 * This renderer uses WebGL 2 to display scenes.
	 *
	 * WebGL 1 is not supported since `r163`.
	 */
	class WebGLRenderer {

		/**
		 * Constructs a new WebGL renderer.
		 *
		 * @param {WebGLRenderer~Options} [parameters] - The configuration parameter.
		 */
		constructor( parameters = {} ) {

			const {
				canvas = createCanvasElement(),
				context = null,
				depth = true,
				stencil = false,
				alpha = false,
				antialias = false,
				premultipliedAlpha = true,
				preserveDrawingBuffer = false,
				powerPreference = 'default',
				failIfMajorPerformanceCaveat = false,
				reversedDepthBuffer = false,
			} = parameters;

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isWebGLRenderer = true;

			let _alpha;

			if ( context !== null ) {

				if ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {

					throw new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );

				}

				_alpha = context.getContextAttributes().alpha;

			} else {

				_alpha = alpha;

			}

			const uintClearColor = new Uint32Array( 4 );
			const intClearColor = new Int32Array( 4 );

			let currentRenderList = null;
			let currentRenderState = null;

			// render() can be called from within a callback triggered by another render.
			// We track this so that the nested render call gets its list and state isolated from the parent render call.

			const renderListStack = [];
			const renderStateStack = [];

			// public properties

			/**
			 * A canvas where the renderer draws its output.This is automatically created by the renderer
			 * in the constructor (if not provided already); you just need to add it to your page like so:
			 * ```js
			 * document.body.appendChild( renderer.domElement );
			 * ```
			 *
			 * @type {HTMLCanvasElement|OffscreenCanvas}
			 */
			this.domElement = canvas;

			/**
			 * A object with debug configuration settings.
			 *
			 * - `checkShaderErrors`: If it is `true`, defines whether material shader programs are
			 * checked for errors during compilation and linkage process. It may be useful to disable
			 * this check in production for performance gain. It is strongly recommended to keep these
			 * checks enabled during development. If the shader does not compile and link - it will not
			 * work and associated material will not render.
			 * - `onShaderError(gl, program, glVertexShader,glFragmentShader)`: A callback function that
			 * can be used for custom error reporting. The callback receives the WebGL context, an instance
			 * of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
			 * Assigning a custom function disables the default error reporting.
			 *
			 * @type {Object}
			 */
			this.debug = {

				/**
				 * Enables error checking and reporting when shader programs are being compiled.
				 * @type {boolean}
				 */
				checkShaderErrors: true,
				/**
				 * Callback for custom error reporting.
				 * @type {?Function}
				 */
				onShaderError: null
			};

			// clearing

			/**
			 * Whether the renderer should automatically clear its output before rendering a frame or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.autoClear = true;

			/**
			 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
			 * the color buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.autoClearColor = true;

			/**
			 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
			 * the depth buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.autoClearDepth = true;

			/**
			 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
			 * the stencil buffer or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.autoClearStencil = true;

			// scene graph

			/**
			 * Whether the renderer should sort objects or not.
			 *
			 * Note: Sorting is used to attempt to properly render objects that have some
			 * degree of transparency. By definition, sorting objects may not work in all
			 * cases. Depending on the needs of application, it may be necessary to turn
			 * off sorting and use other methods to deal with transparency rendering e.g.
			 * manually determining each object's rendering order.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.sortObjects = true;

			// user-defined clipping

			/**
			 * User-defined clipping planes specified in world space. These planes apply globally.
			 * Points in space whose dot product with the plane is negative are cut away.
			 *
			 * @type {Array<Plane>}
			 */
			this.clippingPlanes = [];

			/**
			 * Whether the renderer respects object-level clipping planes or not.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.localClippingEnabled = false;

			// tone mapping

			/**
			 * The tone mapping technique of the renderer.
			 *
			 * @type {(NoToneMapping|LinearToneMapping|ReinhardToneMapping|CineonToneMapping|ACESFilmicToneMapping|CustomToneMapping|AgXToneMapping|NeutralToneMapping)}
			 * @default NoToneMapping
			 */
			this.toneMapping = NoToneMapping;

			/**
			 * Exposure level of tone mapping.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.toneMappingExposure = 1.0;

			// transmission

			/**
			 * The normalized resolution scale for the transmission render target, measured in percentage
			 * of viewport dimensions. Lowering this value can result in significant performance improvements
			 * when using {@link MeshPhysicalMaterial#transmission}.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.transmissionResolutionScale = 1.0;

			// internal properties

			const _this = this;

			let _isContextLost = false;

			// internal state cache

			this._outputColorSpace = SRGBColorSpace;

			let _currentActiveCubeFace = 0;
			let _currentActiveMipmapLevel = 0;
			let _currentRenderTarget = null;
			let _currentMaterialId = -1;

			let _currentCamera = null;

			const _currentViewport = new Vector4();
			const _currentScissor = new Vector4();
			let _currentScissorTest = null;

			const _currentClearColor = new Color( 0x000000 );
			let _currentClearAlpha = 0;

			//

			let _width = canvas.width;
			let _height = canvas.height;

			let _pixelRatio = 1;
			let _opaqueSort = null;
			let _transparentSort = null;

			const _viewport = new Vector4( 0, 0, _width, _height );
			const _scissor = new Vector4( 0, 0, _width, _height );
			let _scissorTest = false;

			// frustum

			const _frustum = new Frustum();

			// clipping

			let _clippingEnabled = false;
			let _localClippingEnabled = false;

			// camera matrices cache

			const _projScreenMatrix = new Matrix4();

			const _vector3 = new Vector3();

			const _vector4 = new Vector4();

			const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

			let _renderBackground = false;

			function getTargetPixelRatio() {

				return _currentRenderTarget === null ? _pixelRatio : 1;

			}

			// initialize

			let _gl = context;

			function getContext( contextName, contextAttributes ) {

				return canvas.getContext( contextName, contextAttributes );

			}

			try {

				const contextAttributes = {
					alpha: true,
					depth,
					stencil,
					antialias,
					premultipliedAlpha,
					preserveDrawingBuffer,
					powerPreference,
					failIfMajorPerformanceCaveat,
				};

				// OffscreenCanvas does not have setAttribute, see #22811
				if ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

				// event listeners must be registered before WebGL context is created, see #12753
				canvas.addEventListener( 'webglcontextlost', onContextLost, false );
				canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
				canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

				if ( _gl === null ) {

					const contextName = 'webgl2';

					_gl = getContext( contextName, contextAttributes );

					if ( _gl === null ) {

						if ( getContext( contextName ) ) {

							throw new Error( 'Error creating WebGL context with your selected attributes.' );

						} else {

							throw new Error( 'Error creating WebGL context.' );

						}

					}

				}

			} catch ( error ) {

				error( 'WebGLRenderer: ' + error.message );
				throw error;

			}

			let extensions, capabilities, state, info;
			let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
			let programCache, materials, renderLists, renderStates, clipping, shadowMap;

			let background, morphtargets, bufferRenderer, indexedBufferRenderer;

			let utils, bindingStates, uniformsGroups;

			function initGLContext() {

				extensions = new WebGLExtensions( _gl );
				extensions.init();

				utils = new WebGLUtils( _gl, extensions );

				capabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );

				state = new WebGLState( _gl, extensions );

				if ( capabilities.reversedDepthBuffer && reversedDepthBuffer ) {

					state.buffers.depth.setReversed( true );

				}

				info = new WebGLInfo( _gl );
				properties = new WebGLProperties();
				textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
				cubemaps = new WebGLCubeMaps( _this );
				cubeuvmaps = new WebGLCubeUVMaps( _this );
				attributes = new WebGLAttributes( _gl );
				bindingStates = new WebGLBindingStates( _gl, attributes );
				geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
				objects = new WebGLObjects( _gl, geometries, attributes, info );
				morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
				clipping = new WebGLClipping( properties );
				programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
				materials = new WebGLMaterials( _this, properties );
				renderLists = new WebGLRenderLists();
				renderStates = new WebGLRenderStates( extensions );
				background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );
				shadowMap = new WebGLShadowMap( _this, objects, capabilities );
				uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

				bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );
				indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );

				info.programs = programCache.programs;

				/**
				 * Holds details about the capabilities of the current rendering context.
				 *
				 * @name WebGLRenderer#capabilities
				 * @type {WebGLRenderer~Capabilities}
				 */
				_this.capabilities = capabilities;

				/**
				 * Provides methods for retrieving and testing WebGL extensions.
				 *
				 * - `get(extensionName:string)`: Used to check whether a WebGL extension is supported
				 * and return the extension object if available.
				 * - `has(extensionName:string)`: returns `true` if the extension is supported.
				 *
				 * @name WebGLRenderer#extensions
				 * @type {Object}
				 */
				_this.extensions = extensions;

				/**
				 * Used to track properties of other objects like native WebGL objects.
				 *
				 * @name WebGLRenderer#properties
				 * @type {Object}
				 */
				_this.properties = properties;

				/**
				 * Manages the render lists of the renderer.
				 *
				 * @name WebGLRenderer#renderLists
				 * @type {Object}
				 */
				_this.renderLists = renderLists;



				/**
				 * Interface for managing shadows.
				 *
				 * @name WebGLRenderer#shadowMap
				 * @type {WebGLRenderer~ShadowMap}
				 */
				_this.shadowMap = shadowMap;

				/**
				 * Interface for managing the WebGL state.
				 *
				 * @name WebGLRenderer#state
				 * @type {Object}
				 */
				_this.state = state;

				/**
				 * Holds a series of statistical information about the GPU memory
				 * and the rendering process. Useful for debugging and monitoring.
				 *
				 * By default these data are reset at each render call but when having
				 * multiple render passes per frame (e.g. when using post processing) it can
				 * be preferred to reset with a custom pattern. First, set `autoReset` to
				 * `false`.
				 * ```js
				 * renderer.info.autoReset = false;
				 * ```
				 * Call `reset()` whenever you have finished to render a single frame.
				 * ```js
				 * renderer.info.reset();
				 * ```
				 *
				 * @name WebGLRenderer#info
				 * @type {WebGLRenderer~Info}
				 */
				_this.info = info;

			}

			initGLContext();

			// xr

			const xr = new WebXRManager( _this, _gl );

			/**
			 * A reference to the XR manager.
			 *
			 * @type {WebXRManager}
			 */
			this.xr = xr;

			/**
			 * Returns the rendering context.
			 *
			 * @return {WebGL2RenderingContext} The rendering context.
			 */
			this.getContext = function () {

				return _gl;

			};

			/**
			 * Returns the rendering context attributes.
			 *
			 * @return {WebGLContextAttributes} The rendering context attributes.
			 */
			this.getContextAttributes = function () {

				return _gl.getContextAttributes();

			};

			/**
			 * Simulates a loss of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
			 */
			this.forceContextLoss = function () {

				const extension = extensions.get( 'WEBGL_lose_context' );
				if ( extension ) extension.loseContext();

			};

			/**
			 * Simulates a restore of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
			 */
			this.forceContextRestore = function () {

				const extension = extensions.get( 'WEBGL_lose_context' );
				if ( extension ) extension.restoreContext();

			};

			/**
			 * Returns the pixel ratio.
			 *
			 * @return {number} The pixel ratio.
			 */
			this.getPixelRatio = function () {

				return _pixelRatio;

			};

			/**
			 * Sets the given pixel ratio and resizes the canvas if necessary.
			 *
			 * @param {number} value - The pixel ratio.
			 */
			this.setPixelRatio = function ( value ) {

				if ( value === undefined ) return;

				_pixelRatio = value;

				this.setSize( _width, _height, false );

			};

			/**
			 * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
			 *
			 * @param {Vector2} target - The method writes the result in this target object.
			 * @return {Vector2} The renderer's size in logical pixels.
			 */
			this.getSize = function ( target ) {

				return target.set( _width, _height );

			};

			/**
			 * Resizes the output canvas to (width, height) with device pixel ratio taken
			 * into account, and also sets the viewport to fit that size, starting in (0,
			 * 0). Setting `updateStyle` to false prevents any style changes to the output canvas.
			 *
			 * @param {number} width - The width in logical pixels.
			 * @param {number} height - The height in logical pixels.
			 * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
			 */
			this.setSize = function ( width, height, updateStyle = true ) {

				if ( xr.isPresenting ) {

					warn( 'WebGLRenderer: Can\'t change size while VR device is presenting.' );
					return;

				}

				_width = width;
				_height = height;

				canvas.width = Math.floor( width * _pixelRatio );
				canvas.height = Math.floor( height * _pixelRatio );

				if ( updateStyle === true ) {

					canvas.style.width = width + 'px';
					canvas.style.height = height + 'px';

				}

				this.setViewport( 0, 0, width, height );

			};

			/**
			 * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
			 *
			 * @param {Vector2} target - The method writes the result in this target object.
			 * @return {Vector2} The drawing buffer size.
			 */
			this.getDrawingBufferSize = function ( target ) {

				return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

			};

			/**
			 * This method allows to define the drawing buffer size by specifying
			 * width, height and pixel ratio all at once. The size of the drawing
			 * buffer is computed with this formula:
			 * ```js
			 * size.x = width * pixelRatio;
			 * size.y = height * pixelRatio;
			 * ```
			 *
			 * @param {number} width - The width in logical pixels.
			 * @param {number} height - The height in logical pixels.
			 * @param {number} pixelRatio - The pixel ratio.
			 */
			this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

				_width = width;
				_height = height;

				_pixelRatio = pixelRatio;

				canvas.width = Math.floor( width * pixelRatio );
				canvas.height = Math.floor( height * pixelRatio );

				this.setViewport( 0, 0, width, height );

			};

			/**
			 * Returns the current viewport definition.
			 *
			 * @param {Vector2} target - The method writes the result in this target object.
			 * @return {Vector2} The current viewport definition.
			 */
			this.getCurrentViewport = function ( target ) {

				return target.copy( _currentViewport );

			};

			/**
			 * Returns the viewport definition.
			 *
			 * @param {Vector4} target - The method writes the result in this target object.
			 * @return {Vector4} The viewport definition.
			 */
			this.getViewport = function ( target ) {

				return target.copy( _viewport );

			};

			/**
			 * Sets the viewport to render from `(x, y)` to `(x + width, y + height)`.
			 *
			 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
			 * Or alternatively a four-component vector specifying all the parameters of the viewport.
			 * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
			 * @param {number} width - The width of the viewport in logical pixel unit.
			 * @param {number} height - The height of the viewport in logical pixel unit.
			 */
			this.setViewport = function ( x, y, width, height ) {

				if ( x.isVector4 ) {

					_viewport.set( x.x, x.y, x.z, x.w );

				} else {

					_viewport.set( x, y, width, height );

				}

				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );

			};

			/**
			 * Returns the scissor region.
			 *
			 * @param {Vector4} target - The method writes the result in this target object.
			 * @return {Vector4} The scissor region.
			 */
			this.getScissor = function ( target ) {

				return target.copy( _scissor );

			};

			/**
			 * Sets the scissor region to render from `(x, y)` to `(x + width, y + height)`.
			 *
			 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the scissor region origin in logical pixel unit.
			 * Or alternatively a four-component vector specifying all the parameters of the scissor region.
			 * @param {number} y - The vertical coordinate for the lower left corner of the scissor region origin  in logical pixel unit.
			 * @param {number} width - The width of the scissor region in logical pixel unit.
			 * @param {number} height - The height of the scissor region in logical pixel unit.
			 */
			this.setScissor = function ( x, y, width, height ) {

				if ( x.isVector4 ) {

					_scissor.set( x.x, x.y, x.z, x.w );

				} else {

					_scissor.set( x, y, width, height );

				}

				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );

			};

			/**
			 * Returns `true` if the scissor test is enabled.
			 *
			 * @return {boolean} Whether the scissor test is enabled or not.
			 */
			this.getScissorTest = function () {

				return _scissorTest;

			};

			/**
			 * Enable or disable the scissor test. When this is enabled, only the pixels
			 * within the defined scissor area will be affected by further renderer
			 * actions.
			 *
			 * @param {boolean} boolean - Whether the scissor test is enabled or not.
			 */
			this.setScissorTest = function ( boolean ) {

				state.setScissorTest( _scissorTest = boolean );

			};

			/**
			 * Sets a custom opaque sort function for the render lists. Pass `null`
			 * to use the default `painterSortStable` function.
			 *
			 * @param {?Function} method - The opaque sort function.
			 */
			this.setOpaqueSort = function ( method ) {

				_opaqueSort = method;

			};

			/**
			 * Sets a custom transparent sort function for the render lists. Pass `null`
			 * to use the default `reversePainterSortStable` function.
			 *
			 * @param {?Function} method - The opaque sort function.
			 */
			this.setTransparentSort = function ( method ) {

				_transparentSort = method;

			};

			// Clearing

			/**
			 * Returns the clear color.
			 *
			 * @param {Color} target - The method writes the result in this target object.
			 * @return {Color} The clear color.
			 */
			this.getClearColor = function ( target ) {

				return target.copy( background.getClearColor() );

			};

			/**
			 * Sets the clear color and alpha.
			 *
			 * @param {Color} color - The clear color.
			 * @param {number} [alpha=1] - The clear alpha.
			 */
			this.setClearColor = function () {

				background.setClearColor( ...arguments );

			};

			/**
			 * Returns the clear alpha. Ranges within `[0,1]`.
			 *
			 * @return {number} The clear alpha.
			 */
			this.getClearAlpha = function () {

				return background.getClearAlpha();

			};

			/**
			 * Sets the clear alpha.
			 *
			 * @param {number} alpha - The clear alpha.
			 */
			this.setClearAlpha = function () {

				background.setClearAlpha( ...arguments );

			};

			/**
			 * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
			 * This method initializes the buffers to the current clear color values.
			 *
			 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
			 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
			 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
			 */
			this.clear = function ( color = true, depth = true, stencil = true ) {

				let bits = 0;

				if ( color ) {

					// check if we're trying to clear an integer target
					let isIntegerFormat = false;
					if ( _currentRenderTarget !== null ) {

						const targetFormat = _currentRenderTarget.texture.format;
						isIntegerFormat = targetFormat === RGBAIntegerFormat ||
							targetFormat === RGIntegerFormat ||
							targetFormat === RedIntegerFormat;

					}

					// use the appropriate clear functions to clear the target if it's a signed
					// or unsigned integer target
					if ( isIntegerFormat ) {

						const targetType = _currentRenderTarget.texture.type;
						const isUnsignedType = targetType === UnsignedByteType ||
							targetType === UnsignedIntType ||
							targetType === UnsignedShortType ||
							targetType === UnsignedInt248Type ||
							targetType === UnsignedShort4444Type ||
							targetType === UnsignedShort5551Type;

						const clearColor = background.getClearColor();
						const a = background.getClearAlpha();
						const r = clearColor.r;
						const g = clearColor.g;
						const b = clearColor.b;

						if ( isUnsignedType ) {

							uintClearColor[ 0 ] = r;
							uintClearColor[ 1 ] = g;
							uintClearColor[ 2 ] = b;
							uintClearColor[ 3 ] = a;
							_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );

						} else {

							intClearColor[ 0 ] = r;
							intClearColor[ 1 ] = g;
							intClearColor[ 2 ] = b;
							intClearColor[ 3 ] = a;
							_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );

						}

					} else {

						bits |= _gl.COLOR_BUFFER_BIT;

					}

				}

				if ( depth ) {

					bits |= _gl.DEPTH_BUFFER_BIT;

				}

				if ( stencil ) {

					bits |= _gl.STENCIL_BUFFER_BIT;
					this.state.buffers.stencil.setMask( 0xffffffff );

				}

				_gl.clear( bits );

			};

			/**
			 * Clears the color buffer. Equivalent to calling `renderer.clear( true, false, false )`.
			 */
			this.clearColor = function () {

				this.clear( true, false, false );

			};

			/**
			 * Clears the depth buffer. Equivalent to calling `renderer.clear( false, true, false )`.
			 */
			this.clearDepth = function () {

				this.clear( false, true, false );

			};

			/**
			 * Clears the stencil buffer. Equivalent to calling `renderer.clear( false, false, true )`.
			 */
			this.clearStencil = function () {

				this.clear( false, false, true );

			};

			/**
			 * Frees the GPU-related resources allocated by this instance. Call this
			 * method whenever this instance is no longer used in your app.
			 */
			this.dispose = function () {

				canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
				canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
				canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

				background.dispose();
				renderLists.dispose();
				renderStates.dispose();
				properties.dispose();
				cubemaps.dispose();
				cubeuvmaps.dispose();
				objects.dispose();
				bindingStates.dispose();
				uniformsGroups.dispose();
				programCache.dispose();

				xr.dispose();

				xr.removeEventListener( 'sessionstart', onXRSessionStart );
				xr.removeEventListener( 'sessionend', onXRSessionEnd );

				animation.stop();

			};

			// Events

			function onContextLost( event ) {

				event.preventDefault();

				log( 'WebGLRenderer: Context Lost.' );

				_isContextLost = true;

			}

			function onContextRestore( /* event */ ) {

				log( 'WebGLRenderer: Context Restored.' );

				_isContextLost = false;

				const infoAutoReset = info.autoReset;
				const shadowMapEnabled = shadowMap.enabled;
				const shadowMapAutoUpdate = shadowMap.autoUpdate;
				const shadowMapNeedsUpdate = shadowMap.needsUpdate;
				const shadowMapType = shadowMap.type;

				initGLContext();

				info.autoReset = infoAutoReset;
				shadowMap.enabled = shadowMapEnabled;
				shadowMap.autoUpdate = shadowMapAutoUpdate;
				shadowMap.needsUpdate = shadowMapNeedsUpdate;
				shadowMap.type = shadowMapType;

			}

			function onContextCreationError( event ) {

				error( 'WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

			}

			function onMaterialDispose( event ) {

				const material = event.target;

				material.removeEventListener( 'dispose', onMaterialDispose );

				deallocateMaterial( material );

			}

			// Buffer deallocation

			function deallocateMaterial( material ) {

				releaseMaterialProgramReferences( material );

				properties.remove( material );

			}


			function releaseMaterialProgramReferences( material ) {

				const programs = properties.get( material ).programs;

				if ( programs !== undefined ) {

					programs.forEach( function ( program ) {

						programCache.releaseProgram( program );

					} );

					if ( material.isShaderMaterial ) {

						programCache.releaseShaderCache( material );

					}

				}

			}

			// Buffer rendering

			this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

				if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

				const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

				const program = setProgram( camera, scene, geometry, material, object );

				state.setMaterial( material, frontFaceCW );

				//

				let index = geometry.index;
				let rangeFactor = 1;

				if ( material.wireframe === true ) {

					index = geometries.getWireframeAttribute( geometry );

					if ( index === undefined ) return;

					rangeFactor = 2;

				}

				//

				const drawRange = geometry.drawRange;
				const position = geometry.attributes.position;

				let drawStart = drawRange.start * rangeFactor;
				let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

				if ( group !== null ) {

					drawStart = Math.max( drawStart, group.start * rangeFactor );
					drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

				}

				if ( index !== null ) {

					drawStart = Math.max( drawStart, 0 );
					drawEnd = Math.min( drawEnd, index.count );

				} else if ( position !== undefined && position !== null ) {

					drawStart = Math.max( drawStart, 0 );
					drawEnd = Math.min( drawEnd, position.count );

				}

				const drawCount = drawEnd - drawStart;

				if ( drawCount < 0 || drawCount === Infinity ) return;

				//

				bindingStates.setup( object, material, program, geometry, index );

				let attribute;
				let renderer = bufferRenderer;

				if ( index !== null ) {

					attribute = attributes.get( index );

					renderer = indexedBufferRenderer;
					renderer.setIndex( attribute );

				}

				//

				if ( object.isMesh ) {

					if ( material.wireframe === true ) {

						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );

					} else {

						renderer.setMode( _gl.TRIANGLES );

					}

				} else if ( object.isLine ) {

					let lineWidth = material.linewidth;

					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

					state.setLineWidth( lineWidth * getTargetPixelRatio() );

					if ( object.isLineSegments ) {

						renderer.setMode( _gl.LINES );

					} else if ( object.isLineLoop ) {

						renderer.setMode( _gl.LINE_LOOP );

					} else {

						renderer.setMode( _gl.LINE_STRIP );

					}

				} else if ( object.isPoints ) {

					renderer.setMode( _gl.POINTS );

				} else if ( object.isSprite ) {

					renderer.setMode( _gl.TRIANGLES );

				}

				if ( object.isBatchedMesh ) {

					if ( object._multiDrawInstances !== null ) {

						// @deprecated, r174
						warnOnce( 'WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );
						renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

					} else {

						if ( ! extensions.get( 'WEBGL_multi_draw' ) ) {

							const starts = object._multiDrawStarts;
							const counts = object._multiDrawCounts;
							const drawCount = object._multiDrawCount;
							const bytesPerElement = index ? attributes.get( index ).bytesPerElement : 1;
							const uniforms = properties.get( material ).currentProgram.getUniforms();
							for ( let i = 0; i < drawCount; i ++ ) {

								uniforms.setValue( _gl, '_gl_DrawID', i );
								renderer.render( starts[ i ] / bytesPerElement, counts[ i ] );

							}

						} else {

							renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

						}

					}

				} else if ( object.isInstancedMesh ) {

					renderer.renderInstances( drawStart, drawCount, object.count );

				} else if ( geometry.isInstancedBufferGeometry ) {

					const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
					const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

					renderer.renderInstances( drawStart, drawCount, instanceCount );

				} else {

					renderer.render( drawStart, drawCount );

				}

			};

			// Compile

			function prepareMaterial( material, scene, object ) {

				if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

					material.side = BackSide;
					material.needsUpdate = true;
					getProgram( material, scene, object );

					material.side = FrontSide;
					material.needsUpdate = true;
					getProgram( material, scene, object );

					material.side = DoubleSide;

				} else {

					getProgram( material, scene, object );

				}

			}

			/**
			 * Compiles all materials in the scene with the camera. This is useful to precompile shaders
			 * before the first rendering. If you want to add a 3D object to an existing scene, use the third
			 * optional parameter for applying the target scene.
			 *
			 * Note that the (target) scene's lighting and environment must be configured before calling this method.
			 *
			 * @param {Object3D} scene - The scene or another type of 3D object to precompile.
			 * @param {Camera} camera - The camera.
			 * @param {?Scene} [targetScene=null] - The target scene.
			 * @return {Set<Material>} The precompiled materials.
			 */
			this.compile = function ( scene, camera, targetScene = null ) {

				if ( targetScene === null ) targetScene = scene;

				currentRenderState = renderStates.get( targetScene );
				currentRenderState.init( camera );

				renderStateStack.push( currentRenderState );

				// gather lights from both the target scene and the new object that will be added to the scene.

				targetScene.traverseVisible( function ( object ) {

					if ( object.isLight && object.layers.test( camera.layers ) ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					}

				} );

				if ( scene !== targetScene ) {

					scene.traverseVisible( function ( object ) {

						if ( object.isLight && object.layers.test( camera.layers ) ) {

							currentRenderState.pushLight( object );

							if ( object.castShadow ) {

								currentRenderState.pushShadow( object );

							}

						}

					} );

				}

				currentRenderState.setupLights();

				// Only initialize materials in the new scene, not the targetScene.

				const materials = new Set();

				scene.traverse( function ( object ) {

					if ( ! ( object.isMesh || object.isPoints || object.isLine || object.isSprite ) ) {

						return;

					}

					const material = object.material;

					if ( material ) {

						if ( Array.isArray( material ) ) {

							for ( let i = 0; i < material.length; i ++ ) {

								const material2 = material[ i ];

								prepareMaterial( material2, targetScene, object );
								materials.add( material2 );

							}

						} else {

							prepareMaterial( material, targetScene, object );
							materials.add( material );

						}

					}

				} );

				currentRenderState = renderStateStack.pop();

				return materials;

			};

			// compileAsync

			/**
			 * Asynchronous version of {@link WebGLRenderer#compile}.
			 *
			 * This method makes use of the `KHR_parallel_shader_compile` WebGL extension. Hence,
			 * it is recommended to use this version of `compile()` whenever possible.
			 *
			 * @async
			 * @param {Object3D} scene - The scene or another type of 3D object to precompile.
			 * @param {Camera} camera - The camera.
			 * @param {?Scene} [targetScene=null] - The target scene.
			 * @return {Promise} A Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.
			 */
			this.compileAsync = function ( scene, camera, targetScene = null ) {

				const materials = this.compile( scene, camera, targetScene );

				// Wait for all the materials in the new object to indicate that they're
				// ready to be used before resolving the promise.

				return new Promise( ( resolve ) => {

					function checkMaterialsReady() {

						materials.forEach( function ( material ) {

							const materialProperties = properties.get( material );
							const program = materialProperties.currentProgram;

							if ( program.isReady() ) {

								// remove any programs that report they're ready to use from the list
								materials.delete( material );

							}

						} );

						// once the list of compiling materials is empty, call the callback

						if ( materials.size === 0 ) {

							resolve( scene );
							return;

						}

						// if some materials are still not ready, wait a bit and check again

						setTimeout( checkMaterialsReady, 10 );

					}

					if ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {

						// If we can check the compilation status of the materials without
						// blocking then do so right away.

						checkMaterialsReady();

					} else {

						// Otherwise start by waiting a bit to give the materials we just
						// initialized a chance to finish.

						setTimeout( checkMaterialsReady, 10 );

					}

				} );

			};

			// Animation Loop

			let onAnimationFrameCallback = null;

			function onAnimationFrame( time ) {

				if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

			}

			function onXRSessionStart() {

				animation.stop();

			}

			function onXRSessionEnd() {

				animation.start();

			}

			const animation = new WebGLAnimation();
			animation.setAnimationLoop( onAnimationFrame );

			if ( typeof self !== 'undefined' ) animation.setContext( self );

			/**
			 * Applications are advised to always define the animation loop
			 * with this method and not manually with `requestAnimationFrame()`
			 * for best compatibility.
			 *
			 * @param {?onAnimationCallback} callback - The application's animation loop.
			 */
			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;
				xr.setAnimationLoop( callback );

				( callback === null ) ? animation.stop() : animation.start();

			};

			xr.addEventListener( 'sessionstart', onXRSessionStart );
			xr.addEventListener( 'sessionend', onXRSessionEnd );

			// Rendering

			/**
			 * Renders the given scene (or other type of 3D object) using the given camera.
			 *
			 * The render is done to a previously specified render target set by calling {@link WebGLRenderer#setRenderTarget}
			 * or to the canvas as usual.
			 *
			 * By default render buffers are cleared before rendering but you can prevent
			 * this by setting the property `autoClear` to `false`. If you want to prevent
			 * only certain buffers being cleared you can `autoClearColor`, `autoClearDepth`
			 * or `autoClearStencil` to `false`. To force a clear, use {@link WebGLRenderer#clear}.
			 *
			 * @param {Object3D} scene - The scene to render.
			 * @param {Camera} camera - The camera.
			 */
			this.render = function ( scene, camera ) {

				if ( camera !== undefined && camera.isCamera !== true ) {

					error( 'WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;

				}

				if ( _isContextLost === true ) return;

				// update scene graph

				if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

				// update camera matrices and frustum

				if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

				if ( xr.enabled === true && xr.isPresenting === true ) {

					if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

					camera = xr.getCamera(); // use XR camera for rendering

				}

				//
				if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

				currentRenderState = renderStates.get( scene, renderStateStack.length );
				currentRenderState.init( camera );

				renderStateStack.push( currentRenderState );

				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromProjectionMatrix( _projScreenMatrix, WebGLCoordinateSystem, camera.reversedDepth );

				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );

				currentRenderList = renderLists.get( scene, renderListStack.length );
				currentRenderList.init();

				renderListStack.push( currentRenderList );

				if ( xr.enabled === true && xr.isPresenting === true ) {

					const depthSensingMesh = _this.xr.getDepthSensingMesh();

					if ( depthSensingMesh !== null ) {

						projectObject( depthSensingMesh, camera, - Infinity, _this.sortObjects );

					}

				}

				projectObject( scene, camera, 0, _this.sortObjects );

				currentRenderList.finish();

				if ( _this.sortObjects === true ) {

					currentRenderList.sort( _opaqueSort, _transparentSort );

				}

				_renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
				if ( _renderBackground ) {

					background.addToRenderList( currentRenderList, scene );

				}

				//

				this.info.render.frame ++;

				if ( _clippingEnabled === true ) clipping.beginShadows();

				const shadowsArray = currentRenderState.state.shadowsArray;

				shadowMap.render( shadowsArray, scene, camera );

				if ( _clippingEnabled === true ) clipping.endShadows();

				//

				if ( this.info.autoReset === true ) this.info.reset();

				// render scene

				const opaqueObjects = currentRenderList.opaque;
				const transmissiveObjects = currentRenderList.transmissive;

				currentRenderState.setupLights();

				if ( camera.isArrayCamera ) {

					const cameras = camera.cameras;

					if ( transmissiveObjects.length > 0 ) {

						for ( let i = 0, l = cameras.length; i < l; i ++ ) {

							const camera2 = cameras[ i ];

							renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );

						}

					}

					if ( _renderBackground ) background.render( scene );

					for ( let i = 0, l = cameras.length; i < l; i ++ ) {

						const camera2 = cameras[ i ];

						renderScene( currentRenderList, scene, camera2, camera2.viewport );

					}

				} else {

					if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );

					if ( _renderBackground ) background.render( scene );

					renderScene( currentRenderList, scene, camera );

				}

				//

				if ( _currentRenderTarget !== null && _currentActiveMipmapLevel === 0 ) {

					// resolve multisample renderbuffers to a single-sample texture if necessary

					textures.updateMultisampleRenderTarget( _currentRenderTarget );

					// Generate mipmap if we're using any kind of mipmap filtering

					textures.updateRenderTargetMipmap( _currentRenderTarget );

				}

				//

				if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

				// _gl.finish();

				bindingStates.resetDefaultState();
				_currentMaterialId = -1;
				_currentCamera = null;

				renderStateStack.pop();

				if ( renderStateStack.length > 0 ) {

					currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

					if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );

				} else {

					currentRenderState = null;

				}

				renderListStack.pop();

				if ( renderListStack.length > 0 ) {

					currentRenderList = renderListStack[ renderListStack.length - 1 ];

				} else {

					currentRenderList = null;

				}

			};

			function projectObject( object, camera, groupOrder, sortObjects ) {

				if ( object.visible === false ) return;

				const visible = object.layers.test( camera.layers );

				if ( visible ) {

					if ( object.isGroup ) {

						groupOrder = object.renderOrder;

					} else if ( object.isLOD ) {

						if ( object.autoUpdate === true ) object.update( camera );

					} else if ( object.isLight ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					} else if ( object.isSprite ) {

						if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

							if ( sortObjects ) {

								_vector4.setFromMatrixPosition( object.matrixWorld )
									.applyMatrix4( _projScreenMatrix );

							}

							const geometry = objects.update( object );
							const material = object.material;

							if ( material.visible ) {

								currentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );

							}

						}

					} else if ( object.isMesh || object.isLine || object.isPoints ) {

						if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

							const geometry = objects.update( object );
							const material = object.material;

							if ( sortObjects ) {

								if ( object.boundingSphere !== undefined ) {

									if ( object.boundingSphere === null ) object.computeBoundingSphere();
									_vector4.copy( object.boundingSphere.center );

								} else {

									if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
									_vector4.copy( geometry.boundingSphere.center );

								}

								_vector4
									.applyMatrix4( object.matrixWorld )
									.applyMatrix4( _projScreenMatrix );

							}

							if ( Array.isArray( material ) ) {

								const groups = geometry.groups;

								for ( let i = 0, l = groups.length; i < l; i ++ ) {

									const group = groups[ i ];
									const groupMaterial = material[ group.materialIndex ];

									if ( groupMaterial && groupMaterial.visible ) {

										currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group );

									}

								}

							} else if ( material.visible ) {

								currentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );

							}

						}

					}

				}

				const children = object.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera, groupOrder, sortObjects );

				}

			}

			function renderScene( currentRenderList, scene, camera, viewport ) {

				const opaqueObjects = currentRenderList.opaque;
				const transmissiveObjects = currentRenderList.transmissive;
				const transparentObjects = currentRenderList.transparent;

				currentRenderState.setupLightsView( camera );

				if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

				if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

				if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
				if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
				if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

				// Ensure depth buffer writing is enabled so it can be cleared on next render

				state.buffers.depth.setTest( true );
				state.buffers.depth.setMask( true );
				state.buffers.color.setMask( true );

				state.setPolygonOffset( false );

			}

			function renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {

				const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

				if ( overrideMaterial !== null ) {

					return;

				}

				if ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {

					currentRenderState.state.transmissionRenderTarget[ camera.id ] = new WebGLRenderTarget( 1, 1, {
						generateMipmaps: true,
						type: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? HalfFloatType : UnsignedByteType,
						minFilter: LinearMipmapLinearFilter,
						samples: 4,
						stencilBuffer: stencil,
						resolveDepthBuffer: false,
						resolveStencilBuffer: false,
						colorSpace: ColorManagement.workingColorSpace,
					} );

					// debug

					/*
					const geometry = new PlaneGeometry();
					const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

					const mesh = new Mesh( geometry, material );
					scene.add( mesh );
					*/

				}

				const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];

				const activeViewport = camera.viewport || _currentViewport;
				transmissionRenderTarget.setSize( activeViewport.z * _this.transmissionResolutionScale, activeViewport.w * _this.transmissionResolutionScale );

				//

				const currentRenderTarget = _this.getRenderTarget();
				const currentActiveCubeFace = _this.getActiveCubeFace();
				const currentActiveMipmapLevel = _this.getActiveMipmapLevel();

				_this.setRenderTarget( transmissionRenderTarget );

				_this.getClearColor( _currentClearColor );
				_currentClearAlpha = _this.getClearAlpha();
				if ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );

				_this.clear();

				if ( _renderBackground ) background.render( scene );

				// Turn off the features which can affect the frag color for opaque objects pass.
				// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
				const currentToneMapping = _this.toneMapping;
				_this.toneMapping = NoToneMapping;

				// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
				// Transmission render pass requires viewport to match the transmissionRenderTarget.
				const currentCameraViewport = camera.viewport;
				if ( camera.viewport !== undefined ) camera.viewport = undefined;

				currentRenderState.setupLightsView( camera );

				if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

				renderObjects( opaqueObjects, scene, camera );

				textures.updateMultisampleRenderTarget( transmissionRenderTarget );
				textures.updateRenderTargetMipmap( transmissionRenderTarget );

				if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131

					let renderTargetNeedsUpdate = false;

					for ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {

						const renderItem = transmissiveObjects[ i ];

						const object = renderItem.object;
						const geometry = renderItem.geometry;
						const material = renderItem.material;
						const group = renderItem.group;

						if ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {

							const currentSide = material.side;

							material.side = BackSide;
							material.needsUpdate = true;

							renderObject( object, scene, camera, geometry, material, group );

							material.side = currentSide;
							material.needsUpdate = true;

							renderTargetNeedsUpdate = true;

						}

					}

					if ( renderTargetNeedsUpdate === true ) {

						textures.updateMultisampleRenderTarget( transmissionRenderTarget );
						textures.updateRenderTargetMipmap( transmissionRenderTarget );

					}

				}

				_this.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

				_this.setClearColor( _currentClearColor, _currentClearAlpha );

				if ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;

				_this.toneMapping = currentToneMapping;

			}

			function renderObjects( renderList, scene, camera ) {

				const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

				for ( let i = 0, l = renderList.length; i < l; i ++ ) {

					const renderItem = renderList[ i ];

					const object = renderItem.object;
					const geometry = renderItem.geometry;
					const group = renderItem.group;
					let material = renderItem.material;

					if ( material.allowOverride === true && overrideMaterial !== null ) {

						material = overrideMaterial;

					}

					if ( object.layers.test( camera.layers ) ) {

						renderObject( object, scene, camera, geometry, material, group );

					}

				}

			}

			function renderObject( object, scene, camera, geometry, material, group ) {

				object.onBeforeRender( _this, scene, camera, geometry, material, group );

				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

				material.onBeforeRender( _this, scene, camera, geometry, object, group );

				if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

					material.side = BackSide;
					material.needsUpdate = true;
					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

					material.side = FrontSide;
					material.needsUpdate = true;
					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

					material.side = DoubleSide;

				} else {

					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				}

				object.onAfterRender( _this, scene, camera, geometry, material, group );

			}

			function getProgram( material, scene, object ) {

				if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

				const materialProperties = properties.get( material );

				const lights = currentRenderState.state.lights;
				const shadowsArray = currentRenderState.state.shadowsArray;

				const lightsStateVersion = lights.state.version;

				const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
				const programCacheKey = programCache.getProgramCacheKey( parameters );

				let programs = materialProperties.programs;

				// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

				materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
				materialProperties.fog = scene.fog;
				materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );
				materialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;

				if ( programs === undefined ) {

					// new material

					material.addEventListener( 'dispose', onMaterialDispose );

					programs = new Map();
					materialProperties.programs = programs;

				}

				let program = programs.get( programCacheKey );

				if ( program !== undefined ) {

					// early out if program and light state is identical

					if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

						updateCommonMaterialProperties( material, parameters );

						return program;

					}

				} else {

					parameters.uniforms = programCache.getUniforms( material );

					material.onBeforeCompile( parameters, _this );

					program = programCache.acquireProgram( parameters, programCacheKey );
					programs.set( programCacheKey, program );

					materialProperties.uniforms = parameters.uniforms;

				}

				const uniforms = materialProperties.uniforms;

				if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

					uniforms.clippingPlanes = clipping.uniform;

				}

				updateCommonMaterialProperties( material, parameters );

				// store the light setup it was created for

				materialProperties.needsLights = materialNeedsLights( material );
				materialProperties.lightsStateVersion = lightsStateVersion;

				if ( materialProperties.needsLights ) {

					// wire up the material to this renderer's lighting state

					uniforms.ambientLightColor.value = lights.state.ambient;
					uniforms.lightProbe.value = lights.state.probe;
					uniforms.directionalLights.value = lights.state.directional;
					uniforms.directionalLightShadows.value = lights.state.directionalShadow;
					uniforms.spotLights.value = lights.state.spot;
					uniforms.spotLightShadows.value = lights.state.spotShadow;
					uniforms.rectAreaLights.value = lights.state.rectArea;
					uniforms.ltc_1.value = lights.state.rectAreaLTC1;
					uniforms.ltc_2.value = lights.state.rectAreaLTC2;
					uniforms.pointLights.value = lights.state.point;
					uniforms.pointLightShadows.value = lights.state.pointShadow;
					uniforms.hemisphereLights.value = lights.state.hemi;

					uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
					uniforms.spotShadowMap.value = lights.state.spotShadowMap;
					uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
					uniforms.spotLightMap.value = lights.state.spotLightMap;
					uniforms.pointShadowMap.value = lights.state.pointShadowMap;
					uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
					// TODO (abelnation): add area lights shadow info to uniforms

				}

				materialProperties.currentProgram = program;
				materialProperties.uniformsList = null;

				return program;

			}

			function getUniformList( materialProperties ) {

				if ( materialProperties.uniformsList === null ) {

					const progUniforms = materialProperties.currentProgram.getUniforms();
					materialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );

				}

				return materialProperties.uniformsList;

			}

			function updateCommonMaterialProperties( material, parameters ) {

				const materialProperties = properties.get( material );

				materialProperties.outputColorSpace = parameters.outputColorSpace;
				materialProperties.batching = parameters.batching;
				materialProperties.batchingColor = parameters.batchingColor;
				materialProperties.instancing = parameters.instancing;
				materialProperties.instancingColor = parameters.instancingColor;
				materialProperties.instancingMorph = parameters.instancingMorph;
				materialProperties.skinning = parameters.skinning;
				materialProperties.morphTargets = parameters.morphTargets;
				materialProperties.morphNormals = parameters.morphNormals;
				materialProperties.morphColors = parameters.morphColors;
				materialProperties.morphTargetsCount = parameters.morphTargetsCount;
				materialProperties.numClippingPlanes = parameters.numClippingPlanes;
				materialProperties.numIntersection = parameters.numClipIntersection;
				materialProperties.vertexAlphas = parameters.vertexAlphas;
				materialProperties.vertexTangents = parameters.vertexTangents;
				materialProperties.toneMapping = parameters.toneMapping;

			}

			function setProgram( camera, scene, geometry, material, object ) {

				if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

				textures.resetTextureUnits();

				const fog = scene.fog;
				const environment = material.isMeshStandardMaterial ? scene.environment : null;
				const colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );
				const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
				const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
				const vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );
				const morphTargets = !! geometry.morphAttributes.position;
				const morphNormals = !! geometry.morphAttributes.normal;
				const morphColors = !! geometry.morphAttributes.color;

				let toneMapping = NoToneMapping;

				if ( material.toneMapped ) {

					if ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {

						toneMapping = _this.toneMapping;

					}

				}

				const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
				const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

				const materialProperties = properties.get( material );
				const lights = currentRenderState.state.lights;

				if ( _clippingEnabled === true ) {

					if ( _localClippingEnabled === true || camera !== _currentCamera ) {

						const useCache =
							camera === _currentCamera &&
							material.id === _currentMaterialId;

						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						clipping.setState( material, camera, useCache );

					}

				}

				//

				let needsProgramChange = false;

				if ( material.version === materialProperties.__version ) {

					if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

						needsProgramChange = true;

					} else if ( materialProperties.outputColorSpace !== colorSpace ) {

						needsProgramChange = true;

					} else if ( object.isBatchedMesh && materialProperties.batching === false ) {

						needsProgramChange = true;

					} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {

						needsProgramChange = true;

					} else if ( object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null ) {

						needsProgramChange = true;

					} else if ( object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null ) {

						needsProgramChange = true;

					} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

						needsProgramChange = true;

					} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

						needsProgramChange = true;

					} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

						needsProgramChange = true;

					} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

						needsProgramChange = true;

					} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {

						needsProgramChange = true;

					} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {

						needsProgramChange = true;

					} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {

						needsProgramChange = true;

					} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {

						needsProgramChange = true;

					} else if ( materialProperties.envMap !== envMap ) {

						needsProgramChange = true;

					} else if ( material.fog === true && materialProperties.fog !== fog ) {

						needsProgramChange = true;

					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== clipping.numPlanes ||
						materialProperties.numIntersection !== clipping.numIntersection ) ) {

						needsProgramChange = true;

					} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

						needsProgramChange = true;

					} else if ( materialProperties.vertexTangents !== vertexTangents ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphTargets !== morphTargets ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphNormals !== morphNormals ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphColors !== morphColors ) {

						needsProgramChange = true;

					} else if ( materialProperties.toneMapping !== toneMapping ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {

						needsProgramChange = true;

					}

				} else {

					needsProgramChange = true;
					materialProperties.__version = material.version;

				}

				//

				let program = materialProperties.currentProgram;

				if ( needsProgramChange === true ) {

					program = getProgram( material, scene, object );

				}

				let refreshProgram = false;
				let refreshMaterial = false;
				let refreshLights = false;

				const p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.uniforms;

				if ( state.useProgram( program.program ) ) {

					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;

				}

				if ( material.id !== _currentMaterialId ) {

					_currentMaterialId = material.id;

					refreshMaterial = true;

				}

				if ( refreshProgram || _currentCamera !== camera ) {

					// common camera uniforms

					const reversedDepthBuffer = state.buffers.depth.getReversed();

					if ( reversedDepthBuffer && camera.reversedDepth !== true ) {

						camera._reversedDepth = true;
						camera.updateProjectionMatrix();

					}

					p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

					const uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

					if ( capabilities.logarithmicDepthBuffer ) {

						p_uniforms.setValue( _gl, 'logDepthBufFC',
							2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

					}

					// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067

					if ( material.isMeshPhongMaterial ||
						material.isMeshToonMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ) {

						p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

					}

					if ( _currentCamera !== camera ) {

						_currentCamera = camera;

						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:

						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done

					}

				}

				// skinning and morph target uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone and morph texture must go before other textures
				// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

				if ( object.isSkinnedMesh ) {

					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

					const skeleton = object.skeleton;

					if ( skeleton ) {

						if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );

					}

				}

				if ( object.isBatchedMesh ) {

					p_uniforms.setOptional( _gl, object, 'batchingTexture' );
					p_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );

					p_uniforms.setOptional( _gl, object, 'batchingIdTexture' );
					p_uniforms.setValue( _gl, 'batchingIdTexture', object._indirectTexture, textures );

					p_uniforms.setOptional( _gl, object, 'batchingColorTexture' );
					if ( object._colorsTexture !== null ) {

						p_uniforms.setValue( _gl, 'batchingColorTexture', object._colorsTexture, textures );

					}

				}

				const morphAttributes = geometry.morphAttributes;

				if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {

					morphtargets.update( object, geometry, program );

				}

				if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

					materialProperties.receiveShadow = object.receiveShadow;
					p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

				}

				// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

				if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

					m_uniforms.envMap.value = envMap;

					m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? -1 : 1;

				}

				if ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {

					m_uniforms.envMapIntensity.value = scene.environmentIntensity;

				}

				if ( refreshMaterial ) {

					p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

					if ( materialProperties.needsLights ) {

						// the current material requires lighting info

						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required

						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

					}

					// refresh uniforms common to several materials

					if ( fog && material.fog === true ) {

						materials.refreshFogUniforms( m_uniforms, fog );

					}

					materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );

					WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );

				}

				if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

					WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );
					material.uniformsNeedUpdate = false;

				}

				if ( material.isSpriteMaterial ) {

					p_uniforms.setValue( _gl, 'center', object.center );

				}

				// common matrices

				p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
				p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

				// UBOs

				if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

					const groups = material.uniformsGroups;

					for ( let i = 0, l = groups.length; i < l; i ++ ) {

						const group = groups[ i ];

						uniformsGroups.update( group, program );
						uniformsGroups.bind( group, program );

					}

				}

				return program;

			}

			// If uniforms are marked as clean, they don't need to be loaded to the GPU.

			function markUniformsLightsNeedsUpdate( uniforms, value ) {

				uniforms.ambientLightColor.needsUpdate = value;
				uniforms.lightProbe.needsUpdate = value;

				uniforms.directionalLights.needsUpdate = value;
				uniforms.directionalLightShadows.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.pointLightShadows.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.spotLightShadows.needsUpdate = value;
				uniforms.rectAreaLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;

			}

			function materialNeedsLights( material ) {

				return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial || material.isShadowMaterial ||
					( material.isShaderMaterial && material.lights === true );

			}

			/**
			 * Returns the active cube face.
			 *
			 * @return {number} The active cube face.
			 */
			this.getActiveCubeFace = function () {

				return _currentActiveCubeFace;

			};

			/**
			 * Returns the active mipmap level.
			 *
			 * @return {number} The active mipmap level.
			 */
			this.getActiveMipmapLevel = function () {

				return _currentActiveMipmapLevel;

			};

			/**
			 * Returns the active render target.
			 *
			 * @return {?WebGLRenderTarget} The active render target. Returns `null` if no render target
			 * is currently set.
			 */
			this.getRenderTarget = function () {

				return _currentRenderTarget;

			};

			this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

				const renderTargetProperties = properties.get( renderTarget );

				renderTargetProperties.__autoAllocateDepthBuffer = renderTarget.resolveDepthBuffer === false;
				if ( renderTargetProperties.__autoAllocateDepthBuffer === false ) {

					// The multisample_render_to_texture extension doesn't work properly if there
					// are midframe flushes and an external depth buffer. Disable use of the extension.
					renderTargetProperties.__useRenderToTexture = false;

				}

				properties.get( renderTarget.texture ).__webglTexture = colorTexture;
				properties.get( renderTarget.depthTexture ).__webglTexture = renderTargetProperties.__autoAllocateDepthBuffer ? undefined : depthTexture;

				renderTargetProperties.__hasExternalTextures = true;

			};

			this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

				const renderTargetProperties = properties.get( renderTarget );
				renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
				renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

			};

			const _scratchFrameBuffer = _gl.createFramebuffer();

			/**
			 * Sets the active rendertarget.
			 *
			 * @param {?WebGLRenderTarget} renderTarget - The render target to set. When `null` is given,
			 * the canvas is set as the active render target instead.
			 * @param {number} [activeCubeFace=0] - The active cube face when using a cube render target.
			 * Indicates the z layer to render in to when using 3D or array render targets.
			 * @param {number} [activeMipmapLevel=0] - The active mipmap level.
			 */
			this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

				_currentRenderTarget = renderTarget;
				_currentActiveCubeFace = activeCubeFace;
				_currentActiveMipmapLevel = activeMipmapLevel;

				let useDefaultFramebuffer = true;
				let framebuffer = null;
				let isCube = false;
				let isRenderTarget3D = false;

				if ( renderTarget ) {

					const renderTargetProperties = properties.get( renderTarget );

					if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

						// We need to make sure to rebind the framebuffer.
						state.bindFramebuffer( _gl.FRAMEBUFFER, null );
						useDefaultFramebuffer = false;

					} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

						textures.setupRenderTarget( renderTarget );

					} else if ( renderTargetProperties.__hasExternalTextures ) {

						// Color and depth texture must be rebound in order for the swapchain to update.
						textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

					} else if ( renderTarget.depthBuffer ) {

						// check if the depth texture is already bound to the frame buffer and that it's been initialized
						const depthTexture = renderTarget.depthTexture;
						if ( renderTargetProperties.__boundDepthTexture !== depthTexture ) {

							// check if the depth texture is compatible
							if (
								depthTexture !== null &&
								properties.has( depthTexture ) &&
								( renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height )
							) {

								throw new Error( 'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.' );

							}

							// Swap the depth buffer to the currently attached one
							textures.setupDepthRenderbuffer( renderTarget );

						}

					}

					const texture = renderTarget.texture;

					if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

						isRenderTarget3D = true;

					}

					const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

					if ( renderTarget.isWebGLCubeRenderTarget ) {

						if ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {

							framebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];

						} else {

							framebuffer = __webglFramebuffer[ activeCubeFace ];

						}

						isCube = true;

					} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

						framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

					} else {

						if ( Array.isArray( __webglFramebuffer ) ) {

							framebuffer = __webglFramebuffer[ activeMipmapLevel ];

						} else {

							framebuffer = __webglFramebuffer;

						}

					}

					_currentViewport.copy( renderTarget.viewport );
					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;

				} else {

					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
					_currentScissorTest = _scissorTest;

				}

				// Use a scratch frame buffer if rendering to a mip level to avoid depth buffers
				// being bound that are different sizes.
				if ( activeMipmapLevel !== 0 ) {

					framebuffer = _scratchFrameBuffer;

				}

				const framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				if ( framebufferBound && useDefaultFramebuffer ) {

					state.drawBuffers( renderTarget, framebuffer );

				}

				state.viewport( _currentViewport );
				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );

				if ( isCube ) {

					const textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

				} else if ( isRenderTarget3D ) {

					const layer = activeCubeFace;

					for ( let i = 0; i < renderTarget.textures.length; i ++ ) {

						const textureProperties = properties.get( renderTarget.textures[ i ] );

						_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, textureProperties.__webglTexture, activeMipmapLevel, layer );

					}

				} else if ( renderTarget !== null && activeMipmapLevel !== 0 ) {

					// Only bind the frame buffer if we are using a scratch frame buffer to render to a mipmap.
					// If we rebind the texture when using a multi sample buffer then an error about inconsistent samples will be thrown.
					const textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, textureProperties.__webglTexture, activeMipmapLevel );

				}

				_currentMaterialId = -1; // reset current material to ensure correct uniform bindings

			};

			/**
			 * Reads the pixel data from the given render target into the given buffer.
			 *
			 * @param {WebGLRenderTarget} renderTarget - The render target to read from.
			 * @param {number} x - The `x` coordinate of the copy region's origin.
			 * @param {number} y - The `y` coordinate of the copy region's origin.
			 * @param {number} width - The width of the copy region.
			 * @param {number} height - The height of the copy region.
			 * @param {TypedArray} buffer - The result buffer.
			 * @param {number} [activeCubeFaceIndex] - The active cube face index.
			 * @param {number} [textureIndex=0] - The texture index of an MRT render target.
			 */
			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex, textureIndex = 0 ) {

				if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

					error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;

				}

				let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

					framebuffer = framebuffer[ activeCubeFaceIndex ];

				}

				if ( framebuffer ) {

					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					try {

						const texture = renderTarget.textures[ textureIndex ];
						const textureFormat = texture.format;
						const textureType = texture.type;

						if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

							error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;

						}

						if ( ! capabilities.textureTypeReadable( textureType ) ) {

							error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;

						}

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							// when using MRT, select the correct color buffer for the subsequent read command

							if ( renderTarget.textures.length > 1 ) _gl.readBuffer( _gl.COLOR_ATTACHMENT0 + textureIndex );

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} finally {

						// restore framebuffer of current render target if necessary

						const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
						state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					}

				}

			};

			/**
			 * Asynchronous, non-blocking version of {@link WebGLRenderer#readRenderTargetPixels}.
			 *
			 * It is recommended to use this version of `readRenderTargetPixels()` whenever possible.
			 *
			 * @async
			 * @param {WebGLRenderTarget} renderTarget - The render target to read from.
			 * @param {number} x - The `x` coordinate of the copy region's origin.
			 * @param {number} y - The `y` coordinate of the copy region's origin.
			 * @param {number} width - The width of the copy region.
			 * @param {number} height - The height of the copy region.
			 * @param {TypedArray} buffer - The result buffer.
			 * @param {number} [activeCubeFaceIndex] - The active cube face index.
			 * @param {number} [textureIndex=0] - The texture index of an MRT render target.
			 * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
			 */
			this.readRenderTargetPixelsAsync = async function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex, textureIndex = 0 ) {

				if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

					throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );

				}

				let framebuffer = properties.get( renderTarget ).__webglFramebuffer;
				if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

					framebuffer = framebuffer[ activeCubeFaceIndex ];

				}

				if ( framebuffer ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						// set the active frame buffer to the one we want to read
						state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

						const texture = renderTarget.textures[ textureIndex ];
						const textureFormat = texture.format;
						const textureType = texture.type;

						if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

							throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.' );

						}

						if ( ! capabilities.textureTypeReadable( textureType ) ) {

							throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.' );

						}

						const glBuffer = _gl.createBuffer();
						_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );
						_gl.bufferData( _gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ );

						// when using MRT, select the correct color buffer for the subsequent read command

						if ( renderTarget.textures.length > 1 ) _gl.readBuffer( _gl.COLOR_ATTACHMENT0 + textureIndex );

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), 0 );

						// reset the frame buffer to the currently set buffer before waiting
						const currFramebuffer = _currentRenderTarget !== null ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
						state.bindFramebuffer( _gl.FRAMEBUFFER, currFramebuffer );

						// check if the commands have finished every 8 ms
						const sync = _gl.fenceSync( _gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );

						_gl.flush();

						await probeAsync( _gl, sync, 4 );

						// read the data and delete the buffer
						_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );
						_gl.getBufferSubData( _gl.PIXEL_PACK_BUFFER, 0, buffer );
						_gl.deleteBuffer( glBuffer );
						_gl.deleteSync( sync );

						return buffer;

					} else {

						throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.' );

					}

				}

			};

			/**
			 * Copies pixels from the current bound framebuffer into the given texture.
			 *
			 * @param {FramebufferTexture} texture - The texture.
			 * @param {?Vector2} [position=null] - The start position of the copy operation.
			 * @param {number} [level=0] - The mip level. The default represents the base mip.
			 */
			this.copyFramebufferToTexture = function ( texture, position = null, level = 0 ) {

				const levelScale = Math.pow( 2, - level );
				const width = Math.floor( texture.image.width * levelScale );
				const height = Math.floor( texture.image.height * levelScale );

				const x = position !== null ? position.x : 0;
				const y = position !== null ? position.y : 0;

				textures.setTexture2D( texture, 0 );

				_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, x, y, width, height );

				state.unbindTexture();

			};

			const _srcFramebuffer = _gl.createFramebuffer();
			const _dstFramebuffer = _gl.createFramebuffer();

			/**
			 * Copies data of the given source texture into a destination texture.
			 *
			 * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized
			 * {@link WebGLRenderer#initRenderTarget}.
			 *
			 * @param {Texture} srcTexture - The source texture.
			 * @param {Texture} dstTexture - The destination texture.
			 * @param {?(Box2|Box3)} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
			 * @param {?(Vector2|Vector3)} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
			 * @param {number} [srcLevel=0] - The source mipmap level to copy.
			 * @param {?number} [dstLevel=null] - The destination mipmap level.
			 */
			this.copyTextureToTexture = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = null ) {

				// support the previous signature with just a single dst mipmap level
				if ( dstLevel === null ) {

					if ( srcLevel !== 0 ) {

						// @deprecated, r171
						warnOnce( 'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.' );
						dstLevel = srcLevel;
						srcLevel = 0;

					} else {

						dstLevel = 0;

					}

				}

				// gather the necessary dimensions to copy
				let width, height, depth, minX, minY, minZ;
				let dstX, dstY, dstZ;
				const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ dstLevel ] : srcTexture.image;
				if ( srcRegion !== null ) {

					width = srcRegion.max.x - srcRegion.min.x;
					height = srcRegion.max.y - srcRegion.min.y;
					depth = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
					minX = srcRegion.min.x;
					minY = srcRegion.min.y;
					minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;

				} else {

					const levelScale = Math.pow( 2, - srcLevel );
					width = Math.floor( image.width * levelScale );
					height = Math.floor( image.height * levelScale );
					if ( srcTexture.isDataArrayTexture ) {

						depth = image.depth;

					} else if ( srcTexture.isData3DTexture ) {

						depth = Math.floor( image.depth * levelScale );

					} else {

						depth = 1;

					}

					minX = 0;
					minY = 0;
					minZ = 0;

				}

				if ( dstPosition !== null ) {

					dstX = dstPosition.x;
					dstY = dstPosition.y;
					dstZ = dstPosition.z;

				} else {

					dstX = 0;
					dstY = 0;
					dstZ = 0;

				}

				// Set up the destination target
				const glFormat = utils.convert( dstTexture.format );
				const glType = utils.convert( dstTexture.type );
				let glTarget;

				if ( dstTexture.isData3DTexture ) {

					textures.setTexture3D( dstTexture, 0 );
					glTarget = _gl.TEXTURE_3D;

				} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {

					textures.setTexture2DArray( dstTexture, 0 );
					glTarget = _gl.TEXTURE_2D_ARRAY;

				} else {

					textures.setTexture2D( dstTexture, 0 );
					glTarget = _gl.TEXTURE_2D;

				}

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

				// used for copying data from cpu
				const currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
				const currentUnpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
				const currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
				const currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
				const currentUnpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

				_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );
				_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );
				_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, minX );
				_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, minY );
				_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, minZ );

				// set up the src texture
				const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;
				const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;
				if ( srcTexture.isDepthTexture ) {

					const srcTextureProperties = properties.get( srcTexture );
					const dstTextureProperties = properties.get( dstTexture );
					const srcRenderTargetProperties = properties.get( srcTextureProperties.__renderTarget );
					const dstRenderTargetProperties = properties.get( dstTextureProperties.__renderTarget );
					state.bindFramebuffer( _gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer );
					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer );

					for ( let i = 0; i < depth; i ++ ) {

						// if the source or destination are a 3d target then a layer needs to be bound
						if ( isSrc3D ) {

							_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( srcTexture ).__webglTexture, srcLevel, minZ + i );
							_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( dstTexture ).__webglTexture, dstLevel, dstZ + i );

						}

						_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST );

					}

					state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

				} else if ( srcLevel !== 0 || srcTexture.isRenderTargetTexture || properties.has( srcTexture ) ) {

					// get the appropriate frame buffers
					const srcTextureProperties = properties.get( srcTexture );
					const dstTextureProperties = properties.get( dstTexture );

					// bind the frame buffer targets
					state.bindFramebuffer( _gl.READ_FRAMEBUFFER, _srcFramebuffer );
					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, _dstFramebuffer );

					for ( let i = 0; i < depth; i ++ ) {

						// assign the correct layers and mip maps to the frame buffers
						if ( isSrc3D ) {

							_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, srcTextureProperties.__webglTexture, srcLevel, minZ + i );

						} else {

							_gl.framebufferTexture2D( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, srcTextureProperties.__webglTexture, srcLevel );

						}

						if ( isDst3D ) {

							_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, dstTextureProperties.__webglTexture, dstLevel, dstZ + i );

						} else {

							_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, dstTextureProperties.__webglTexture, dstLevel );

						}

						// copy the data using the fastest function that can achieve the copy
						if ( srcLevel !== 0 ) {

							_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST );

						} else if ( isDst3D ) {

							_gl.copyTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height );

						} else {

							_gl.copyTexSubImage2D( glTarget, dstLevel, dstX, dstY, minX, minY, width, height );

						}

					}

					// unbind read, draw buffers
					state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

				} else {

					if ( isDst3D ) {

						// copy data into the 3d texture
						if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

							_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data );

						} else if ( dstTexture.isCompressedArrayTexture ) {

							_gl.compressedTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, image.data );

						} else {

							_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image );

						}

					} else {

						// copy data into the 2d texture
						if ( srcTexture.isDataTexture ) {

							_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data );

						} else if ( srcTexture.isCompressedTexture ) {

							_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data );

						} else {

							_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image );

						}

					}

				}

				// reset values
				_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
				_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
				_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
				_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
				_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

				// Generate mipmaps only when copying level 0
				if ( dstLevel === 0 && dstTexture.generateMipmaps ) {

					_gl.generateMipmap( glTarget );

				}

				state.unbindTexture();

			};

			/**
			 * Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data
			 * can be copied into it using {@link WebGLRenderer#copyTextureToTexture} before it has been
			 * rendered to.
			 *
			 * @param {WebGLRenderTarget} target - The render target.
			 */
			this.initRenderTarget = function ( target ) {

				if ( properties.get( target ).__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( target );

				}

			};

			/**
			 * Initializes the given texture. Useful for preloading a texture rather than waiting until first
			 * render (which can cause noticeable lags due to decode and GPU upload overhead).
			 *
			 * @param {Texture} texture - The texture.
			 */
			this.initTexture = function ( texture ) {

				if ( texture.isCubeTexture ) {

					textures.setTextureCube( texture, 0 );

				} else if ( texture.isData3DTexture ) {

					textures.setTexture3D( texture, 0 );

				} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

					textures.setTexture2DArray( texture, 0 );

				} else {

					textures.setTexture2D( texture, 0 );

				}

				state.unbindTexture();

			};

			/**
			 * Can be used to reset the internal WebGL state. This method is mostly
			 * relevant for applications which share a single WebGL context across
			 * multiple WebGL libraries.
			 */
			this.resetState = function () {

				_currentActiveCubeFace = 0;
				_currentActiveMipmapLevel = 0;
				_currentRenderTarget = null;

				state.reset();
				bindingStates.reset();

			};

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

			}

		}

		/**
		 * Defines the coordinate system of the renderer.
		 *
		 * In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.
		 *
		 * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
		 * @default WebGLCoordinateSystem
		 * @readonly
		 */
		get coordinateSystem() {

			return WebGLCoordinateSystem;

		}

		/**
		 * Defines the output color space of the renderer.
		 *
		 * @type {SRGBColorSpace|LinearSRGBColorSpace}
		 * @default SRGBColorSpace
		 */
		get outputColorSpace() {

			return this._outputColorSpace;

		}

		set outputColorSpace( colorSpace ) {

			this._outputColorSpace = colorSpace;

			const gl = this.getContext();
			gl.drawingBufferColorSpace = ColorManagement._getDrawingBufferColorSpace( colorSpace );
			gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();

		}

	}

	/**
	 * Records what objects are colliding with each other
	 */

	/**
	 * A 3x3 matrix.
	 * Authored by {@link http://github.com/schteppe/ schteppe}
	 */
	class Mat3 {
	  /**
	   * A vector of length 9, containing all matrix elements.
	   */

	  /**
	   * @param elements A vector of length 9, containing all matrix elements.
	   */
	  constructor(elements) {
	    if (elements === void 0) {
	      elements = [0, 0, 0, 0, 0, 0, 0, 0, 0];
	    }

	    this.elements = elements;
	  }
	  /**
	   * Sets the matrix to identity
	   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
	   * @todo Create another function that immediately creates an identity matrix eg. `eye()`
	   */


	  identity() {
	    const e = this.elements;
	    e[0] = 1;
	    e[1] = 0;
	    e[2] = 0;
	    e[3] = 0;
	    e[4] = 1;
	    e[5] = 0;
	    e[6] = 0;
	    e[7] = 0;
	    e[8] = 1;
	  }
	  /**
	   * Set all elements to zero
	   */


	  setZero() {
	    const e = this.elements;
	    e[0] = 0;
	    e[1] = 0;
	    e[2] = 0;
	    e[3] = 0;
	    e[4] = 0;
	    e[5] = 0;
	    e[6] = 0;
	    e[7] = 0;
	    e[8] = 0;
	  }
	  /**
	   * Sets the matrix diagonal elements from a Vec3
	   */


	  setTrace(vector) {
	    const e = this.elements;
	    e[0] = vector.x;
	    e[4] = vector.y;
	    e[8] = vector.z;
	  }
	  /**
	   * Gets the matrix diagonal elements
	   */


	  getTrace(target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    const e = this.elements;
	    target.x = e[0];
	    target.y = e[4];
	    target.z = e[8];
	    return target;
	  }
	  /**
	   * Matrix-Vector multiplication
	   * @param v The vector to multiply with
	   * @param target Optional, target to save the result in.
	   */


	  vmult(v, target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    const e = this.elements;
	    const x = v.x;
	    const y = v.y;
	    const z = v.z;
	    target.x = e[0] * x + e[1] * y + e[2] * z;
	    target.y = e[3] * x + e[4] * y + e[5] * z;
	    target.z = e[6] * x + e[7] * y + e[8] * z;
	    return target;
	  }
	  /**
	   * Matrix-scalar multiplication
	   */


	  smult(s) {
	    for (let i = 0; i < this.elements.length; i++) {
	      this.elements[i] *= s;
	    }
	  }
	  /**
	   * Matrix multiplication
	   * @param matrix Matrix to multiply with from left side.
	   */


	  mmult(matrix, target) {
	    if (target === void 0) {
	      target = new Mat3();
	    }

	    const A = this.elements;
	    const B = matrix.elements;
	    const T = target.elements;
	    const a11 = A[0],
	          a12 = A[1],
	          a13 = A[2],
	          a21 = A[3],
	          a22 = A[4],
	          a23 = A[5],
	          a31 = A[6],
	          a32 = A[7],
	          a33 = A[8];
	    const b11 = B[0],
	          b12 = B[1],
	          b13 = B[2],
	          b21 = B[3],
	          b22 = B[4],
	          b23 = B[5],
	          b31 = B[6],
	          b32 = B[7],
	          b33 = B[8];
	    T[0] = a11 * b11 + a12 * b21 + a13 * b31;
	    T[1] = a11 * b12 + a12 * b22 + a13 * b32;
	    T[2] = a11 * b13 + a12 * b23 + a13 * b33;
	    T[3] = a21 * b11 + a22 * b21 + a23 * b31;
	    T[4] = a21 * b12 + a22 * b22 + a23 * b32;
	    T[5] = a21 * b13 + a22 * b23 + a23 * b33;
	    T[6] = a31 * b11 + a32 * b21 + a33 * b31;
	    T[7] = a31 * b12 + a32 * b22 + a33 * b32;
	    T[8] = a31 * b13 + a32 * b23 + a33 * b33;
	    return target;
	  }
	  /**
	   * Scale each column of the matrix
	   */


	  scale(vector, target) {
	    if (target === void 0) {
	      target = new Mat3();
	    }

	    const e = this.elements;
	    const t = target.elements;

	    for (let i = 0; i !== 3; i++) {
	      t[3 * i + 0] = vector.x * e[3 * i + 0];
	      t[3 * i + 1] = vector.y * e[3 * i + 1];
	      t[3 * i + 2] = vector.z * e[3 * i + 2];
	    }

	    return target;
	  }
	  /**
	   * Solve Ax=b
	   * @param b The right hand side
	   * @param target Optional. Target vector to save in.
	   * @return The solution x
	   * @todo should reuse arrays
	   */


	  solve(b, target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    // Construct equations
	    const nr = 3; // num rows

	    const nc = 4; // num cols

	    const eqns = [];
	    let i;
	    let j;

	    for (i = 0; i < nr * nc; i++) {
	      eqns.push(0);
	    }

	    for (i = 0; i < 3; i++) {
	      for (j = 0; j < 3; j++) {
	        eqns[i + nc * j] = this.elements[i + 3 * j];
	      }
	    }

	    eqns[3 + 4 * 0] = b.x;
	    eqns[3 + 4 * 1] = b.y;
	    eqns[3 + 4 * 2] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination

	    let n = 3;
	    const k = n;
	    let np;
	    const kp = 4; // num rows

	    let p;

	    do {
	      i = k - n;

	      if (eqns[i + nc * i] === 0) {
	        // the pivot is null, swap lines
	        for (j = i + 1; j < k; j++) {
	          if (eqns[i + nc * j] !== 0) {
	            np = kp;

	            do {
	              // do ligne( i ) = ligne( i ) + ligne( k )
	              p = kp - np;
	              eqns[p + nc * i] += eqns[p + nc * j];
	            } while (--np);

	            break;
	          }
	        }
	      }

	      if (eqns[i + nc * i] !== 0) {
	        for (j = i + 1; j < k; j++) {
	          const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
	          np = kp;

	          do {
	            // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
	            p = kp - np;
	            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
	          } while (--np);
	        }
	      }
	    } while (--n); // Get the solution


	    target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
	    target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
	    target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];

	    if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
	      throw `Could not solve equation! Got x=[${target.toString()}], b=[${b.toString()}], A=[${this.toString()}]`;
	    }

	    return target;
	  }
	  /**
	   * Get an element in the matrix by index. Index starts at 0, not 1!!!
	   * @param value If provided, the matrix element will be set to this value.
	   */


	  e(row, column, value) {
	    if (value === undefined) {
	      return this.elements[column + 3 * row];
	    } else {
	      // Set value
	      this.elements[column + 3 * row] = value;
	    }
	  }
	  /**
	   * Copy another matrix into this matrix object.
	   */


	  copy(matrix) {
	    for (let i = 0; i < matrix.elements.length; i++) {
	      this.elements[i] = matrix.elements[i];
	    }

	    return this;
	  }
	  /**
	   * Returns a string representation of the matrix.
	   */


	  toString() {
	    let r = '';
	    const sep = ',';

	    for (let i = 0; i < 9; i++) {
	      r += this.elements[i] + sep;
	    }

	    return r;
	  }
	  /**
	   * reverse the matrix
	   * @param target Target matrix to save in.
	   * @return The solution x
	   */


	  reverse(target) {
	    if (target === void 0) {
	      target = new Mat3();
	    }

	    // Construct equations
	    const nr = 3; // num rows

	    const nc = 6; // num cols

	    const eqns = reverse_eqns;
	    let i;
	    let j;

	    for (i = 0; i < 3; i++) {
	      for (j = 0; j < 3; j++) {
	        eqns[i + nc * j] = this.elements[i + 3 * j];
	      }
	    }

	    eqns[3 + 6 * 0] = 1;
	    eqns[3 + 6 * 1] = 0;
	    eqns[3 + 6 * 2] = 0;
	    eqns[4 + 6 * 0] = 0;
	    eqns[4 + 6 * 1] = 1;
	    eqns[4 + 6 * 2] = 0;
	    eqns[5 + 6 * 0] = 0;
	    eqns[5 + 6 * 1] = 0;
	    eqns[5 + 6 * 2] = 1; // Compute right upper triangular version of the matrix - Gauss elimination

	    let n = 3;
	    const k = n;
	    let np;
	    const kp = nc; // num rows

	    let p;

	    do {
	      i = k - n;

	      if (eqns[i + nc * i] === 0) {
	        // the pivot is null, swap lines
	        for (j = i + 1; j < k; j++) {
	          if (eqns[i + nc * j] !== 0) {
	            np = kp;

	            do {
	              // do line( i ) = line( i ) + line( k )
	              p = kp - np;
	              eqns[p + nc * i] += eqns[p + nc * j];
	            } while (--np);

	            break;
	          }
	        }
	      }

	      if (eqns[i + nc * i] !== 0) {
	        for (j = i + 1; j < k; j++) {
	          const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
	          np = kp;

	          do {
	            // do line( k ) = line( k ) - multiplier * line( i )
	            p = kp - np;
	            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
	          } while (--np);
	        }
	      }
	    } while (--n); // eliminate the upper left triangle of the matrix


	    i = 2;

	    do {
	      j = i - 1;

	      do {
	        const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
	        np = nc;

	        do {
	          p = nc - np;
	          eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
	        } while (--np);
	      } while (j--);
	    } while (--i); // operations on the diagonal


	    i = 2;

	    do {
	      const multiplier = 1 / eqns[i + nc * i];
	      np = nc;

	      do {
	        p = nc - np;
	        eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
	      } while (--np);
	    } while (i--);

	    i = 2;

	    do {
	      j = 2;

	      do {
	        p = eqns[nr + j + nc * i];

	        if (isNaN(p) || p === Infinity) {
	          throw `Could not reverse! A=[${this.toString()}]`;
	        }

	        target.e(i, j, p);
	      } while (j--);
	    } while (i--);

	    return target;
	  }
	  /**
	   * Set the matrix from a quaterion
	   */


	  setRotationFromQuaternion(q) {
	    const x = q.x;
	    const y = q.y;
	    const z = q.z;
	    const w = q.w;
	    const x2 = x + x;
	    const y2 = y + y;
	    const z2 = z + z;
	    const xx = x * x2;
	    const xy = x * y2;
	    const xz = x * z2;
	    const yy = y * y2;
	    const yz = y * z2;
	    const zz = z * z2;
	    const wx = w * x2;
	    const wy = w * y2;
	    const wz = w * z2;
	    const e = this.elements;
	    e[3 * 0 + 0] = 1 - (yy + zz);
	    e[3 * 0 + 1] = xy - wz;
	    e[3 * 0 + 2] = xz + wy;
	    e[3 * 1 + 0] = xy + wz;
	    e[3 * 1 + 1] = 1 - (xx + zz);
	    e[3 * 1 + 2] = yz - wx;
	    e[3 * 2 + 0] = xz - wy;
	    e[3 * 2 + 1] = yz + wx;
	    e[3 * 2 + 2] = 1 - (xx + yy);
	    return this;
	  }
	  /**
	   * Transpose the matrix
	   * @param target Optional. Where to store the result.
	   * @return The target Mat3, or a new Mat3 if target was omitted.
	   */


	  transpose(target) {
	    if (target === void 0) {
	      target = new Mat3();
	    }

	    const M = this.elements;
	    const T = target.elements;
	    let tmp; //Set diagonals

	    T[0] = M[0];
	    T[4] = M[4];
	    T[8] = M[8];
	    tmp = M[1];
	    T[1] = M[3];
	    T[3] = tmp;
	    tmp = M[2];
	    T[2] = M[6];
	    T[6] = tmp;
	    tmp = M[5];
	    T[5] = M[7];
	    T[7] = tmp;
	    return target;
	  }

	}
	const reverse_eqns = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

	/**
	 * 3-dimensional vector
	 * @example
	 *     const v = new Vec3(1, 2, 3)
	 *     console.log('x=' + v.x) // x=1
	 */

	class Vec3 {
	  constructor(x, y, z) {
	    if (x === void 0) {
	      x = 0.0;
	    }

	    if (y === void 0) {
	      y = 0.0;
	    }

	    if (z === void 0) {
	      z = 0.0;
	    }

	    this.x = x;
	    this.y = y;
	    this.z = z;
	  }
	  /**
	   * Vector cross product
	   * @param target Optional target to save in.
	   */


	  cross(vector, target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    const vx = vector.x;
	    const vy = vector.y;
	    const vz = vector.z;
	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    target.x = y * vz - z * vy;
	    target.y = z * vx - x * vz;
	    target.z = x * vy - y * vx;
	    return target;
	  }
	  /**
	   * Set the vectors' 3 elements
	   */


	  set(x, y, z) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    return this;
	  }
	  /**
	   * Set all components of the vector to zero.
	   */


	  setZero() {
	    this.x = this.y = this.z = 0;
	  }
	  /**
	   * Vector addition
	   */


	  vadd(vector, target) {
	    if (target) {
	      target.x = vector.x + this.x;
	      target.y = vector.y + this.y;
	      target.z = vector.z + this.z;
	    } else {
	      return new Vec3(this.x + vector.x, this.y + vector.y, this.z + vector.z);
	    }
	  }
	  /**
	   * Vector subtraction
	   * @param target Optional target to save in.
	   */


	  vsub(vector, target) {
	    if (target) {
	      target.x = this.x - vector.x;
	      target.y = this.y - vector.y;
	      target.z = this.z - vector.z;
	    } else {
	      return new Vec3(this.x - vector.x, this.y - vector.y, this.z - vector.z);
	    }
	  }
	  /**
	   * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
	   *
	   * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Ume University Lecture}
	   */


	  crossmat() {
	    return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
	  }
	  /**
	   * Normalize the vector. Note that this changes the values in the vector.
	    * @return Returns the norm of the vector
	   */


	  normalize() {
	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    const n = Math.sqrt(x * x + y * y + z * z);

	    if (n > 0.0) {
	      const invN = 1 / n;
	      this.x *= invN;
	      this.y *= invN;
	      this.z *= invN;
	    } else {
	      // Make something up
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	    }

	    return n;
	  }
	  /**
	   * Get the version of this vector that is of length 1.
	   * @param target Optional target to save in
	   * @return Returns the unit vector
	   */


	  unit(target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    let ninv = Math.sqrt(x * x + y * y + z * z);

	    if (ninv > 0.0) {
	      ninv = 1.0 / ninv;
	      target.x = x * ninv;
	      target.y = y * ninv;
	      target.z = z * ninv;
	    } else {
	      target.x = 1;
	      target.y = 0;
	      target.z = 0;
	    }

	    return target;
	  }
	  /**
	   * Get the length of the vector
	   */


	  length() {
	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    return Math.sqrt(x * x + y * y + z * z);
	  }
	  /**
	   * Get the squared length of the vector.
	   */


	  lengthSquared() {
	    return this.dot(this);
	  }
	  /**
	   * Get distance from this point to another point
	   */


	  distanceTo(p) {
	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    const px = p.x;
	    const py = p.y;
	    const pz = p.z;
	    return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
	  }
	  /**
	   * Get squared distance from this point to another point
	   */


	  distanceSquared(p) {
	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    const px = p.x;
	    const py = p.y;
	    const pz = p.z;
	    return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
	  }
	  /**
	   * Multiply all the components of the vector with a scalar.
	   * @param target The vector to save the result in.
	   */


	  scale(scalar, target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    target.x = scalar * x;
	    target.y = scalar * y;
	    target.z = scalar * z;
	    return target;
	  }
	  /**
	   * Multiply the vector with an other vector, component-wise.
	   * @param target The vector to save the result in.
	   */


	  vmul(vector, target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    target.x = vector.x * this.x;
	    target.y = vector.y * this.y;
	    target.z = vector.z * this.z;
	    return target;
	  }
	  /**
	   * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
	   * @param target The vector to save the result in.
	   */


	  addScaledVector(scalar, vector, target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    target.x = this.x + scalar * vector.x;
	    target.y = this.y + scalar * vector.y;
	    target.z = this.z + scalar * vector.z;
	    return target;
	  }
	  /**
	   * Calculate dot product
	   * @param vector
	   */


	  dot(vector) {
	    return this.x * vector.x + this.y * vector.y + this.z * vector.z;
	  }

	  isZero() {
	    return this.x === 0 && this.y === 0 && this.z === 0;
	  }
	  /**
	   * Make the vector point in the opposite direction.
	   * @param target Optional target to save in
	   */


	  negate(target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    target.x = -this.x;
	    target.y = -this.y;
	    target.z = -this.z;
	    return target;
	  }
	  /**
	   * Compute two artificial tangents to the vector
	   * @param t1 Vector object to save the first tangent in
	   * @param t2 Vector object to save the second tangent in
	   */


	  tangents(t1, t2) {
	    const norm = this.length();

	    if (norm > 0.0) {
	      const n = Vec3_tangents_n;
	      const inorm = 1 / norm;
	      n.set(this.x * inorm, this.y * inorm, this.z * inorm);
	      const randVec = Vec3_tangents_randVec;

	      if (Math.abs(n.x) < 0.9) {
	        randVec.set(1, 0, 0);
	        n.cross(randVec, t1);
	      } else {
	        randVec.set(0, 1, 0);
	        n.cross(randVec, t1);
	      }

	      n.cross(t1, t2);
	    } else {
	      // The normal length is zero, make something up
	      t1.set(1, 0, 0);
	      t2.set(0, 1, 0);
	    }
	  }
	  /**
	   * Converts to a more readable format
	   */


	  toString() {
	    return `${this.x},${this.y},${this.z}`;
	  }
	  /**
	   * Converts to an array
	   */


	  toArray() {
	    return [this.x, this.y, this.z];
	  }
	  /**
	   * Copies value of source to this vector.
	   */


	  copy(vector) {
	    this.x = vector.x;
	    this.y = vector.y;
	    this.z = vector.z;
	    return this;
	  }
	  /**
	   * Do a linear interpolation between two vectors
	   * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
	   */


	  lerp(vector, t, target) {
	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    target.x = x + (vector.x - x) * t;
	    target.y = y + (vector.y - y) * t;
	    target.z = z + (vector.z - z) * t;
	  }
	  /**
	   * Check if a vector equals is almost equal to another one.
	   */


	  almostEquals(vector, precision) {
	    if (precision === void 0) {
	      precision = 1e-6;
	    }

	    if (Math.abs(this.x - vector.x) > precision || Math.abs(this.y - vector.y) > precision || Math.abs(this.z - vector.z) > precision) {
	      return false;
	    }

	    return true;
	  }
	  /**
	   * Check if a vector is almost zero
	   */


	  almostZero(precision) {
	    if (precision === void 0) {
	      precision = 1e-6;
	    }

	    if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) {
	      return false;
	    }

	    return true;
	  }
	  /**
	   * Check if the vector is anti-parallel to another vector.
	   * @param precision Set to zero for exact comparisons
	   */


	  isAntiparallelTo(vector, precision) {
	    this.negate(antip_neg);
	    return antip_neg.almostEquals(vector, precision);
	  }
	  /**
	   * Clone the vector
	   */


	  clone() {
	    return new Vec3(this.x, this.y, this.z);
	  }

	}
	Vec3.ZERO = new Vec3(0, 0, 0);
	Vec3.UNIT_X = new Vec3(1, 0, 0);
	Vec3.UNIT_Y = new Vec3(0, 1, 0);
	Vec3.UNIT_Z = new Vec3(0, 0, 1);
	const Vec3_tangents_n = new Vec3();
	const Vec3_tangents_randVec = new Vec3();
	const antip_neg = new Vec3();

	/**
	 * Axis aligned bounding box class.
	 */
	class AABB {
	  /**
	   * The lower bound of the bounding box
	   */

	  /**
	   * The upper bound of the bounding box
	   */
	  constructor(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    this.lowerBound = new Vec3();
	    this.upperBound = new Vec3();

	    if (options.lowerBound) {
	      this.lowerBound.copy(options.lowerBound);
	    }

	    if (options.upperBound) {
	      this.upperBound.copy(options.upperBound);
	    }
	  }
	  /**
	   * Set the AABB bounds from a set of points.
	   * @param points An array of Vec3's.
	   * @return The self object
	   */


	  setFromPoints(points, position, quaternion, skinSize) {
	    const l = this.lowerBound;
	    const u = this.upperBound;
	    const q = quaternion; // Set to the first point

	    l.copy(points[0]);

	    if (q) {
	      q.vmult(l, l);
	    }

	    u.copy(l);

	    for (let i = 1; i < points.length; i++) {
	      let p = points[i];

	      if (q) {
	        q.vmult(p, tmp$1);
	        p = tmp$1;
	      }

	      if (p.x > u.x) {
	        u.x = p.x;
	      }

	      if (p.x < l.x) {
	        l.x = p.x;
	      }

	      if (p.y > u.y) {
	        u.y = p.y;
	      }

	      if (p.y < l.y) {
	        l.y = p.y;
	      }

	      if (p.z > u.z) {
	        u.z = p.z;
	      }

	      if (p.z < l.z) {
	        l.z = p.z;
	      }
	    } // Add offset


	    if (position) {
	      position.vadd(l, l);
	      position.vadd(u, u);
	    }

	    if (skinSize) {
	      l.x -= skinSize;
	      l.y -= skinSize;
	      l.z -= skinSize;
	      u.x += skinSize;
	      u.y += skinSize;
	      u.z += skinSize;
	    }

	    return this;
	  }
	  /**
	   * Copy bounds from an AABB to this AABB
	   * @param aabb Source to copy from
	   * @return The this object, for chainability
	   */


	  copy(aabb) {
	    this.lowerBound.copy(aabb.lowerBound);
	    this.upperBound.copy(aabb.upperBound);
	    return this;
	  }
	  /**
	   * Clone an AABB
	   */


	  clone() {
	    return new AABB().copy(this);
	  }
	  /**
	   * Extend this AABB so that it covers the given AABB too.
	   */


	  extend(aabb) {
	    this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
	    this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
	    this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
	    this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
	    this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
	    this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
	  }
	  /**
	   * Returns true if the given AABB overlaps this AABB.
	   */


	  overlaps(aabb) {
	    const l1 = this.lowerBound;
	    const u1 = this.upperBound;
	    const l2 = aabb.lowerBound;
	    const u2 = aabb.upperBound; //      l2        u2
	    //      |---------|
	    // |--------|
	    // l1       u1

	    const overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;
	    const overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;
	    const overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;
	    return overlapsX && overlapsY && overlapsZ;
	  } // Mostly for debugging


	  volume() {
	    const l = this.lowerBound;
	    const u = this.upperBound;
	    return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
	  }
	  /**
	   * Returns true if the given AABB is fully contained in this AABB.
	   */


	  contains(aabb) {
	    const l1 = this.lowerBound;
	    const u1 = this.upperBound;
	    const l2 = aabb.lowerBound;
	    const u2 = aabb.upperBound; //      l2        u2
	    //      |---------|
	    // |---------------|
	    // l1              u1

	    return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
	  }

	  getCorners(a, b, c, d, e, f, g, h) {
	    const l = this.lowerBound;
	    const u = this.upperBound;
	    a.copy(l);
	    b.set(u.x, l.y, l.z);
	    c.set(u.x, u.y, l.z);
	    d.set(l.x, u.y, u.z);
	    e.set(u.x, l.y, u.z);
	    f.set(l.x, u.y, l.z);
	    g.set(l.x, l.y, u.z);
	    h.copy(u);
	  }
	  /**
	   * Get the representation of an AABB in another frame.
	   * @return The "target" AABB object.
	   */


	  toLocalFrame(frame, target) {
	    const corners = transformIntoFrame_corners;
	    const a = corners[0];
	    const b = corners[1];
	    const c = corners[2];
	    const d = corners[3];
	    const e = corners[4];
	    const f = corners[5];
	    const g = corners[6];
	    const h = corners[7]; // Get corners in current frame

	    this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

	    for (let i = 0; i !== 8; i++) {
	      const corner = corners[i];
	      frame.pointToLocal(corner, corner);
	    }

	    return target.setFromPoints(corners);
	  }
	  /**
	   * Get the representation of an AABB in the global frame.
	   * @return The "target" AABB object.
	   */


	  toWorldFrame(frame, target) {
	    const corners = transformIntoFrame_corners;
	    const a = corners[0];
	    const b = corners[1];
	    const c = corners[2];
	    const d = corners[3];
	    const e = corners[4];
	    const f = corners[5];
	    const g = corners[6];
	    const h = corners[7]; // Get corners in current frame

	    this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

	    for (let i = 0; i !== 8; i++) {
	      const corner = corners[i];
	      frame.pointToWorld(corner, corner);
	    }

	    return target.setFromPoints(corners);
	  }
	  /**
	   * Check if the AABB is hit by a ray.
	   */


	  overlapsRay(ray) {
	    const {
	      direction,
	      from
	    } = ray; // const t = 0
	    // ray.direction is unit direction vector of ray

	    const dirFracX = 1 / direction.x;
	    const dirFracY = 1 / direction.y;
	    const dirFracZ = 1 / direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner

	    const t1 = (this.lowerBound.x - from.x) * dirFracX;
	    const t2 = (this.upperBound.x - from.x) * dirFracX;
	    const t3 = (this.lowerBound.y - from.y) * dirFracY;
	    const t4 = (this.upperBound.y - from.y) * dirFracY;
	    const t5 = (this.lowerBound.z - from.z) * dirFracZ;
	    const t6 = (this.upperBound.z - from.z) * dirFracZ; // const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
	    // const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));

	    const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
	    const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us

	    if (tmax < 0) {
	      //t = tmax;
	      return false;
	    } // if tmin > tmax, ray doesn't intersect AABB


	    if (tmin > tmax) {
	      //t = tmax;
	      return false;
	    }

	    return true;
	  }

	}
	const tmp$1 = new Vec3();
	const transformIntoFrame_corners = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

	/**
	 * Collision "matrix".
	 * It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
	 */
	class ArrayCollisionMatrix {
	  /**
	   * The matrix storage.
	   */
	  constructor() {
	    this.matrix = [];
	  }
	  /**
	   * Get an element
	   */


	  get(bi, bj) {
	    let {
	      index: i
	    } = bi;
	    let {
	      index: j
	    } = bj;

	    if (j > i) {
	      const temp = j;
	      j = i;
	      i = temp;
	    }

	    return this.matrix[(i * (i + 1) >> 1) + j - 1];
	  }
	  /**
	   * Set an element
	   */


	  set(bi, bj, value) {
	    let {
	      index: i
	    } = bi;
	    let {
	      index: j
	    } = bj;

	    if (j > i) {
	      const temp = j;
	      j = i;
	      i = temp;
	    }

	    this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
	  }
	  /**
	   * Sets all elements to zero
	   */


	  reset() {
	    for (let i = 0, l = this.matrix.length; i !== l; i++) {
	      this.matrix[i] = 0;
	    }
	  }
	  /**
	   * Sets the max number of objects
	   */


	  setNumObjects(n) {
	    this.matrix.length = n * (n - 1) >> 1;
	  }

	}

	/**
	 * Base class for objects that dispatches events.
	 */
	class EventTarget {
	  /**
	   * Add an event listener
	   * @return The self object, for chainability.
	   */
	  addEventListener(type, listener) {
	    if (this._listeners === undefined) {
	      this._listeners = {};
	    }

	    const listeners = this._listeners;

	    if (listeners[type] === undefined) {
	      listeners[type] = [];
	    }

	    if (!listeners[type].includes(listener)) {
	      listeners[type].push(listener);
	    }

	    return this;
	  }
	  /**
	   * Check if an event listener is added
	   */


	  hasEventListener(type, listener) {
	    if (this._listeners === undefined) {
	      return false;
	    }

	    const listeners = this._listeners;

	    if (listeners[type] !== undefined && listeners[type].includes(listener)) {
	      return true;
	    }

	    return false;
	  }
	  /**
	   * Check if any event listener of the given type is added
	   */


	  hasAnyEventListener(type) {
	    if (this._listeners === undefined) {
	      return false;
	    }

	    const listeners = this._listeners;
	    return listeners[type] !== undefined;
	  }
	  /**
	   * Remove an event listener
	   * @return The self object, for chainability.
	   */


	  removeEventListener(type, listener) {
	    if (this._listeners === undefined) {
	      return this;
	    }

	    const listeners = this._listeners;

	    if (listeners[type] === undefined) {
	      return this;
	    }

	    const index = listeners[type].indexOf(listener);

	    if (index !== -1) {
	      listeners[type].splice(index, 1);
	    }

	    return this;
	  }
	  /**
	   * Emit an event.
	   * @return The self object, for chainability.
	   */


	  dispatchEvent(event) {
	    if (this._listeners === undefined) {
	      return this;
	    }

	    const listeners = this._listeners;
	    const listenerArray = listeners[event.type];

	    if (listenerArray !== undefined) {
	      event.target = this;

	      for (let i = 0, l = listenerArray.length; i < l; i++) {
	        listenerArray[i].call(this, event);
	      }
	    }

	    return this;
	  }

	}

	/**
	 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
	 * @param x Multiplier of the imaginary basis vector i.
	 * @param y Multiplier of the imaginary basis vector j.
	 * @param z Multiplier of the imaginary basis vector k.
	 * @param w Multiplier of the real part.
	 * @see http://en.wikipedia.org/wiki/Quaternion
	 */

	class Quaternion {
	  constructor(x, y, z, w) {
	    if (x === void 0) {
	      x = 0;
	    }

	    if (y === void 0) {
	      y = 0;
	    }

	    if (z === void 0) {
	      z = 0;
	    }

	    if (w === void 0) {
	      w = 1;
	    }

	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;
	  }
	  /**
	   * Set the value of the quaternion.
	   */


	  set(x, y, z, w) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;
	    return this;
	  }
	  /**
	   * Convert to a readable format
	   * @return "x,y,z,w"
	   */


	  toString() {
	    return `${this.x},${this.y},${this.z},${this.w}`;
	  }
	  /**
	   * Convert to an Array
	   * @return [x, y, z, w]
	   */


	  toArray() {
	    return [this.x, this.y, this.z, this.w];
	  }
	  /**
	   * Set the quaternion components given an axis and an angle in radians.
	   */


	  setFromAxisAngle(vector, angle) {
	    const s = Math.sin(angle * 0.5);
	    this.x = vector.x * s;
	    this.y = vector.y * s;
	    this.z = vector.z * s;
	    this.w = Math.cos(angle * 0.5);
	    return this;
	  }
	  /**
	   * Converts the quaternion to [ axis, angle ] representation.
	   * @param targetAxis A vector object to reuse for storing the axis.
	   * @return An array, first element is the axis and the second is the angle in radians.
	   */


	  toAxisAngle(targetAxis) {
	    if (targetAxis === void 0) {
	      targetAxis = new Vec3();
	    }

	    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised

	    const angle = 2 * Math.acos(this.w);
	    const s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.

	    if (s < 0.001) {
	      // test to avoid divide by zero, s is always positive due to sqrt
	      // if s close to zero then direction of axis not important
	      targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;

	      targetAxis.y = this.y;
	      targetAxis.z = this.z;
	    } else {
	      targetAxis.x = this.x / s; // normalise axis

	      targetAxis.y = this.y / s;
	      targetAxis.z = this.z / s;
	    }

	    return [targetAxis, angle];
	  }
	  /**
	   * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
	   */


	  setFromVectors(u, v) {
	    if (u.isAntiparallelTo(v)) {
	      const t1 = sfv_t1;
	      const t2 = sfv_t2;
	      u.tangents(t1, t2);
	      this.setFromAxisAngle(t1, Math.PI);
	    } else {
	      const a = u.cross(v);
	      this.x = a.x;
	      this.y = a.y;
	      this.z = a.z;
	      this.w = Math.sqrt(u.length() ** 2 * v.length() ** 2) + u.dot(v);
	      this.normalize();
	    }

	    return this;
	  }
	  /**
	   * Multiply the quaternion with an other quaternion.
	   */


	  mult(quat, target) {
	    if (target === void 0) {
	      target = new Quaternion();
	    }

	    const ax = this.x;
	    const ay = this.y;
	    const az = this.z;
	    const aw = this.w;
	    const bx = quat.x;
	    const by = quat.y;
	    const bz = quat.z;
	    const bw = quat.w;
	    target.x = ax * bw + aw * bx + ay * bz - az * by;
	    target.y = ay * bw + aw * by + az * bx - ax * bz;
	    target.z = az * bw + aw * bz + ax * by - ay * bx;
	    target.w = aw * bw - ax * bx - ay * by - az * bz;
	    return target;
	  }
	  /**
	   * Get the inverse quaternion rotation.
	   */


	  inverse(target) {
	    if (target === void 0) {
	      target = new Quaternion();
	    }

	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    const w = this.w;
	    this.conjugate(target);
	    const inorm2 = 1 / (x * x + y * y + z * z + w * w);
	    target.x *= inorm2;
	    target.y *= inorm2;
	    target.z *= inorm2;
	    target.w *= inorm2;
	    return target;
	  }
	  /**
	   * Get the quaternion conjugate
	   */


	  conjugate(target) {
	    if (target === void 0) {
	      target = new Quaternion();
	    }

	    target.x = -this.x;
	    target.y = -this.y;
	    target.z = -this.z;
	    target.w = this.w;
	    return target;
	  }
	  /**
	   * Normalize the quaternion. Note that this changes the values of the quaternion.
	   */


	  normalize() {
	    let l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

	    if (l === 0) {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	      this.w = 0;
	    } else {
	      l = 1 / l;
	      this.x *= l;
	      this.y *= l;
	      this.z *= l;
	      this.w *= l;
	    }

	    return this;
	  }
	  /**
	   * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
	   * @author unphased, https://github.com/unphased
	   */


	  normalizeFast() {
	    const f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;

	    if (f === 0) {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	      this.w = 0;
	    } else {
	      this.x *= f;
	      this.y *= f;
	      this.z *= f;
	      this.w *= f;
	    }

	    return this;
	  }
	  /**
	   * Multiply the quaternion by a vector
	   */


	  vmult(v, target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    const x = v.x;
	    const y = v.y;
	    const z = v.z;
	    const qx = this.x;
	    const qy = this.y;
	    const qz = this.z;
	    const qw = this.w; // q*v

	    const ix = qw * x + qy * z - qz * y;
	    const iy = qw * y + qz * x - qx * z;
	    const iz = qw * z + qx * y - qy * x;
	    const iw = -qx * x - qy * y - qz * z;
	    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    return target;
	  }
	  /**
	   * Copies value of source to this quaternion.
	   * @return this
	   */


	  copy(quat) {
	    this.x = quat.x;
	    this.y = quat.y;
	    this.z = quat.z;
	    this.w = quat.w;
	    return this;
	  }
	  /**
	   * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
	   * @param order Three-character string, defaults to "YZX"
	   */


	  toEuler(target, order) {
	    if (order === void 0) {
	      order = 'YZX';
	    }

	    let heading;
	    let attitude;
	    let bank;
	    const x = this.x;
	    const y = this.y;
	    const z = this.z;
	    const w = this.w;

	    switch (order) {
	      case 'YZX':
	        const test = x * y + z * w;

	        if (test > 0.499) {
	          // singularity at north pole
	          heading = 2 * Math.atan2(x, w);
	          attitude = Math.PI / 2;
	          bank = 0;
	        }

	        if (test < -0.499) {
	          // singularity at south pole
	          heading = -2 * Math.atan2(x, w);
	          attitude = -Math.PI / 2;
	          bank = 0;
	        }

	        if (heading === undefined) {
	          const sqx = x * x;
	          const sqy = y * y;
	          const sqz = z * z;
	          heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading

	          attitude = Math.asin(2 * test); // attitude

	          bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank
	        }

	        break;

	      default:
	        throw new Error(`Euler order ${order} not supported yet.`);
	    }

	    target.y = heading;
	    target.z = attitude;
	    target.x = bank;
	  }
	  /**
	   * Set the quaternion components given Euler angle representation.
	   *
	   * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
	   *
	   * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
	   */


	  setFromEuler(x, y, z, order) {
	    if (order === void 0) {
	      order = 'XYZ';
	    }

	    const c1 = Math.cos(x / 2);
	    const c2 = Math.cos(y / 2);
	    const c3 = Math.cos(z / 2);
	    const s1 = Math.sin(x / 2);
	    const s2 = Math.sin(y / 2);
	    const s3 = Math.sin(z / 2);

	    if (order === 'XYZ') {
	      this.x = s1 * c2 * c3 + c1 * s2 * s3;
	      this.y = c1 * s2 * c3 - s1 * c2 * s3;
	      this.z = c1 * c2 * s3 + s1 * s2 * c3;
	      this.w = c1 * c2 * c3 - s1 * s2 * s3;
	    } else if (order === 'YXZ') {
	      this.x = s1 * c2 * c3 + c1 * s2 * s3;
	      this.y = c1 * s2 * c3 - s1 * c2 * s3;
	      this.z = c1 * c2 * s3 - s1 * s2 * c3;
	      this.w = c1 * c2 * c3 + s1 * s2 * s3;
	    } else if (order === 'ZXY') {
	      this.x = s1 * c2 * c3 - c1 * s2 * s3;
	      this.y = c1 * s2 * c3 + s1 * c2 * s3;
	      this.z = c1 * c2 * s3 + s1 * s2 * c3;
	      this.w = c1 * c2 * c3 - s1 * s2 * s3;
	    } else if (order === 'ZYX') {
	      this.x = s1 * c2 * c3 - c1 * s2 * s3;
	      this.y = c1 * s2 * c3 + s1 * c2 * s3;
	      this.z = c1 * c2 * s3 - s1 * s2 * c3;
	      this.w = c1 * c2 * c3 + s1 * s2 * s3;
	    } else if (order === 'YZX') {
	      this.x = s1 * c2 * c3 + c1 * s2 * s3;
	      this.y = c1 * s2 * c3 + s1 * c2 * s3;
	      this.z = c1 * c2 * s3 - s1 * s2 * c3;
	      this.w = c1 * c2 * c3 - s1 * s2 * s3;
	    } else if (order === 'XZY') {
	      this.x = s1 * c2 * c3 - c1 * s2 * s3;
	      this.y = c1 * s2 * c3 - s1 * c2 * s3;
	      this.z = c1 * c2 * s3 + s1 * s2 * c3;
	      this.w = c1 * c2 * c3 + s1 * s2 * s3;
	    }

	    return this;
	  }

	  clone() {
	    return new Quaternion(this.x, this.y, this.z, this.w);
	  }
	  /**
	   * Performs a spherical linear interpolation between two quat
	   *
	   * @param toQuat second operand
	   * @param t interpolation amount between the self quaternion and toQuat
	   * @param target A quaternion to store the result in. If not provided, a new one will be created.
	   * @returns {Quaternion} The "target" object
	   */


	  slerp(toQuat, t, target) {
	    if (target === void 0) {
	      target = new Quaternion();
	    }

	    const ax = this.x;
	    const ay = this.y;
	    const az = this.z;
	    const aw = this.w;
	    let bx = toQuat.x;
	    let by = toQuat.y;
	    let bz = toQuat.z;
	    let bw = toQuat.w;
	    let omega;
	    let cosom;
	    let sinom;
	    let scale0;
	    let scale1; // calc cosine

	    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

	    if (cosom < 0.0) {
	      cosom = -cosom;
	      bx = -bx;
	      by = -by;
	      bz = -bz;
	      bw = -bw;
	    } // calculate coefficients


	    if (1.0 - cosom > 0.000001) {
	      // standard case (slerp)
	      omega = Math.acos(cosom);
	      sinom = Math.sin(omega);
	      scale0 = Math.sin((1.0 - t) * omega) / sinom;
	      scale1 = Math.sin(t * omega) / sinom;
	    } else {
	      // "from" and "to" quaternions are very close
	      //  ... so we can do a linear interpolation
	      scale0 = 1.0 - t;
	      scale1 = t;
	    } // calculate final values


	    target.x = scale0 * ax + scale1 * bx;
	    target.y = scale0 * ay + scale1 * by;
	    target.z = scale0 * az + scale1 * bz;
	    target.w = scale0 * aw + scale1 * bw;
	    return target;
	  }
	  /**
	   * Rotate an absolute orientation quaternion given an angular velocity and a time step.
	   */


	  integrate(angularVelocity, dt, angularFactor, target) {
	    if (target === void 0) {
	      target = new Quaternion();
	    }

	    const ax = angularVelocity.x * angularFactor.x,
	          ay = angularVelocity.y * angularFactor.y,
	          az = angularVelocity.z * angularFactor.z,
	          bx = this.x,
	          by = this.y,
	          bz = this.z,
	          bw = this.w;
	    const half_dt = dt * 0.5;
	    target.x += half_dt * (ax * bw + ay * bz - az * by);
	    target.y += half_dt * (ay * bw + az * bx - ax * bz);
	    target.z += half_dt * (az * bw + ax * by - ay * bx);
	    target.w += half_dt * (-ax * bx - ay * by - az * bz);
	    return target;
	  }

	}
	const sfv_t1 = new Vec3();
	const sfv_t2 = new Vec3();

	/**
	 * The available shape types.
	 */
	const SHAPE_TYPES = {
	  /** SPHERE */
	  SPHERE: 1,

	  /** PLANE */
	  PLANE: 2,

	  /** BOX */
	  BOX: 4,

	  /** COMPOUND */
	  COMPOUND: 8,

	  /** CONVEXPOLYHEDRON */
	  CONVEXPOLYHEDRON: 16,

	  /** HEIGHTFIELD */
	  HEIGHTFIELD: 32,

	  /** PARTICLE */
	  PARTICLE: 64,

	  /** CYLINDER */
	  CYLINDER: 128,

	  /** TRIMESH */
	  TRIMESH: 256
	};
	/**
	 * ShapeType
	 */

	/**
	 * Base class for shapes
	 */
	class Shape {
	  /**
	   * Identifier of the Shape.
	   */

	  /**
	   * The type of this shape. Must be set to an int > 0 by subclasses.
	   */

	  /**
	   * The local bounding sphere radius of this shape.
	   */

	  /**
	   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
	   * @default true
	   */

	  /**
	   * @default 1
	   */

	  /**
	   * @default -1
	   */

	  /**
	   * Optional material of the shape that regulates contact properties.
	   */

	  /**
	   * The body to which the shape is added to.
	   */

	  /**
	   * All the Shape types.
	   */
	  constructor(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    this.id = Shape.idCounter++;
	    this.type = options.type || 0;
	    this.boundingSphereRadius = 0;
	    this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;
	    this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;
	    this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;
	    this.material = options.material ? options.material : null;
	    this.body = null;
	  }
	  /**
	   * Computes the bounding sphere radius.
	   * The result is stored in the property `.boundingSphereRadius`
	   */


	  updateBoundingSphereRadius() {
	    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
	  }
	  /**
	   * Get the volume of this shape
	   */


	  volume() {
	    throw `volume() not implemented for shape type ${this.type}`;
	  }
	  /**
	   * Calculates the inertia in the local frame for this shape.
	   * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
	   */


	  calculateLocalInertia(mass, target) {
	    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
	  }
	  /**
	   * @todo use abstract for these kind of methods
	   */


	  calculateWorldAABB(pos, quat, min, max) {
	    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
	  }

	}
	Shape.idCounter = 0;
	Shape.types = SHAPE_TYPES;

	/**
	 * Transformation utilities.
	 */
	class Transform {
	  /**
	   * position
	   */

	  /**
	   * quaternion
	   */
	  constructor(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    this.position = new Vec3();
	    this.quaternion = new Quaternion();

	    if (options.position) {
	      this.position.copy(options.position);
	    }

	    if (options.quaternion) {
	      this.quaternion.copy(options.quaternion);
	    }
	  }
	  /**
	   * Get a global point in local transform coordinates.
	   */


	  pointToLocal(worldPoint, result) {
	    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
	  }
	  /**
	   * Get a local point in global transform coordinates.
	   */


	  pointToWorld(localPoint, result) {
	    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
	  }
	  /**
	   * vectorToWorldFrame
	   */


	  vectorToWorldFrame(localVector, result) {
	    if (result === void 0) {
	      result = new Vec3();
	    }

	    this.quaternion.vmult(localVector, result);
	    return result;
	  }
	  /**
	   * pointToLocalFrame
	   */


	  static pointToLocalFrame(position, quaternion, worldPoint, result) {
	    if (result === void 0) {
	      result = new Vec3();
	    }

	    worldPoint.vsub(position, result);
	    quaternion.conjugate(tmpQuat$1);
	    tmpQuat$1.vmult(result, result);
	    return result;
	  }
	  /**
	   * pointToWorldFrame
	   */


	  static pointToWorldFrame(position, quaternion, localPoint, result) {
	    if (result === void 0) {
	      result = new Vec3();
	    }

	    quaternion.vmult(localPoint, result);
	    result.vadd(position, result);
	    return result;
	  }
	  /**
	   * vectorToWorldFrame
	   */


	  static vectorToWorldFrame(quaternion, localVector, result) {
	    if (result === void 0) {
	      result = new Vec3();
	    }

	    quaternion.vmult(localVector, result);
	    return result;
	  }
	  /**
	   * vectorToLocalFrame
	   */


	  static vectorToLocalFrame(position, quaternion, worldVector, result) {
	    if (result === void 0) {
	      result = new Vec3();
	    }

	    quaternion.w *= -1;
	    quaternion.vmult(worldVector, result);
	    quaternion.w *= -1;
	    return result;
	  }

	}
	const tmpQuat$1 = new Quaternion();

	/**
	 * A set of polygons describing a convex shape.
	 *
	 * The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
	 * in the same 3D plane), instead these should be merged into one polygon.
	 *
	 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
	 * @author schteppe / https://github.com/schteppe
	 * @see https://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
	 *
	 * @todo Move the clipping functions to ContactGenerator?
	 * @todo Automatically merge coplanar polygons in constructor.
	 * @example
	 *     const convexShape = new CANNON.ConvexPolyhedron({ vertices, faces })
	 *     const convexBody = new CANNON.Body({ mass: 1, shape: convexShape })
	 *     world.addBody(convexBody)
	 */
	class ConvexPolyhedron extends Shape {
	  /** vertices */

	  /**
	   * Array of integer arrays, indicating which vertices each face consists of
	   */

	  /** faceNormals */

	  /** worldVertices */

	  /** worldVerticesNeedsUpdate */

	  /** worldFaceNormals */

	  /** worldFaceNormalsNeedsUpdate */

	  /**
	   * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
	   */

	  /** uniqueEdges */

	  /**
	   * @param vertices An array of Vec3's
	   * @param faces Array of integer arrays, describing which vertices that is included in each face.
	   */
	  constructor(props) {
	    if (props === void 0) {
	      props = {};
	    }

	    const {
	      vertices = [],
	      faces = [],
	      normals = [],
	      axes,
	      boundingSphereRadius
	    } = props;
	    super({
	      type: Shape.types.CONVEXPOLYHEDRON
	    });
	    this.vertices = vertices;
	    this.faces = faces;
	    this.faceNormals = normals;

	    if (this.faceNormals.length === 0) {
	      this.computeNormals();
	    }

	    if (!boundingSphereRadius) {
	      this.updateBoundingSphereRadius();
	    } else {
	      this.boundingSphereRadius = boundingSphereRadius;
	    }

	    this.worldVertices = []; // World transformed version of .vertices

	    this.worldVerticesNeedsUpdate = true;
	    this.worldFaceNormals = []; // World transformed version of .faceNormals

	    this.worldFaceNormalsNeedsUpdate = true;
	    this.uniqueAxes = axes ? axes.slice() : null;
	    this.uniqueEdges = [];
	    this.computeEdges();
	  }
	  /**
	   * Computes uniqueEdges
	   */


	  computeEdges() {
	    const faces = this.faces;
	    const vertices = this.vertices;
	    const edges = this.uniqueEdges;
	    edges.length = 0;
	    const edge = new Vec3();

	    for (let i = 0; i !== faces.length; i++) {
	      const face = faces[i];
	      const numVertices = face.length;

	      for (let j = 0; j !== numVertices; j++) {
	        const k = (j + 1) % numVertices;
	        vertices[face[j]].vsub(vertices[face[k]], edge);
	        edge.normalize();
	        let found = false;

	        for (let p = 0; p !== edges.length; p++) {
	          if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
	            found = true;
	            break;
	          }
	        }

	        if (!found) {
	          edges.push(edge.clone());
	        }
	      }
	    }
	  }
	  /**
	   * Compute the normals of the faces.
	   * Will reuse existing Vec3 objects in the `faceNormals` array if they exist.
	   */


	  computeNormals() {
	    this.faceNormals.length = this.faces.length; // Generate normals

	    for (let i = 0; i < this.faces.length; i++) {
	      // Check so all vertices exists for this face
	      for (let j = 0; j < this.faces[i].length; j++) {
	        if (!this.vertices[this.faces[i][j]]) {
	          throw new Error(`Vertex ${this.faces[i][j]} not found!`);
	        }
	      }

	      const n = this.faceNormals[i] || new Vec3();
	      this.getFaceNormal(i, n);
	      n.negate(n);
	      this.faceNormals[i] = n;
	      const vertex = this.vertices[this.faces[i][0]];

	      if (n.dot(vertex) < 0) {
	        console.error(`.faceNormals[${i}] = Vec3(${n.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);

	        for (let j = 0; j < this.faces[i].length; j++) {
	          console.warn(`.vertices[${this.faces[i][j]}] = Vec3(${this.vertices[this.faces[i][j]].toString()})`);
	        }
	      }
	    }
	  }
	  /**
	   * Compute the normal of a face from its vertices
	   */


	  getFaceNormal(i, target) {
	    const f = this.faces[i];
	    const va = this.vertices[f[0]];
	    const vb = this.vertices[f[1]];
	    const vc = this.vertices[f[2]];
	    ConvexPolyhedron.computeNormal(va, vb, vc, target);
	  }
	  /**
	   * Get face normal given 3 vertices
	   */


	  static computeNormal(va, vb, vc, target) {
	    const cb = new Vec3();
	    const ab = new Vec3();
	    vb.vsub(va, ab);
	    vc.vsub(vb, cb);
	    cb.cross(ab, target);

	    if (!target.isZero()) {
	      target.normalize();
	    }
	  }
	  /**
	   * @param minDist Clamp distance
	   * @param result The an array of contact point objects, see clipFaceAgainstHull
	   */


	  clipAgainstHull(posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
	    const WorldNormal = new Vec3();
	    let closestFaceB = -1;
	    let dmax = -Number.MAX_VALUE;

	    for (let face = 0; face < hullB.faces.length; face++) {
	      WorldNormal.copy(hullB.faceNormals[face]);
	      quatB.vmult(WorldNormal, WorldNormal);
	      const d = WorldNormal.dot(separatingNormal);

	      if (d > dmax) {
	        dmax = d;
	        closestFaceB = face;
	      }
	    }

	    const worldVertsB1 = [];

	    for (let i = 0; i < hullB.faces[closestFaceB].length; i++) {
	      const b = hullB.vertices[hullB.faces[closestFaceB][i]];
	      const worldb = new Vec3();
	      worldb.copy(b);
	      quatB.vmult(worldb, worldb);
	      posB.vadd(worldb, worldb);
	      worldVertsB1.push(worldb);
	    }

	    if (closestFaceB >= 0) {
	      this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
	    }
	  }
	  /**
	   * Find the separating axis between this hull and another
	   * @param target The target vector to save the axis in
	   * @return Returns false if a separation is found, else true
	   */


	  findSeparatingAxis(hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
	    const faceANormalWS3 = new Vec3();
	    const Worldnormal1 = new Vec3();
	    const deltaC = new Vec3();
	    const worldEdge0 = new Vec3();
	    const worldEdge1 = new Vec3();
	    const Cross = new Vec3();
	    let dmin = Number.MAX_VALUE;
	    const hullA = this;

	    if (!hullA.uniqueAxes) {
	      const numFacesA = faceListA ? faceListA.length : hullA.faces.length; // Test face normals from hullA

	      for (let i = 0; i < numFacesA; i++) {
	        const fi = faceListA ? faceListA[i] : i; // Get world face normal

	        faceANormalWS3.copy(hullA.faceNormals[fi]);
	        quatA.vmult(faceANormalWS3, faceANormalWS3);
	        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

	        if (d === false) {
	          return false;
	        }

	        if (d < dmin) {
	          dmin = d;
	          target.copy(faceANormalWS3);
	        }
	      }
	    } else {
	      // Test unique axes
	      for (let i = 0; i !== hullA.uniqueAxes.length; i++) {
	        // Get world axis
	        quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);
	        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

	        if (d === false) {
	          return false;
	        }

	        if (d < dmin) {
	          dmin = d;
	          target.copy(faceANormalWS3);
	        }
	      }
	    }

	    if (!hullB.uniqueAxes) {
	      // Test face normals from hullB
	      const numFacesB = faceListB ? faceListB.length : hullB.faces.length;

	      for (let i = 0; i < numFacesB; i++) {
	        const fi = faceListB ? faceListB[i] : i;
	        Worldnormal1.copy(hullB.faceNormals[fi]);
	        quatB.vmult(Worldnormal1, Worldnormal1);
	        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

	        if (d === false) {
	          return false;
	        }

	        if (d < dmin) {
	          dmin = d;
	          target.copy(Worldnormal1);
	        }
	      }
	    } else {
	      // Test unique axes in B
	      for (let i = 0; i !== hullB.uniqueAxes.length; i++) {
	        quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
	        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

	        if (d === false) {
	          return false;
	        }

	        if (d < dmin) {
	          dmin = d;
	          target.copy(Worldnormal1);
	        }
	      }
	    } // Test edges


	    for (let e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
	      // Get world edge
	      quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);

	      for (let e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
	        // Get world edge 2
	        quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
	        worldEdge0.cross(worldEdge1, Cross);

	        if (!Cross.almostZero()) {
	          Cross.normalize();
	          const dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);

	          if (dist === false) {
	            return false;
	          }

	          if (dist < dmin) {
	            dmin = dist;
	            target.copy(Cross);
	          }
	        }
	      }
	    }

	    posB.vsub(posA, deltaC);

	    if (deltaC.dot(target) > 0.0) {
	      target.negate(target);
	    }

	    return true;
	  }
	  /**
	   * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
	   * @return The overlap depth, or FALSE if no penetration.
	   */


	  testSepAxis(axis, hullB, posA, quatA, posB, quatB) {
	    const hullA = this;
	    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
	    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
	    const maxA = maxminA[0];
	    const minA = maxminA[1];
	    const maxB = maxminB[0];
	    const minB = maxminB[1];

	    if (maxA < minB || maxB < minA) {
	      return false; // Separated
	    }

	    const d0 = maxA - minB;
	    const d1 = maxB - minA;
	    const depth = d0 < d1 ? d0 : d1;
	    return depth;
	  }
	  /**
	   * calculateLocalInertia
	   */


	  calculateLocalInertia(mass, target) {
	    // Approximate with box inertia
	    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
	    const aabbmax = new Vec3();
	    const aabbmin = new Vec3();
	    this.computeLocalAABB(aabbmin, aabbmax);
	    const x = aabbmax.x - aabbmin.x;
	    const y = aabbmax.y - aabbmin.y;
	    const z = aabbmax.z - aabbmin.z;
	    target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
	    target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
	    target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
	  }
	  /**
	   * @param face_i Index of the face
	   */


	  getPlaneConstantOfFace(face_i) {
	    const f = this.faces[face_i];
	    const n = this.faceNormals[face_i];
	    const v = this.vertices[f[0]];
	    const c = -n.dot(v);
	    return c;
	  }
	  /**
	   * Clip a face against a hull.
	   * @param worldVertsB1 An array of Vec3 with vertices in the world frame.
	   * @param minDist Distance clamping
	   * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
	   */


	  clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
	    const faceANormalWS = new Vec3();
	    const edge0 = new Vec3();
	    const WorldEdge0 = new Vec3();
	    const worldPlaneAnormal1 = new Vec3();
	    const planeNormalWS1 = new Vec3();
	    const worldA1 = new Vec3();
	    const localPlaneNormal = new Vec3();
	    const planeNormalWS = new Vec3();
	    const hullA = this;
	    const worldVertsB2 = [];
	    const pVtxIn = worldVertsB1;
	    const pVtxOut = worldVertsB2;
	    let closestFaceA = -1;
	    let dmin = Number.MAX_VALUE; // Find the face with normal closest to the separating axis

	    for (let face = 0; face < hullA.faces.length; face++) {
	      faceANormalWS.copy(hullA.faceNormals[face]);
	      quatA.vmult(faceANormalWS, faceANormalWS);
	      const d = faceANormalWS.dot(separatingNormal);

	      if (d < dmin) {
	        dmin = d;
	        closestFaceA = face;
	      }
	    }

	    if (closestFaceA < 0) {
	      return;
	    } // Get the face and construct connected faces


	    const polyA = hullA.faces[closestFaceA];
	    polyA.connectedFaces = [];

	    for (let i = 0; i < hullA.faces.length; i++) {
	      for (let j = 0; j < hullA.faces[i].length; j++) {
	        if (
	        /* Sharing a vertex*/
	        polyA.indexOf(hullA.faces[i][j]) !== -1 &&
	        /* Not the one we are looking for connections from */
	        i !== closestFaceA &&
	        /* Not already added */
	        polyA.connectedFaces.indexOf(i) === -1) {
	          polyA.connectedFaces.push(i);
	        }
	      }
	    } // Clip the polygon to the back of the planes of all faces of hull A,
	    // that are adjacent to the witness face


	    const numVerticesA = polyA.length;

	    for (let i = 0; i < numVerticesA; i++) {
	      const a = hullA.vertices[polyA[i]];
	      const b = hullA.vertices[polyA[(i + 1) % numVerticesA]];
	      a.vsub(b, edge0);
	      WorldEdge0.copy(edge0);
	      quatA.vmult(WorldEdge0, WorldEdge0);
	      posA.vadd(WorldEdge0, WorldEdge0);
	      worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);
	      quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
	      posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
	      WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
	      planeNormalWS1.negate(planeNormalWS1);
	      worldA1.copy(a);
	      quatA.vmult(worldA1, worldA1);
	      posA.vadd(worldA1, worldA1);
	      const otherFace = polyA.connectedFaces[i];
	      localPlaneNormal.copy(this.faceNormals[otherFace]);
	      const localPlaneEq = this.getPlaneConstantOfFace(otherFace);
	      planeNormalWS.copy(localPlaneNormal);
	      quatA.vmult(planeNormalWS, planeNormalWS);
	      const planeEqWS = localPlaneEq - planeNormalWS.dot(posA); // Clip face against our constructed plane

	      this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS); // Throw away all clipped points, but save the remaining until next clip

	      while (pVtxIn.length) {
	        pVtxIn.shift();
	      }

	      while (pVtxOut.length) {
	        pVtxIn.push(pVtxOut.shift());
	      }
	    } // only keep contact points that are behind the witness face


	    localPlaneNormal.copy(this.faceNormals[closestFaceA]);
	    const localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
	    planeNormalWS.copy(localPlaneNormal);
	    quatA.vmult(planeNormalWS, planeNormalWS);
	    const planeEqWS = localPlaneEq - planeNormalWS.dot(posA);

	    for (let i = 0; i < pVtxIn.length; i++) {
	      let depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; // ???

	      if (depth <= minDist) {
	        console.log(`clamped: depth=${depth} to minDist=${minDist}`);
	        depth = minDist;
	      }

	      if (depth <= maxDist) {
	        const point = pVtxIn[i];

	        if (depth <= 1e-6) {
	          const p = {
	            point,
	            normal: planeNormalWS,
	            depth
	          };
	          result.push(p);
	        }
	      }
	    }
	  }
	  /**
	   * Clip a face in a hull against the back of a plane.
	   * @param planeConstant The constant in the mathematical plane equation
	   */


	  clipFaceAgainstPlane(inVertices, outVertices, planeNormal, planeConstant) {
	    let n_dot_first;
	    let n_dot_last;
	    const numVerts = inVertices.length;

	    if (numVerts < 2) {
	      return outVertices;
	    }

	    let firstVertex = inVertices[inVertices.length - 1];
	    let lastVertex = inVertices[0];
	    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

	    for (let vi = 0; vi < numVerts; vi++) {
	      lastVertex = inVertices[vi];
	      n_dot_last = planeNormal.dot(lastVertex) + planeConstant;

	      if (n_dot_first < 0) {
	        if (n_dot_last < 0) {
	          // Start < 0, end < 0, so output lastVertex
	          const newv = new Vec3();
	          newv.copy(lastVertex);
	          outVertices.push(newv);
	        } else {
	          // Start < 0, end >= 0, so output intersection
	          const newv = new Vec3();
	          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
	          outVertices.push(newv);
	        }
	      } else {
	        if (n_dot_last < 0) {
	          // Start >= 0, end < 0 so output intersection and end
	          const newv = new Vec3();
	          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
	          outVertices.push(newv);
	          outVertices.push(lastVertex);
	        }
	      }

	      firstVertex = lastVertex;
	      n_dot_first = n_dot_last;
	    }

	    return outVertices;
	  }
	  /**
	   * Updates `.worldVertices` and sets `.worldVerticesNeedsUpdate` to false.
	   */


	  computeWorldVertices(position, quat) {
	    while (this.worldVertices.length < this.vertices.length) {
	      this.worldVertices.push(new Vec3());
	    }

	    const verts = this.vertices;
	    const worldVerts = this.worldVertices;

	    for (let i = 0; i !== this.vertices.length; i++) {
	      quat.vmult(verts[i], worldVerts[i]);
	      position.vadd(worldVerts[i], worldVerts[i]);
	    }

	    this.worldVerticesNeedsUpdate = false;
	  }

	  computeLocalAABB(aabbmin, aabbmax) {
	    const vertices = this.vertices;
	    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
	    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

	    for (let i = 0; i < this.vertices.length; i++) {
	      const v = vertices[i];

	      if (v.x < aabbmin.x) {
	        aabbmin.x = v.x;
	      } else if (v.x > aabbmax.x) {
	        aabbmax.x = v.x;
	      }

	      if (v.y < aabbmin.y) {
	        aabbmin.y = v.y;
	      } else if (v.y > aabbmax.y) {
	        aabbmax.y = v.y;
	      }

	      if (v.z < aabbmin.z) {
	        aabbmin.z = v.z;
	      } else if (v.z > aabbmax.z) {
	        aabbmax.z = v.z;
	      }
	    }
	  }
	  /**
	   * Updates `worldVertices` and sets `worldVerticesNeedsUpdate` to false.
	   */


	  computeWorldFaceNormals(quat) {
	    const N = this.faceNormals.length;

	    while (this.worldFaceNormals.length < N) {
	      this.worldFaceNormals.push(new Vec3());
	    }

	    const normals = this.faceNormals;
	    const worldNormals = this.worldFaceNormals;

	    for (let i = 0; i !== N; i++) {
	      quat.vmult(normals[i], worldNormals[i]);
	    }

	    this.worldFaceNormalsNeedsUpdate = false;
	  }
	  /**
	   * updateBoundingSphereRadius
	   */


	  updateBoundingSphereRadius() {
	    // Assume points are distributed with local (0,0,0) as center
	    let max2 = 0;
	    const verts = this.vertices;

	    for (let i = 0; i !== verts.length; i++) {
	      const norm2 = verts[i].lengthSquared();

	      if (norm2 > max2) {
	        max2 = norm2;
	      }
	    }

	    this.boundingSphereRadius = Math.sqrt(max2);
	  }
	  /**
	   * calculateWorldAABB
	   */


	  calculateWorldAABB(pos, quat, min, max) {
	    const verts = this.vertices;
	    let minx;
	    let miny;
	    let minz;
	    let maxx;
	    let maxy;
	    let maxz;
	    let tempWorldVertex = new Vec3();

	    for (let i = 0; i < verts.length; i++) {
	      tempWorldVertex.copy(verts[i]);
	      quat.vmult(tempWorldVertex, tempWorldVertex);
	      pos.vadd(tempWorldVertex, tempWorldVertex);
	      const v = tempWorldVertex;

	      if (minx === undefined || v.x < minx) {
	        minx = v.x;
	      }

	      if (maxx === undefined || v.x > maxx) {
	        maxx = v.x;
	      }

	      if (miny === undefined || v.y < miny) {
	        miny = v.y;
	      }

	      if (maxy === undefined || v.y > maxy) {
	        maxy = v.y;
	      }

	      if (minz === undefined || v.z < minz) {
	        minz = v.z;
	      }

	      if (maxz === undefined || v.z > maxz) {
	        maxz = v.z;
	      }
	    }

	    min.set(minx, miny, minz);
	    max.set(maxx, maxy, maxz);
	  }
	  /**
	   * Get approximate convex volume
	   */


	  volume() {
	    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
	  }
	  /**
	   * Get an average of all the vertices positions
	   */


	  getAveragePointLocal(target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    const verts = this.vertices;

	    for (let i = 0; i < verts.length; i++) {
	      target.vadd(verts[i], target);
	    }

	    target.scale(1 / verts.length, target);
	    return target;
	  }
	  /**
	   * Transform all local points. Will change the .vertices
	   */


	  transformAllPoints(offset, quat) {
	    const n = this.vertices.length;
	    const verts = this.vertices; // Apply rotation

	    if (quat) {
	      // Rotate vertices
	      for (let i = 0; i < n; i++) {
	        const v = verts[i];
	        quat.vmult(v, v);
	      } // Rotate face normals


	      for (let i = 0; i < this.faceNormals.length; i++) {
	        const v = this.faceNormals[i];
	        quat.vmult(v, v);
	      }
	      /*
	            // Rotate edges
	            for(let i=0; i<this.uniqueEdges.length; i++){
	                const v = this.uniqueEdges[i];
	                quat.vmult(v,v);
	            }*/

	    } // Apply offset


	    if (offset) {
	      for (let i = 0; i < n; i++) {
	        const v = verts[i];
	        v.vadd(offset, v);
	      }
	    }
	  }
	  /**
	   * Checks whether p is inside the polyhedra. Must be in local coords.
	   * The point lies outside of the convex hull of the other points if and only if the direction
	   * of all the vectors from it to those other points are on less than one half of a sphere around it.
	   * @param p A point given in local coordinates
	   */


	  pointIsInside(p) {
	    const verts = this.vertices;
	    const faces = this.faces;
	    const normals = this.faceNormals;
	    const positiveResult = null;
	    const pointInside = new Vec3();
	    this.getAveragePointLocal(pointInside);

	    for (let i = 0; i < this.faces.length; i++) {
	      let n = normals[i];
	      const v = verts[faces[i][0]]; // We only need one point in the face
	      // This dot product determines which side of the edge the point is

	      const vToP = new Vec3();
	      p.vsub(v, vToP);
	      const r1 = n.dot(vToP);
	      const vToPointInside = new Vec3();
	      pointInside.vsub(v, vToPointInside);
	      const r2 = n.dot(vToPointInside);

	      if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) {
	        return false; // Encountered some other sign. Exit.
	      }
	    } // If we got here, all dot products were of the same sign.


	    return positiveResult ? 1 : -1;
	  }
	  /**
	   * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.
	   * Results are saved in the array maxmin.
	   * @param result result[0] and result[1] will be set to maximum and minimum, respectively.
	   */


	  static project(shape, axis, pos, quat, result) {
	    const n = shape.vertices.length;
	    const localAxis = project_localAxis;
	    let max = 0;
	    let min = 0;
	    const localOrigin = project_localOrigin;
	    const vs = shape.vertices;
	    localOrigin.setZero(); // Transform the axis to local

	    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
	    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
	    const add = localOrigin.dot(localAxis);
	    min = max = vs[0].dot(localAxis);

	    for (let i = 1; i < n; i++) {
	      const val = vs[i].dot(localAxis);

	      if (val > max) {
	        max = val;
	      }

	      if (val < min) {
	        min = val;
	      }
	    }

	    min -= add;
	    max -= add;

	    if (min > max) {
	      // Inconsistent - swap
	      const temp = min;
	      min = max;
	      max = temp;
	    } // Output


	    result[0] = max;
	    result[1] = min;
	  }

	}
	const maxminA = [];
	const maxminB = [];
	new Vec3();
	const project_localAxis = new Vec3();
	const project_localOrigin = new Vec3();

	/**
	 * A 3d box shape.
	 * @example
	 *     const size = 1
	 *     const halfExtents = new CANNON.Vec3(size, size, size)
	 *     const boxShape = new CANNON.Box(halfExtents)
	 *     const boxBody = new CANNON.Body({ mass: 1, shape: boxShape })
	 *     world.addBody(boxBody)
	 */
	class PhysBox extends Shape {
	  /**
	   * The half extents of the box.
	   */

	  /**
	   * Used by the contact generator to make contacts with other convex polyhedra for example.
	   */
	  constructor(halfExtents) {
	    super({
	      type: Shape.types.BOX
	    });
	    this.halfExtents = halfExtents;
	    this.convexPolyhedronRepresentation = null;
	    this.updateConvexPolyhedronRepresentation();
	    this.updateBoundingSphereRadius();
	  }
	  /**
	   * Updates the local convex polyhedron representation used for some collisions.
	   */


	  updateConvexPolyhedronRepresentation() {
	    const sx = this.halfExtents.x;
	    const sy = this.halfExtents.y;
	    const sz = this.halfExtents.z;
	    const V = Vec3;
	    const vertices = [new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz)];
	    const faces = [[3, 2, 1, 0], // -z
	    [4, 5, 6, 7], // +z
	    [5, 4, 0, 1], // -y
	    [2, 3, 7, 6], // +y
	    [0, 4, 7, 3], // -x
	    [1, 2, 6, 5] // +x
	    ];
	    const axes = [new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0)];
	    const h = new ConvexPolyhedron({
	      vertices,
	      faces,
	      axes
	    });
	    this.convexPolyhedronRepresentation = h;
	    h.material = this.material;
	  }
	  /**
	   * Calculate the inertia of the box.
	   */


	  calculateLocalInertia(mass, target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    Box.calculateInertia(this.halfExtents, mass, target);
	    return target;
	  }

	  static calculateInertia(halfExtents, mass, target) {
	    const e = halfExtents;
	    target.x = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
	    target.y = 1.0 / 12.0 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
	    target.z = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
	  }
	  /**
	   * Get the box 6 side normals
	   * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
	   * @param quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
	   */


	  getSideNormals(sixTargetVectors, quat) {
	    const sides = sixTargetVectors;
	    const ex = this.halfExtents;
	    sides[0].set(ex.x, 0, 0);
	    sides[1].set(0, ex.y, 0);
	    sides[2].set(0, 0, ex.z);
	    sides[3].set(-ex.x, 0, 0);
	    sides[4].set(0, -ex.y, 0);
	    sides[5].set(0, 0, -ex.z);

	    if (quat !== undefined) {
	      for (let i = 0; i !== sides.length; i++) {
	        quat.vmult(sides[i], sides[i]);
	      }
	    }

	    return sides;
	  }
	  /**
	   * Returns the volume of the box.
	   */


	  volume() {
	    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
	  }
	  /**
	   * updateBoundingSphereRadius
	   */


	  updateBoundingSphereRadius() {
	    this.boundingSphereRadius = this.halfExtents.length();
	  }
	  /**
	   * forEachWorldCorner
	   */


	  forEachWorldCorner(pos, quat, callback) {
	    const e = this.halfExtents;
	    const corners = [[e.x, e.y, e.z], [-e.x, e.y, e.z], [-e.x, -e.y, e.z], [-e.x, -e.y, -e.z], [e.x, -e.y, -e.z], [e.x, e.y, -e.z], [-e.x, e.y, -e.z], [e.x, -e.y, e.z]];

	    for (let i = 0; i < corners.length; i++) {
	      worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);
	      quat.vmult(worldCornerTempPos, worldCornerTempPos);
	      pos.vadd(worldCornerTempPos, worldCornerTempPos);
	      callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
	    }
	  }
	  /**
	   * calculateWorldAABB
	   */


	  calculateWorldAABB(pos, quat, min, max) {
	    const e = this.halfExtents;
	    worldCornersTemp[0].set(e.x, e.y, e.z);
	    worldCornersTemp[1].set(-e.x, e.y, e.z);
	    worldCornersTemp[2].set(-e.x, -e.y, e.z);
	    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
	    worldCornersTemp[4].set(e.x, -e.y, -e.z);
	    worldCornersTemp[5].set(e.x, e.y, -e.z);
	    worldCornersTemp[6].set(-e.x, e.y, -e.z);
	    worldCornersTemp[7].set(e.x, -e.y, e.z);
	    const wc = worldCornersTemp[0];
	    quat.vmult(wc, wc);
	    pos.vadd(wc, wc);
	    max.copy(wc);
	    min.copy(wc);

	    for (let i = 1; i < 8; i++) {
	      const wc = worldCornersTemp[i];
	      quat.vmult(wc, wc);
	      pos.vadd(wc, wc);
	      const x = wc.x;
	      const y = wc.y;
	      const z = wc.z;

	      if (x > max.x) {
	        max.x = x;
	      }

	      if (y > max.y) {
	        max.y = y;
	      }

	      if (z > max.z) {
	        max.z = z;
	      }

	      if (x < min.x) {
	        min.x = x;
	      }

	      if (y < min.y) {
	        min.y = y;
	      }

	      if (z < min.z) {
	        min.z = z;
	      }
	    } // Get each axis max
	    // min.set(Infinity,Infinity,Infinity);
	    // max.set(-Infinity,-Infinity,-Infinity);
	    // this.forEachWorldCorner(pos,quat,function(x,y,z){
	    //     if(x > max.x){
	    //         max.x = x;
	    //     }
	    //     if(y > max.y){
	    //         max.y = y;
	    //     }
	    //     if(z > max.z){
	    //         max.z = z;
	    //     }
	    //     if(x < min.x){
	    //         min.x = x;
	    //     }
	    //     if(y < min.y){
	    //         min.y = y;
	    //     }
	    //     if(z < min.z){
	    //         min.z = z;
	    //     }
	    // });

	  }

	}
	const worldCornerTempPos = new Vec3();
	const worldCornersTemp = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

	/**
	 * BODY_TYPES
	 */
	const BODY_TYPES = {
	  /** DYNAMIC */
	  DYNAMIC: 1,

	  /** STATIC */
	  STATIC: 2,

	  /** KINEMATIC */
	  KINEMATIC: 4
	};
	/**
	 * BodyType
	 */

	/**
	 * BODY_SLEEP_STATES
	 */
	const BODY_SLEEP_STATES = {
	  /** AWAKE */
	  AWAKE: 0,

	  /** SLEEPY */
	  SLEEPY: 1,

	  /** SLEEPING */
	  SLEEPING: 2
	};
	/**
	 * BodySleepState
	 */

	/**
	 * Base class for all body types.
	 * @example
	 *     const shape = new CANNON.Sphere(1)
	 *     const body = new CANNON.Body({
	 *       mass: 1,
	 *       shape,
	 *     })
	 *     world.addBody(body)
	 */
	class Body extends EventTarget {
	  /**
	   * Dispatched after two bodies collide. This event is dispatched on each
	   * of the two bodies involved in the collision.
	   * @event collide
	   * @param body The body that was involved in the collision.
	   * @param contact The details of the collision.
	   */

	  /**
	   * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
	   */

	  /**
	   * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
	   */

	  /**
	   * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
	   */

	  /**
	   * AWAKE
	   */

	  /**
	   * SLEEPY
	   */

	  /**
	   * SLEEPING
	   */

	  /**
	   * Dispatched after a sleeping body has woken up.
	   * @event wakeup
	   */

	  /**
	   * Dispatched after a body has gone in to the sleepy state.
	   * @event sleepy
	   */

	  /**
	   * Dispatched after a body has fallen asleep.
	   * @event sleep
	   */
	  constructor(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    super();
	    this.id = Body.idCounter++;
	    this.index = -1;
	    this.world = null;
	    this.vlambda = new Vec3();
	    this.collisionFilterGroup = typeof options.collisionFilterGroup === 'number' ? options.collisionFilterGroup : 1;
	    this.collisionFilterMask = typeof options.collisionFilterMask === 'number' ? options.collisionFilterMask : -1;
	    this.collisionResponse = typeof options.collisionResponse === 'boolean' ? options.collisionResponse : true;
	    this.position = new Vec3();
	    this.previousPosition = new Vec3();
	    this.interpolatedPosition = new Vec3();
	    this.initPosition = new Vec3();

	    if (options.position) {
	      this.position.copy(options.position);
	      this.previousPosition.copy(options.position);
	      this.interpolatedPosition.copy(options.position);
	      this.initPosition.copy(options.position);
	    }

	    this.velocity = new Vec3();

	    if (options.velocity) {
	      this.velocity.copy(options.velocity);
	    }

	    this.initVelocity = new Vec3();
	    this.force = new Vec3();
	    const mass = typeof options.mass === 'number' ? options.mass : 0;
	    this.mass = mass;
	    this.invMass = mass > 0 ? 1.0 / mass : 0;
	    this.material = options.material || null;
	    this.linearDamping = typeof options.linearDamping === 'number' ? options.linearDamping : 0.01;
	    this.type = mass <= 0.0 ? Body.STATIC : Body.DYNAMIC;

	    if (typeof options.type === typeof Body.STATIC) {
	      this.type = options.type;
	    }

	    this.allowSleep = typeof options.allowSleep !== 'undefined' ? options.allowSleep : true;
	    this.sleepState = Body.AWAKE;
	    this.sleepSpeedLimit = typeof options.sleepSpeedLimit !== 'undefined' ? options.sleepSpeedLimit : 0.1;
	    this.sleepTimeLimit = typeof options.sleepTimeLimit !== 'undefined' ? options.sleepTimeLimit : 1;
	    this.timeLastSleepy = 0;
	    this.wakeUpAfterNarrowphase = false;
	    this.torque = new Vec3();
	    this.quaternion = new Quaternion();
	    this.initQuaternion = new Quaternion();
	    this.previousQuaternion = new Quaternion();
	    this.interpolatedQuaternion = new Quaternion();

	    if (options.quaternion) {
	      this.quaternion.copy(options.quaternion);
	      this.initQuaternion.copy(options.quaternion);
	      this.previousQuaternion.copy(options.quaternion);
	      this.interpolatedQuaternion.copy(options.quaternion);
	    }

	    this.angularVelocity = new Vec3();

	    if (options.angularVelocity) {
	      this.angularVelocity.copy(options.angularVelocity);
	    }

	    this.initAngularVelocity = new Vec3();
	    this.shapes = [];
	    this.shapeOffsets = [];
	    this.shapeOrientations = [];
	    this.inertia = new Vec3();
	    this.invInertia = new Vec3();
	    this.invInertiaWorld = new Mat3();
	    this.invMassSolve = 0;
	    this.invInertiaSolve = new Vec3();
	    this.invInertiaWorldSolve = new Mat3();
	    this.fixedRotation = typeof options.fixedRotation !== 'undefined' ? options.fixedRotation : false;
	    this.angularDamping = typeof options.angularDamping !== 'undefined' ? options.angularDamping : 0.01;
	    this.linearFactor = new Vec3(1, 1, 1);

	    if (options.linearFactor) {
	      this.linearFactor.copy(options.linearFactor);
	    }

	    this.angularFactor = new Vec3(1, 1, 1);

	    if (options.angularFactor) {
	      this.angularFactor.copy(options.angularFactor);
	    }

	    this.aabb = new AABB();
	    this.aabbNeedsUpdate = true;
	    this.boundingRadius = 0;
	    this.wlambda = new Vec3();
	    this.isTrigger = Boolean(options.isTrigger);

	    if (options.shape) {
	      this.addShape(options.shape);
	    }

	    this.updateMassProperties();
	  }
	  /**
	   * Wake the body up.
	   */


	  wakeUp() {
	    const prevState = this.sleepState;
	    this.sleepState = Body.AWAKE;
	    this.wakeUpAfterNarrowphase = false;

	    if (prevState === Body.SLEEPING) {
	      this.dispatchEvent(Body.wakeupEvent);
	    }
	  }
	  /**
	   * Force body sleep
	   */


	  sleep() {
	    this.sleepState = Body.SLEEPING;
	    this.velocity.set(0, 0, 0);
	    this.angularVelocity.set(0, 0, 0);
	    this.wakeUpAfterNarrowphase = false;
	  }
	  /**
	   * Called every timestep to update internal sleep timer and change sleep state if needed.
	   * @param time The world time in seconds
	   */


	  sleepTick(time) {
	    if (this.allowSleep) {
	      const sleepState = this.sleepState;
	      const speedSquared = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared();
	      const speedLimitSquared = this.sleepSpeedLimit ** 2;

	      if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
	        this.sleepState = Body.SLEEPY; // Sleepy

	        this.timeLastSleepy = time;
	        this.dispatchEvent(Body.sleepyEvent);
	      } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {
	        this.wakeUp(); // Wake up
	      } else if (sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit) {
	        this.sleep(); // Sleeping

	        this.dispatchEvent(Body.sleepEvent);
	      }
	    }
	  }
	  /**
	   * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
	   */


	  updateSolveMassProperties() {
	    if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
	      this.invMassSolve = 0;
	      this.invInertiaSolve.setZero();
	      this.invInertiaWorldSolve.setZero();
	    } else {
	      this.invMassSolve = this.invMass;
	      this.invInertiaSolve.copy(this.invInertia);
	      this.invInertiaWorldSolve.copy(this.invInertiaWorld);
	    }
	  }
	  /**
	   * Convert a world point to local body frame.
	   */


	  pointToLocalFrame(worldPoint, result) {
	    if (result === void 0) {
	      result = new Vec3();
	    }

	    worldPoint.vsub(this.position, result);
	    this.quaternion.conjugate().vmult(result, result);
	    return result;
	  }
	  /**
	   * Convert a world vector to local body frame.
	   */


	  vectorToLocalFrame(worldVector, result) {
	    if (result === void 0) {
	      result = new Vec3();
	    }

	    this.quaternion.conjugate().vmult(worldVector, result);
	    return result;
	  }
	  /**
	   * Convert a local body point to world frame.
	   */


	  pointToWorldFrame(localPoint, result) {
	    if (result === void 0) {
	      result = new Vec3();
	    }

	    this.quaternion.vmult(localPoint, result);
	    result.vadd(this.position, result);
	    return result;
	  }
	  /**
	   * Convert a local body point to world frame.
	   */


	  vectorToWorldFrame(localVector, result) {
	    if (result === void 0) {
	      result = new Vec3();
	    }

	    this.quaternion.vmult(localVector, result);
	    return result;
	  }
	  /**
	   * Add a shape to the body with a local offset and orientation.
	   * @return The body object, for chainability.
	   */


	  addShape(shape, _offset, _orientation) {
	    const offset = new Vec3();
	    const orientation = new Quaternion();

	    if (_offset) {
	      offset.copy(_offset);
	    }

	    if (_orientation) {
	      orientation.copy(_orientation);
	    }

	    this.shapes.push(shape);
	    this.shapeOffsets.push(offset);
	    this.shapeOrientations.push(orientation);
	    this.updateMassProperties();
	    this.updateBoundingRadius();
	    this.aabbNeedsUpdate = true;
	    shape.body = this;
	    return this;
	  }
	  /**
	   * Remove a shape from the body.
	   * @return The body object, for chainability.
	   */


	  removeShape(shape) {
	    const index = this.shapes.indexOf(shape);

	    if (index === -1) {
	      console.warn('Shape does not belong to the body');
	      return this;
	    }

	    this.shapes.splice(index, 1);
	    this.shapeOffsets.splice(index, 1);
	    this.shapeOrientations.splice(index, 1);
	    this.updateMassProperties();
	    this.updateBoundingRadius();
	    this.aabbNeedsUpdate = true;
	    shape.body = null;
	    return this;
	  }
	  /**
	   * Update the bounding radius of the body. Should be done if any of the shapes are changed.
	   */


	  updateBoundingRadius() {
	    const shapes = this.shapes;
	    const shapeOffsets = this.shapeOffsets;
	    const N = shapes.length;
	    let radius = 0;

	    for (let i = 0; i !== N; i++) {
	      const shape = shapes[i];
	      shape.updateBoundingSphereRadius();
	      const offset = shapeOffsets[i].length();
	      const r = shape.boundingSphereRadius;

	      if (offset + r > radius) {
	        radius = offset + r;
	      }
	    }

	    this.boundingRadius = radius;
	  }
	  /**
	   * Updates the .aabb
	   */


	  updateAABB() {
	    const shapes = this.shapes;
	    const shapeOffsets = this.shapeOffsets;
	    const shapeOrientations = this.shapeOrientations;
	    const N = shapes.length;
	    const offset = tmpVec;
	    const orientation = tmpQuat;
	    const bodyQuat = this.quaternion;
	    const aabb = this.aabb;
	    const shapeAABB = updateAABB_shapeAABB;

	    for (let i = 0; i !== N; i++) {
	      const shape = shapes[i]; // Get shape world position

	      bodyQuat.vmult(shapeOffsets[i], offset);
	      offset.vadd(this.position, offset); // Get shape world quaternion

	      bodyQuat.mult(shapeOrientations[i], orientation); // Get shape AABB

	      shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

	      if (i === 0) {
	        aabb.copy(shapeAABB);
	      } else {
	        aabb.extend(shapeAABB);
	      }
	    }

	    this.aabbNeedsUpdate = false;
	  }
	  /**
	   * Update `.inertiaWorld` and `.invInertiaWorld`
	   */


	  updateInertiaWorld(force) {
	    const I = this.invInertia;

	    if (I.x === I.y && I.y === I.z && !force) ; else {
	      const m1 = uiw_m1;
	      const m2 = uiw_m2;
	      m1.setRotationFromQuaternion(this.quaternion);
	      m1.transpose(m2);
	      m1.scale(I, m1);
	      m1.mmult(m2, this.invInertiaWorld);
	    }
	  }
	  /**
	   * Apply force to a point of the body. This could for example be a point on the Body surface.
	   * Applying force this way will add to Body.force and Body.torque.
	   * @param force The amount of force to add.
	   * @param relativePoint A point relative to the center of mass to apply the force on.
	   */


	  applyForce(force, relativePoint) {
	    if (relativePoint === void 0) {
	      relativePoint = new Vec3();
	    }

	    // Needed?
	    if (this.type !== Body.DYNAMIC) {
	      return;
	    }

	    if (this.sleepState === Body.SLEEPING) {
	      this.wakeUp();
	    } // Compute produced rotational force


	    const rotForce = Body_applyForce_rotForce;
	    relativePoint.cross(force, rotForce); // Add linear force

	    this.force.vadd(force, this.force); // Add rotational force

	    this.torque.vadd(rotForce, this.torque);
	  }
	  /**
	   * Apply force to a local point in the body.
	   * @param force The force vector to apply, defined locally in the body frame.
	   * @param localPoint A local point in the body to apply the force on.
	   */


	  applyLocalForce(localForce, localPoint) {
	    if (localPoint === void 0) {
	      localPoint = new Vec3();
	    }

	    if (this.type !== Body.DYNAMIC) {
	      return;
	    }

	    const worldForce = Body_applyLocalForce_worldForce;
	    const relativePointWorld = Body_applyLocalForce_relativePointWorld; // Transform the force vector to world space

	    this.vectorToWorldFrame(localForce, worldForce);
	    this.vectorToWorldFrame(localPoint, relativePointWorld);
	    this.applyForce(worldForce, relativePointWorld);
	  }
	  /**
	   * Apply torque to the body.
	   * @param torque The amount of torque to add.
	   */


	  applyTorque(torque) {
	    if (this.type !== Body.DYNAMIC) {
	      return;
	    }

	    if (this.sleepState === Body.SLEEPING) {
	      this.wakeUp();
	    } // Add rotational force


	    this.torque.vadd(torque, this.torque);
	  }
	  /**
	   * Apply impulse to a point of the body. This could for example be a point on the Body surface.
	   * An impulse is a force added to a body during a short period of time (impulse = force * time).
	   * Impulses will be added to Body.velocity and Body.angularVelocity.
	   * @param impulse The amount of impulse to add.
	   * @param relativePoint A point relative to the center of mass to apply the force on.
	   */


	  applyImpulse(impulse, relativePoint) {
	    if (relativePoint === void 0) {
	      relativePoint = new Vec3();
	    }

	    if (this.type !== Body.DYNAMIC) {
	      return;
	    }

	    if (this.sleepState === Body.SLEEPING) {
	      this.wakeUp();
	    } // Compute point position relative to the body center


	    const r = relativePoint; // Compute produced central impulse velocity

	    const velo = Body_applyImpulse_velo;
	    velo.copy(impulse);
	    velo.scale(this.invMass, velo); // Add linear impulse

	    this.velocity.vadd(velo, this.velocity); // Compute produced rotational impulse velocity

	    const rotVelo = Body_applyImpulse_rotVelo;
	    r.cross(impulse, rotVelo);
	    /*
	     rotVelo.x *= this.invInertia.x;
	     rotVelo.y *= this.invInertia.y;
	     rotVelo.z *= this.invInertia.z;
	     */

	    this.invInertiaWorld.vmult(rotVelo, rotVelo); // Add rotational Impulse

	    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
	  }
	  /**
	   * Apply locally-defined impulse to a local point in the body.
	   * @param force The force vector to apply, defined locally in the body frame.
	   * @param localPoint A local point in the body to apply the force on.
	   */


	  applyLocalImpulse(localImpulse, localPoint) {
	    if (localPoint === void 0) {
	      localPoint = new Vec3();
	    }

	    if (this.type !== Body.DYNAMIC) {
	      return;
	    }

	    const worldImpulse = Body_applyLocalImpulse_worldImpulse;
	    const relativePointWorld = Body_applyLocalImpulse_relativePoint; // Transform the force vector to world space

	    this.vectorToWorldFrame(localImpulse, worldImpulse);
	    this.vectorToWorldFrame(localPoint, relativePointWorld);
	    this.applyImpulse(worldImpulse, relativePointWorld);
	  }
	  /**
	   * Should be called whenever you change the body shape or mass.
	   */


	  updateMassProperties() {
	    const halfExtents = Body_updateMassProperties_halfExtents;
	    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
	    const I = this.inertia;
	    const fixed = this.fixedRotation; // Approximate with AABB box

	    this.updateAABB();
	    halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
	    PhysBox.calculateInertia(halfExtents, this.mass, I);
	    this.invInertia.set(I.x > 0 && !fixed ? 1.0 / I.x : 0, I.y > 0 && !fixed ? 1.0 / I.y : 0, I.z > 0 && !fixed ? 1.0 / I.z : 0);
	    this.updateInertiaWorld(true);
	  }
	  /**
	   * Get world velocity of a point in the body.
	   * @param worldPoint
	   * @param result
	   * @return The result vector.
	   */


	  getVelocityAtWorldPoint(worldPoint, result) {
	    const r = new Vec3();
	    worldPoint.vsub(this.position, r);
	    this.angularVelocity.cross(r, result);
	    this.velocity.vadd(result, result);
	    return result;
	  }
	  /**
	   * Move the body forward in time.
	   * @param dt Time step
	   * @param quatNormalize Set to true to normalize the body quaternion
	   * @param quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
	   */


	  integrate(dt, quatNormalize, quatNormalizeFast) {
	    // Save previous position
	    this.previousPosition.copy(this.position);
	    this.previousQuaternion.copy(this.quaternion);

	    if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) {
	      // Only for dynamic
	      return;
	    }

	    const velo = this.velocity;
	    const angularVelo = this.angularVelocity;
	    const pos = this.position;
	    const force = this.force;
	    const torque = this.torque;
	    const quat = this.quaternion;
	    const invMass = this.invMass;
	    const invInertia = this.invInertiaWorld;
	    const linearFactor = this.linearFactor;
	    const iMdt = invMass * dt;
	    velo.x += force.x * iMdt * linearFactor.x;
	    velo.y += force.y * iMdt * linearFactor.y;
	    velo.z += force.z * iMdt * linearFactor.z;
	    const e = invInertia.elements;
	    const angularFactor = this.angularFactor;
	    const tx = torque.x * angularFactor.x;
	    const ty = torque.y * angularFactor.y;
	    const tz = torque.z * angularFactor.z;
	    angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
	    angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
	    angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz); // Use new velocity  - leap frog

	    pos.x += velo.x * dt;
	    pos.y += velo.y * dt;
	    pos.z += velo.z * dt;
	    quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);

	    if (quatNormalize) {
	      if (quatNormalizeFast) {
	        quat.normalizeFast();
	      } else {
	        quat.normalize();
	      }
	    }

	    this.aabbNeedsUpdate = true; // Update world inertia

	    this.updateInertiaWorld();
	  }

	}
	Body.idCounter = 0;
	Body.COLLIDE_EVENT_NAME = 'collide';
	Body.DYNAMIC = BODY_TYPES.DYNAMIC;
	Body.STATIC = BODY_TYPES.STATIC;
	Body.KINEMATIC = BODY_TYPES.KINEMATIC;
	Body.AWAKE = BODY_SLEEP_STATES.AWAKE;
	Body.SLEEPY = BODY_SLEEP_STATES.SLEEPY;
	Body.SLEEPING = BODY_SLEEP_STATES.SLEEPING;
	Body.wakeupEvent = {
	  type: 'wakeup'
	};
	Body.sleepyEvent = {
	  type: 'sleepy'
	};
	Body.sleepEvent = {
	  type: 'sleep'
	};
	const tmpVec = new Vec3();
	const tmpQuat = new Quaternion();
	const updateAABB_shapeAABB = new AABB();
	const uiw_m1 = new Mat3();
	const uiw_m2 = new Mat3();
	new Mat3();
	const Body_applyForce_rotForce = new Vec3();
	const Body_applyLocalForce_worldForce = new Vec3();
	const Body_applyLocalForce_relativePointWorld = new Vec3();
	const Body_applyImpulse_velo = new Vec3();
	const Body_applyImpulse_rotVelo = new Vec3();
	const Body_applyLocalImpulse_worldImpulse = new Vec3();
	const Body_applyLocalImpulse_relativePoint = new Vec3();
	const Body_updateMassProperties_halfExtents = new Vec3();

	/**
	 * Base class for broadphase implementations
	 * @author schteppe
	 */
	class Broadphase {
	  /**
	   * The world to search for collisions in.
	   */

	  /**
	   * If set to true, the broadphase uses bounding boxes for intersection tests, else it uses bounding spheres.
	   */

	  /**
	   * Set to true if the objects in the world moved.
	   */
	  constructor() {
	    this.world = null;
	    this.useBoundingBoxes = false;
	    this.dirty = true;
	  }
	  /**
	   * Get the collision pairs from the world
	   * @param world The world to search in
	   * @param p1 Empty array to be filled with body objects
	   * @param p2 Empty array to be filled with body objects
	   */


	  collisionPairs(world, p1, p2) {
	    throw new Error('collisionPairs not implemented for this BroadPhase class!');
	  }
	  /**
	   * Check if a body pair needs to be intersection tested at all.
	   */


	  needBroadphaseCollision(bodyA, bodyB) {
	    // Check collision filter masks
	    if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {
	      return false;
	    } // Check types


	    if (((bodyA.type & Body.STATIC) !== 0 || bodyA.sleepState === Body.SLEEPING) && ((bodyB.type & Body.STATIC) !== 0 || bodyB.sleepState === Body.SLEEPING)) {
	      // Both bodies are static or sleeping. Skip.
	      return false;
	    }

	    return true;
	  }
	  /**
	   * Check if the bounding volumes of two bodies intersect.
	   */


	  intersectionTest(bodyA, bodyB, pairs1, pairs2) {
	    if (this.useBoundingBoxes) {
	      this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
	    } else {
	      this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
	    }
	  }
	  /**
	   * Check if the bounding spheres of two bodies are intersecting.
	   * @param pairs1 bodyA is appended to this array if intersection
	   * @param pairs2 bodyB is appended to this array if intersection
	   */


	  doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2) {
	    const r = Broadphase_collisionPairs_r;
	    bodyB.position.vsub(bodyA.position, r);
	    const boundingRadiusSum2 = (bodyA.boundingRadius + bodyB.boundingRadius) ** 2;
	    const norm2 = r.lengthSquared();

	    if (norm2 < boundingRadiusSum2) {
	      pairs1.push(bodyA);
	      pairs2.push(bodyB);
	    }
	  }
	  /**
	   * Check if the bounding boxes of two bodies are intersecting.
	   */


	  doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2) {
	    if (bodyA.aabbNeedsUpdate) {
	      bodyA.updateAABB();
	    }

	    if (bodyB.aabbNeedsUpdate) {
	      bodyB.updateAABB();
	    } // Check AABB / AABB


	    if (bodyA.aabb.overlaps(bodyB.aabb)) {
	      pairs1.push(bodyA);
	      pairs2.push(bodyB);
	    }
	  }
	  /**
	   * Removes duplicate pairs from the pair arrays.
	   */


	  makePairsUnique(pairs1, pairs2) {
	    const t = Broadphase_makePairsUnique_temp;
	    const p1 = Broadphase_makePairsUnique_p1;
	    const p2 = Broadphase_makePairsUnique_p2;
	    const N = pairs1.length;

	    for (let i = 0; i !== N; i++) {
	      p1[i] = pairs1[i];
	      p2[i] = pairs2[i];
	    }

	    pairs1.length = 0;
	    pairs2.length = 0;

	    for (let i = 0; i !== N; i++) {
	      const id1 = p1[i].id;
	      const id2 = p2[i].id;
	      const key = id1 < id2 ? `${id1},${id2}` : `${id2},${id1}`;
	      t[key] = i;
	      t.keys.push(key);
	    }

	    for (let i = 0; i !== t.keys.length; i++) {
	      const key = t.keys.pop();
	      const pairIndex = t[key];
	      pairs1.push(p1[pairIndex]);
	      pairs2.push(p2[pairIndex]);
	      delete t[key];
	    }
	  }
	  /**
	   * To be implemented by subcasses
	   */


	  setWorld(world) {}
	  /**
	   * Check if the bounding spheres of two bodies overlap.
	   */


	  static boundingSphereCheck(bodyA, bodyB) {
	    const dist = new Vec3(); // bsc_dist;

	    bodyA.position.vsub(bodyB.position, dist);
	    const sa = bodyA.shapes[0];
	    const sb = bodyB.shapes[0];
	    return Math.pow(sa.boundingSphereRadius + sb.boundingSphereRadius, 2) > dist.lengthSquared();
	  }
	  /**
	   * Returns all the bodies within the AABB.
	   */


	  aabbQuery(world, aabb, result) {
	    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
	    return [];
	  }

	} // Temp objects

	const Broadphase_collisionPairs_r = new Vec3();
	new Vec3();
	new Quaternion();
	new Vec3();
	const Broadphase_makePairsUnique_temp = {
	  keys: []
	};
	const Broadphase_makePairsUnique_p1 = [];
	const Broadphase_makePairsUnique_p2 = [];
	new Vec3();
	new Vec3();
	new Vec3();

	/**
	 * Naive broadphase implementation, used in lack of better ones.
	 *
	 * The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 _(which is bad)_
	 */
	class NaiveBroadphase extends Broadphase {
	  /**
	   * @todo Remove useless constructor
	   */
	  constructor() {
	    super();
	  }
	  /**
	   * Get all the collision pairs in the physics world
	   */


	  collisionPairs(world, pairs1, pairs2) {
	    const bodies = world.bodies;
	    const n = bodies.length;
	    let bi;
	    let bj; // Naive N^2 ftw!

	    for (let i = 0; i !== n; i++) {
	      for (let j = 0; j !== i; j++) {
	        bi = bodies[i];
	        bj = bodies[j];

	        if (!this.needBroadphaseCollision(bi, bj)) {
	          continue;
	        }

	        this.intersectionTest(bi, bj, pairs1, pairs2);
	      }
	    }
	  }
	  /**
	   * Returns all the bodies within an AABB.
	   * @param result An array to store resulting bodies in.
	   */


	  aabbQuery(world, aabb, result) {
	    if (result === void 0) {
	      result = [];
	    }

	    for (let i = 0; i < world.bodies.length; i++) {
	      const b = world.bodies[i];

	      if (b.aabbNeedsUpdate) {
	        b.updateAABB();
	      } // Ugly hack until Body gets aabb


	      if (b.aabb.overlaps(aabb)) {
	        result.push(b);
	      }
	    }

	    return result;
	  }

	}

	/**
	 * Storage for Ray casting data
	 */
	class RaycastResult {
	  /**
	   * rayFromWorld
	   */

	  /**
	   * rayToWorld
	   */

	  /**
	   * hitNormalWorld
	   */

	  /**
	   * hitPointWorld
	   */

	  /**
	   * hasHit
	   */

	  /**
	   * shape
	   */

	  /**
	   * body
	   */

	  /**
	   * The index of the hit triangle, if the hit shape was a trimesh
	   */

	  /**
	   * Distance to the hit. Will be set to -1 if there was no hit
	   */

	  /**
	   * If the ray should stop traversing the bodies
	   */
	  constructor() {
	    this.rayFromWorld = new Vec3();
	    this.rayToWorld = new Vec3();
	    this.hitNormalWorld = new Vec3();
	    this.hitPointWorld = new Vec3();
	    this.hasHit = false;
	    this.shape = null;
	    this.body = null;
	    this.hitFaceIndex = -1;
	    this.distance = -1;
	    this.shouldStop = false;
	  }
	  /**
	   * Reset all result data.
	   */


	  reset() {
	    this.rayFromWorld.setZero();
	    this.rayToWorld.setZero();
	    this.hitNormalWorld.setZero();
	    this.hitPointWorld.setZero();
	    this.hasHit = false;
	    this.shape = null;
	    this.body = null;
	    this.hitFaceIndex = -1;
	    this.distance = -1;
	    this.shouldStop = false;
	  }
	  /**
	   * abort
	   */


	  abort() {
	    this.shouldStop = true;
	  }
	  /**
	   * Set result data.
	   */


	  set(rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {
	    this.rayFromWorld.copy(rayFromWorld);
	    this.rayToWorld.copy(rayToWorld);
	    this.hitNormalWorld.copy(hitNormalWorld);
	    this.hitPointWorld.copy(hitPointWorld);
	    this.shape = shape;
	    this.body = body;
	    this.distance = distance;
	  }

	}

	let _Shape$types$SPHERE, _Shape$types$PLANE, _Shape$types$BOX, _Shape$types$CYLINDER, _Shape$types$CONVEXPO, _Shape$types$HEIGHTFI, _Shape$types$TRIMESH;

	/**
	 * RAY_MODES
	 */
	const RAY_MODES = {
	  /** CLOSEST */
	  CLOSEST: 1,

	  /** ANY */
	  ANY: 2,

	  /** ALL */
	  ALL: 4
	};
	/**
	 * RayMode
	 */

	_Shape$types$SPHERE = Shape.types.SPHERE;
	_Shape$types$PLANE = Shape.types.PLANE;
	_Shape$types$BOX = Shape.types.BOX;
	_Shape$types$CYLINDER = Shape.types.CYLINDER;
	_Shape$types$CONVEXPO = Shape.types.CONVEXPOLYHEDRON;
	_Shape$types$HEIGHTFI = Shape.types.HEIGHTFIELD;
	_Shape$types$TRIMESH = Shape.types.TRIMESH;

	/**
	 * A line in 3D space that intersects bodies and return points.
	 */
	class Ray {
	  /**
	   * from
	   */

	  /**
	   * to
	   */

	  /**
	   * direction
	   */

	  /**
	   * The precision of the ray. Used when checking parallelity etc.
	   * @default 0.0001
	   */

	  /**
	   * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
	   * @default true
	   */

	  /**
	   * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
	   * @default false
	   */

	  /**
	   * collisionFilterMask
	   * @default -1
	   */

	  /**
	   * collisionFilterGroup
	   * @default -1
	   */

	  /**
	   * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
	   * @default RAY.ANY
	   */

	  /**
	   * Current result object.
	   */

	  /**
	   * Will be set to `true` during intersectWorld() if the ray hit anything.
	   */

	  /**
	   * User-provided result callback. Will be used if mode is Ray.ALL.
	   */

	  /**
	   * CLOSEST
	   */

	  /**
	   * ANY
	   */

	  /**
	   * ALL
	   */
	  get [_Shape$types$SPHERE]() {
	    return this._intersectSphere;
	  }

	  get [_Shape$types$PLANE]() {
	    return this._intersectPlane;
	  }

	  get [_Shape$types$BOX]() {
	    return this._intersectBox;
	  }

	  get [_Shape$types$CYLINDER]() {
	    return this._intersectConvex;
	  }

	  get [_Shape$types$CONVEXPO]() {
	    return this._intersectConvex;
	  }

	  get [_Shape$types$HEIGHTFI]() {
	    return this._intersectHeightfield;
	  }

	  get [_Shape$types$TRIMESH]() {
	    return this._intersectTrimesh;
	  }

	  constructor(from, to) {
	    if (from === void 0) {
	      from = new Vec3();
	    }

	    if (to === void 0) {
	      to = new Vec3();
	    }

	    this.from = from.clone();
	    this.to = to.clone();
	    this.direction = new Vec3();
	    this.precision = 0.0001;
	    this.checkCollisionResponse = true;
	    this.skipBackfaces = false;
	    this.collisionFilterMask = -1;
	    this.collisionFilterGroup = -1;
	    this.mode = Ray.ANY;
	    this.result = new RaycastResult();
	    this.hasHit = false;

	    this.callback = result => {};
	  }
	  /**
	   * Do itersection against all bodies in the given World.
	   * @return True if the ray hit anything, otherwise false.
	   */


	  intersectWorld(world, options) {
	    this.mode = options.mode || Ray.ANY;
	    this.result = options.result || new RaycastResult();
	    this.skipBackfaces = !!options.skipBackfaces;
	    this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;
	    this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;
	    this.checkCollisionResponse = typeof options.checkCollisionResponse !== 'undefined' ? options.checkCollisionResponse : true;

	    if (options.from) {
	      this.from.copy(options.from);
	    }

	    if (options.to) {
	      this.to.copy(options.to);
	    }

	    this.callback = options.callback || (() => {});

	    this.hasHit = false;
	    this.result.reset();
	    this.updateDirection();
	    this.getAABB(tmpAABB$1);
	    tmpArray.length = 0;
	    world.broadphase.aabbQuery(world, tmpAABB$1, tmpArray);
	    this.intersectBodies(tmpArray);
	    return this.hasHit;
	  }
	  /**
	   * Shoot a ray at a body, get back information about the hit.
	   * @deprecated @param result set the result property of the Ray instead.
	   */


	  intersectBody(body, result) {
	    if (result) {
	      this.result = result;
	      this.updateDirection();
	    }

	    const checkCollisionResponse = this.checkCollisionResponse;

	    if (checkCollisionResponse && !body.collisionResponse) {
	      return;
	    }

	    if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {
	      return;
	    }

	    const xi = intersectBody_xi;
	    const qi = intersectBody_qi;

	    for (let i = 0, N = body.shapes.length; i < N; i++) {
	      const shape = body.shapes[i];

	      if (checkCollisionResponse && !shape.collisionResponse) {
	        continue; // Skip
	      }

	      body.quaternion.mult(body.shapeOrientations[i], qi);
	      body.quaternion.vmult(body.shapeOffsets[i], xi);
	      xi.vadd(body.position, xi);
	      this.intersectShape(shape, qi, xi, body);

	      if (this.result.shouldStop) {
	        break;
	      }
	    }
	  }
	  /**
	   * Shoot a ray at an array bodies, get back information about the hit.
	   * @param bodies An array of Body objects.
	   * @deprecated @param result set the result property of the Ray instead.
	   *
	   */


	  intersectBodies(bodies, result) {
	    if (result) {
	      this.result = result;
	      this.updateDirection();
	    }

	    for (let i = 0, l = bodies.length; !this.result.shouldStop && i < l; i++) {
	      this.intersectBody(bodies[i]);
	    }
	  }
	  /**
	   * Updates the direction vector.
	   */


	  updateDirection() {
	    this.to.vsub(this.from, this.direction);
	    this.direction.normalize();
	  }

	  intersectShape(shape, quat, position, body) {
	    const from = this.from; // Checking boundingSphere

	    const distance = distanceFromIntersection(from, this.direction, position);

	    if (distance > shape.boundingSphereRadius) {
	      return;
	    }

	    const intersectMethod = this[shape.type];

	    if (intersectMethod) {
	      intersectMethod.call(this, shape, quat, position, body, shape);
	    }
	  }

	  _intersectBox(box, quat, position, body, reportedShape) {
	    return this._intersectConvex(box.convexPolyhedronRepresentation, quat, position, body, reportedShape);
	  }

	  _intersectPlane(shape, quat, position, body, reportedShape) {
	    const from = this.from;
	    const to = this.to;
	    const direction = this.direction; // Get plane normal

	    const worldNormal = new Vec3(0, 0, 1);
	    quat.vmult(worldNormal, worldNormal);
	    const len = new Vec3();
	    from.vsub(position, len);
	    const planeToFrom = len.dot(worldNormal);
	    to.vsub(position, len);
	    const planeToTo = len.dot(worldNormal);

	    if (planeToFrom * planeToTo > 0) {
	      // "from" and "to" are on the same side of the plane... bail out
	      return;
	    }

	    if (from.distanceTo(to) < planeToFrom) {
	      return;
	    }

	    const n_dot_dir = worldNormal.dot(direction);

	    if (Math.abs(n_dot_dir) < this.precision) {
	      // No intersection
	      return;
	    }

	    const planePointToFrom = new Vec3();
	    const dir_scaled_with_t = new Vec3();
	    const hitPointWorld = new Vec3();
	    from.vsub(position, planePointToFrom);
	    const t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
	    direction.scale(t, dir_scaled_with_t);
	    from.vadd(dir_scaled_with_t, hitPointWorld);
	    this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
	  }
	  /**
	   * Get the world AABB of the ray.
	   */


	  getAABB(aabb) {
	    const {
	      lowerBound,
	      upperBound
	    } = aabb;
	    const to = this.to;
	    const from = this.from;
	    lowerBound.x = Math.min(to.x, from.x);
	    lowerBound.y = Math.min(to.y, from.y);
	    lowerBound.z = Math.min(to.z, from.z);
	    upperBound.x = Math.max(to.x, from.x);
	    upperBound.y = Math.max(to.y, from.y);
	    upperBound.z = Math.max(to.z, from.z);
	  }

	  _intersectHeightfield(shape, quat, position, body, reportedShape) {
	    shape.data;
	    shape.elementSize; // Convert the ray to local heightfield coordinates

	    const localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);

	    localRay.from.copy(this.from);
	    localRay.to.copy(this.to);
	    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
	    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
	    localRay.updateDirection(); // Get the index of the data points to test against

	    const index = intersectHeightfield_index;
	    let iMinX;
	    let iMinY;
	    let iMaxX;
	    let iMaxY; // Set to max

	    iMinX = iMinY = 0;
	    iMaxX = iMaxY = shape.data.length - 1;
	    const aabb = new AABB();
	    localRay.getAABB(aabb);
	    shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
	    iMinX = Math.max(iMinX, index[0]);
	    iMinY = Math.max(iMinY, index[1]);
	    shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
	    iMaxX = Math.min(iMaxX, index[0] + 1);
	    iMaxY = Math.min(iMaxY, index[1] + 1);

	    for (let i = iMinX; i < iMaxX; i++) {
	      for (let j = iMinY; j < iMaxY; j++) {
	        if (this.result.shouldStop) {
	          return;
	        }

	        shape.getAabbAtIndex(i, j, aabb);

	        if (!aabb.overlapsRay(localRay)) {
	          continue;
	        } // Lower triangle


	        shape.getConvexTrianglePillar(i, j, false);
	        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);

	        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);

	        if (this.result.shouldStop) {
	          return;
	        } // Upper triangle


	        shape.getConvexTrianglePillar(i, j, true);
	        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);

	        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
	      }
	    }
	  }

	  _intersectSphere(sphere, quat, position, body, reportedShape) {
	    const from = this.from;
	    const to = this.to;
	    const r = sphere.radius;
	    const a = (to.x - from.x) ** 2 + (to.y - from.y) ** 2 + (to.z - from.z) ** 2;
	    const b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
	    const c = (from.x - position.x) ** 2 + (from.y - position.y) ** 2 + (from.z - position.z) ** 2 - r ** 2;
	    const delta = b ** 2 - 4 * a * c;
	    const intersectionPoint = Ray_intersectSphere_intersectionPoint;
	    const normal = Ray_intersectSphere_normal;

	    if (delta < 0) {
	      // No intersection
	      return;
	    } else if (delta === 0) {
	      // single intersection point
	      from.lerp(to, delta, intersectionPoint);
	      intersectionPoint.vsub(position, normal);
	      normal.normalize();
	      this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
	    } else {
	      const d1 = (-b - Math.sqrt(delta)) / (2 * a);
	      const d2 = (-b + Math.sqrt(delta)) / (2 * a);

	      if (d1 >= 0 && d1 <= 1) {
	        from.lerp(to, d1, intersectionPoint);
	        intersectionPoint.vsub(position, normal);
	        normal.normalize();
	        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
	      }

	      if (this.result.shouldStop) {
	        return;
	      }

	      if (d2 >= 0 && d2 <= 1) {
	        from.lerp(to, d2, intersectionPoint);
	        intersectionPoint.vsub(position, normal);
	        normal.normalize();
	        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
	      }
	    }
	  }

	  _intersectConvex(shape, quat, position, body, reportedShape, options) {
	    const normal = intersectConvex_normal;
	    const vector = intersectConvex_vector;
	    const faceList = options && options.faceList || null; // Checking faces

	    const faces = shape.faces;
	    const vertices = shape.vertices;
	    const normals = shape.faceNormals;
	    const direction = this.direction;
	    const from = this.from;
	    const to = this.to;
	    const fromToDistance = from.distanceTo(to);
	    const Nfaces = faceList ? faceList.length : faces.length;
	    const result = this.result;

	    for (let j = 0; !result.shouldStop && j < Nfaces; j++) {
	      const fi = faceList ? faceList[j] : j;
	      const face = faces[fi];
	      const faceNormal = normals[fi];
	      const q = quat;
	      const x = position; // determine if ray intersects the plane of the face
	      // note: this works regardless of the direction of the face normal
	      // Get plane point in world coordinates...

	      vector.copy(vertices[face[0]]);
	      q.vmult(vector, vector);
	      vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.

	      vector.vsub(from, vector); // Get plane normal

	      q.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting

	      const dot = direction.dot(normal); // Bail out if ray and plane are parallel

	      if (Math.abs(dot) < this.precision) {
	        continue;
	      } // calc distance to plane


	      const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

	      if (scalar < 0) {
	        continue;
	      } // if (dot < 0) {
	      // Intersection point is from + direction * scalar


	      direction.scale(scalar, intersectPoint);
	      intersectPoint.vadd(from, intersectPoint); // a is the point we compare points b and c with.

	      a.copy(vertices[face[0]]);
	      q.vmult(a, a);
	      x.vadd(a, a);

	      for (let i = 1; !result.shouldStop && i < face.length - 1; i++) {
	        // Transform 3 vertices to world coords
	        b.copy(vertices[face[i]]);
	        c.copy(vertices[face[i + 1]]);
	        q.vmult(b, b);
	        q.vmult(c, c);
	        x.vadd(b, b);
	        x.vadd(c, c);
	        const distance = intersectPoint.distanceTo(from);

	        if (!(Ray.pointInTriangle(intersectPoint, a, b, c) || Ray.pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {
	          continue;
	        }

	        this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
	      } // }

	    }
	  }
	  /**
	   * @todo Optimize by transforming the world to local space first.
	   * @todo Use Octree lookup
	   */


	  _intersectTrimesh(mesh, quat, position, body, reportedShape, options) {
	    const normal = intersectTrimesh_normal;
	    const triangles = intersectTrimesh_triangles;
	    const treeTransform = intersectTrimesh_treeTransform;
	    const vector = intersectConvex_vector;
	    const localDirection = intersectTrimesh_localDirection;
	    const localFrom = intersectTrimesh_localFrom;
	    const localTo = intersectTrimesh_localTo;
	    const worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
	    const worldNormal = intersectTrimesh_worldNormal; // Checking faces

	    const indices = mesh.indices;
	    mesh.vertices; // const normals = mesh.faceNormals

	    const from = this.from;
	    const to = this.to;
	    const direction = this.direction;
	    treeTransform.position.copy(position);
	    treeTransform.quaternion.copy(quat); // Transform ray to local space!

	    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
	    Transform.pointToLocalFrame(position, quat, from, localFrom);
	    Transform.pointToLocalFrame(position, quat, to, localTo);
	    localTo.x *= mesh.scale.x;
	    localTo.y *= mesh.scale.y;
	    localTo.z *= mesh.scale.z;
	    localFrom.x *= mesh.scale.x;
	    localFrom.y *= mesh.scale.y;
	    localFrom.z *= mesh.scale.z;
	    localTo.vsub(localFrom, localDirection);
	    localDirection.normalize();
	    const fromToDistanceSquared = localFrom.distanceSquared(localTo);
	    mesh.tree.rayQuery(this, treeTransform, triangles);

	    for (let i = 0, N = triangles.length; !this.result.shouldStop && i !== N; i++) {
	      const trianglesIndex = triangles[i];
	      mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face
	      // note: this works regardless of the direction of the face normal
	      // Get plane point in world coordinates...

	      mesh.getVertex(indices[trianglesIndex * 3], a); // ...but make it relative to the ray from. We'll fix this later.

	      a.vsub(localFrom, vector); // If this dot product is negative, we have something interesting

	      const dot = localDirection.dot(normal); // Bail out if ray and plane are parallel
	      // if (Math.abs( dot ) < this.precision){
	      //     continue;
	      // }
	      // calc distance to plane

	      const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

	      if (scalar < 0) {
	        continue;
	      } // Intersection point is from + direction * scalar


	      localDirection.scale(scalar, intersectPoint);
	      intersectPoint.vadd(localFrom, intersectPoint); // Get triangle vertices

	      mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
	      mesh.getVertex(indices[trianglesIndex * 3 + 2], c);
	      const squaredDistance = intersectPoint.distanceSquared(localFrom);

	      if (!(Ray.pointInTriangle(intersectPoint, b, a, c) || Ray.pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {
	        continue;
	      } // transform intersectpoint and normal to world


	      Transform.vectorToWorldFrame(quat, normal, worldNormal);
	      Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
	      this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
	    }

	    triangles.length = 0;
	  }
	  /**
	   * @return True if the intersections should continue
	   */


	  reportIntersection(normal, hitPointWorld, shape, body, hitFaceIndex) {
	    const from = this.from;
	    const to = this.to;
	    const distance = from.distanceTo(hitPointWorld);
	    const result = this.result; // Skip back faces?

	    if (this.skipBackfaces && normal.dot(this.direction) > 0) {
	      return;
	    }

	    result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;

	    switch (this.mode) {
	      case Ray.ALL:
	        this.hasHit = true;
	        result.set(from, to, normal, hitPointWorld, shape, body, distance);
	        result.hasHit = true;
	        this.callback(result);
	        break;

	      case Ray.CLOSEST:
	        // Store if closer than current closest
	        if (distance < result.distance || !result.hasHit) {
	          this.hasHit = true;
	          result.hasHit = true;
	          result.set(from, to, normal, hitPointWorld, shape, body, distance);
	        }

	        break;

	      case Ray.ANY:
	        // Report and stop.
	        this.hasHit = true;
	        result.hasHit = true;
	        result.set(from, to, normal, hitPointWorld, shape, body, distance);
	        result.shouldStop = true;
	        break;
	    }
	  }
	  /**
	   * As per "Barycentric Technique" as named
	   * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
	   */


	  static pointInTriangle(p, a, b, c) {
	    c.vsub(a, v0);
	    b.vsub(a, v1);
	    p.vsub(a, v2);
	    const dot00 = v0.dot(v0);
	    const dot01 = v0.dot(v1);
	    const dot02 = v0.dot(v2);
	    const dot11 = v1.dot(v1);
	    const dot12 = v1.dot(v2);
	    let u;
	    let v;
	    return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;
	  }

	}
	Ray.CLOSEST = RAY_MODES.CLOSEST;
	Ray.ANY = RAY_MODES.ANY;
	Ray.ALL = RAY_MODES.ALL;
	const tmpAABB$1 = new AABB();
	const tmpArray = [];
	const v1 = new Vec3();
	const v2 = new Vec3();
	const intersectBody_xi = new Vec3();
	const intersectBody_qi = new Quaternion();
	const intersectPoint = new Vec3();
	const a = new Vec3();
	const b = new Vec3();
	const c = new Vec3();
	new Vec3();
	new RaycastResult();
	const intersectConvexOptions = {
	  faceList: [0]
	};
	const worldPillarOffset = new Vec3();
	const intersectHeightfield_localRay = new Ray();
	const intersectHeightfield_index = [];
	const Ray_intersectSphere_intersectionPoint = new Vec3();
	const Ray_intersectSphere_normal = new Vec3();
	const intersectConvex_normal = new Vec3();
	new Vec3();
	new Vec3();
	const intersectConvex_vector = new Vec3();
	const intersectTrimesh_normal = new Vec3();
	const intersectTrimesh_localDirection = new Vec3();
	const intersectTrimesh_localFrom = new Vec3();
	const intersectTrimesh_localTo = new Vec3();
	const intersectTrimesh_worldNormal = new Vec3();
	const intersectTrimesh_worldIntersectPoint = new Vec3();
	new AABB();
	const intersectTrimesh_triangles = [];
	const intersectTrimesh_treeTransform = new Transform();
	const v0 = new Vec3();
	const intersect = new Vec3();

	function distanceFromIntersection(from, direction, position) {
	  // v0 is vector from from to position
	  position.vsub(from, v0);
	  const dot = v0.dot(direction); // intersect = direction*dot + from

	  direction.scale(dot, intersect);
	  intersect.vadd(from, intersect);
	  const distance = position.distanceTo(intersect);
	  return distance;
	}

	class Utils {
	  /**
	   * Extend an options object with default values.
	   * @param options The options object. May be falsy: in this case, a new object is created and returned.
	   * @param defaults An object containing default values.
	   * @return The modified options object.
	   */
	  static defaults(options, defaults) {
	    if (options === void 0) {
	      options = {};
	    }

	    for (let key in defaults) {
	      if (!(key in options)) {
	        options[key] = defaults[key];
	      }
	    }

	    return options;
	  }

	}

	/**
	 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
	 */

	class JacobianElement {
	  /**
	   * spatial
	   */

	  /**
	   * rotational
	   */
	  constructor() {
	    this.spatial = new Vec3();
	    this.rotational = new Vec3();
	  }
	  /**
	   * Multiply with other JacobianElement
	   */


	  multiplyElement(element) {
	    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
	  }
	  /**
	   * Multiply with two vectors
	   */


	  multiplyVectors(spatial, rotational) {
	    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
	  }

	}

	/**
	 * Equation base class.
	 *
	 * `a`, `b` and `eps` are {@link https://www8.cs.umu.se/kurser/5DV058/VT15/lectures/SPOOKlabnotes.pdf SPOOK} parameters that default to `0.0`. See {@link https://github.com/schteppe/cannon.js/issues/238#issuecomment-147172327 this exchange} for more details on Cannon's physics implementation.
	 */
	class Equation {
	  /**
	   * Minimum (read: negative max) force to be applied by the constraint.
	   */

	  /**
	   * Maximum (read: positive max) force to be applied by the constraint.
	   */

	  /**
	   * SPOOK parameter
	   */

	  /**
	   * SPOOK parameter
	   */

	  /**
	   * SPOOK parameter
	   */

	  /**
	   * A number, proportional to the force added to the bodies.
	   */
	  constructor(bi, bj, minForce, maxForce) {
	    if (minForce === void 0) {
	      minForce = -1e6;
	    }

	    if (maxForce === void 0) {
	      maxForce = 1e6;
	    }

	    this.id = Equation.idCounter++;
	    this.minForce = minForce;
	    this.maxForce = maxForce;
	    this.bi = bi;
	    this.bj = bj;
	    this.a = 0.0; // SPOOK parameter

	    this.b = 0.0; // SPOOK parameter

	    this.eps = 0.0; // SPOOK parameter

	    this.jacobianElementA = new JacobianElement();
	    this.jacobianElementB = new JacobianElement();
	    this.enabled = true;
	    this.multiplier = 0;
	    this.setSpookParams(1e7, 4, 1 / 60); // Set typical spook params
	  }
	  /**
	   * Recalculates a, b, and eps.
	   *
	   * The Equation constructor sets typical SPOOK parameters as such:
	   * * `stiffness` = 1e7
	   * * `relaxation` = 4
	   * * `timeStep`= 1 / 60, _note the hardcoded refresh rate._
	   */


	  setSpookParams(stiffness, relaxation, timeStep) {
	    const d = relaxation;
	    const k = stiffness;
	    const h = timeStep;
	    this.a = 4.0 / (h * (1 + 4 * d));
	    this.b = 4.0 * d / (1 + 4 * d);
	    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
	  }
	  /**
	   * Computes the right hand side of the SPOOK equation
	   */


	  computeB(a, b, h) {
	    const GW = this.computeGW();
	    const Gq = this.computeGq();
	    const GiMf = this.computeGiMf();
	    return -Gq * a - GW * b - GiMf * h;
	  }
	  /**
	   * Computes G*q, where q are the generalized body coordinates
	   */


	  computeGq() {
	    const GA = this.jacobianElementA;
	    const GB = this.jacobianElementB;
	    const bi = this.bi;
	    const bj = this.bj;
	    const xi = bi.position;
	    const xj = bj.position;
	    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
	  }
	  /**
	   * Computes G*W, where W are the body velocities
	   */


	  computeGW() {
	    const GA = this.jacobianElementA;
	    const GB = this.jacobianElementB;
	    const bi = this.bi;
	    const bj = this.bj;
	    const vi = bi.velocity;
	    const vj = bj.velocity;
	    const wi = bi.angularVelocity;
	    const wj = bj.angularVelocity;
	    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
	  }
	  /**
	   * Computes G*Wlambda, where W are the body velocities
	   */


	  computeGWlambda() {
	    const GA = this.jacobianElementA;
	    const GB = this.jacobianElementB;
	    const bi = this.bi;
	    const bj = this.bj;
	    const vi = bi.vlambda;
	    const vj = bj.vlambda;
	    const wi = bi.wlambda;
	    const wj = bj.wlambda;
	    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
	  }
	  /**
	   * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
	   */


	  computeGiMf() {
	    const GA = this.jacobianElementA;
	    const GB = this.jacobianElementB;
	    const bi = this.bi;
	    const bj = this.bj;
	    const fi = bi.force;
	    const ti = bi.torque;
	    const fj = bj.force;
	    const tj = bj.torque;
	    const invMassi = bi.invMassSolve;
	    const invMassj = bj.invMassSolve;
	    fi.scale(invMassi, iMfi);
	    fj.scale(invMassj, iMfj);
	    bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
	    bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
	    return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
	  }
	  /**
	   * Computes G*inv(M)*G'
	   */


	  computeGiMGt() {
	    const GA = this.jacobianElementA;
	    const GB = this.jacobianElementB;
	    const bi = this.bi;
	    const bj = this.bj;
	    const invMassi = bi.invMassSolve;
	    const invMassj = bj.invMassSolve;
	    const invIi = bi.invInertiaWorldSolve;
	    const invIj = bj.invInertiaWorldSolve;
	    let result = invMassi + invMassj;
	    invIi.vmult(GA.rotational, tmp);
	    result += tmp.dot(GA.rotational);
	    invIj.vmult(GB.rotational, tmp);
	    result += tmp.dot(GB.rotational);
	    return result;
	  }
	  /**
	   * Add constraint velocity to the bodies.
	   */


	  addToWlambda(deltalambda) {
	    const GA = this.jacobianElementA;
	    const GB = this.jacobianElementB;
	    const bi = this.bi;
	    const bj = this.bj;
	    const temp = addToWlambda_temp; // Add to linear velocity
	    // v_lambda += inv(M) * delta_lamba * G

	    bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
	    bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda); // Add to angular velocity

	    bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
	    bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
	    bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
	    bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
	  }
	  /**
	   * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
	   */


	  computeC() {
	    return this.computeGiMGt() + this.eps;
	  }

	}
	Equation.idCounter = 0;
	const iMfi = new Vec3();
	const iMfj = new Vec3();
	const invIi_vmult_taui = new Vec3();
	const invIj_vmult_tauj = new Vec3();
	const tmp = new Vec3();
	const addToWlambda_temp = new Vec3();

	/**
	 * Contact/non-penetration constraint equation
	 */
	class ContactEquation extends Equation {
	  /**
	   * "bounciness": u1 = -e*u0
	   */

	  /**
	   * World-oriented vector that goes from the center of bi to the contact point.
	   */

	  /**
	   * World-oriented vector that starts in body j position and goes to the contact point.
	   */

	  /**
	   * Contact normal, pointing out of body i.
	   */
	  constructor(bodyA, bodyB, maxForce) {
	    if (maxForce === void 0) {
	      maxForce = 1e6;
	    }

	    super(bodyA, bodyB, 0, maxForce);
	    this.restitution = 0.0;
	    this.ri = new Vec3();
	    this.rj = new Vec3();
	    this.ni = new Vec3();
	  }

	  computeB(h) {
	    const a = this.a;
	    const b = this.b;
	    const bi = this.bi;
	    const bj = this.bj;
	    const ri = this.ri;
	    const rj = this.rj;
	    const rixn = ContactEquation_computeB_temp1;
	    const rjxn = ContactEquation_computeB_temp2;
	    const vi = bi.velocity;
	    const wi = bi.angularVelocity;
	    bi.force;
	    bi.torque;
	    const vj = bj.velocity;
	    const wj = bj.angularVelocity;
	    bj.force;
	    bj.torque;
	    const penetrationVec = ContactEquation_computeB_temp3;
	    const GA = this.jacobianElementA;
	    const GB = this.jacobianElementB;
	    const n = this.ni; // Caluclate cross products

	    ri.cross(n, rixn);
	    rj.cross(n, rjxn); // g = xj+rj -(xi+ri)
	    // G = [ -ni  -rixn  ni  rjxn ]

	    n.negate(GA.spatial);
	    rixn.negate(GA.rotational);
	    GB.spatial.copy(n);
	    GB.rotational.copy(rjxn); // Calculate the penetration vector

	    penetrationVec.copy(bj.position);
	    penetrationVec.vadd(rj, penetrationVec);
	    penetrationVec.vsub(bi.position, penetrationVec);
	    penetrationVec.vsub(ri, penetrationVec);
	    const g = n.dot(penetrationVec); // Compute iteration

	    const ePlusOne = this.restitution + 1;
	    const GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
	    const GiMf = this.computeGiMf();
	    const B = -g * a - GW * b - h * GiMf;
	    return B;
	  }
	  /**
	   * Get the current relative velocity in the contact point.
	   */


	  getImpactVelocityAlongNormal() {
	    const vi = ContactEquation_getImpactVelocityAlongNormal_vi;
	    const vj = ContactEquation_getImpactVelocityAlongNormal_vj;
	    const xi = ContactEquation_getImpactVelocityAlongNormal_xi;
	    const xj = ContactEquation_getImpactVelocityAlongNormal_xj;
	    const relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
	    this.bi.position.vadd(this.ri, xi);
	    this.bj.position.vadd(this.rj, xj);
	    this.bi.getVelocityAtWorldPoint(xi, vi);
	    this.bj.getVelocityAtWorldPoint(xj, vj);
	    vi.vsub(vj, relVel);
	    return this.ni.dot(relVel);
	  }

	}
	const ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors

	const ContactEquation_computeB_temp2 = new Vec3();
	const ContactEquation_computeB_temp3 = new Vec3();
	const ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
	const ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
	const ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
	const ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
	const ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();

	/**
	 * Constrains the slipping in a contact along a tangent
	 */
	class FrictionEquation extends Equation {
	  // Tangent

	  /**
	   * @param slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
	   */
	  constructor(bodyA, bodyB, slipForce) {
	    super(bodyA, bodyB, -slipForce, slipForce);
	    this.ri = new Vec3();
	    this.rj = new Vec3();
	    this.t = new Vec3();
	  }

	  computeB(h) {
	    this.a;
	    const b = this.b;
	    this.bi;
	    this.bj;
	    const ri = this.ri;
	    const rj = this.rj;
	    const rixt = FrictionEquation_computeB_temp1;
	    const rjxt = FrictionEquation_computeB_temp2;
	    const t = this.t; // Caluclate cross products

	    ri.cross(t, rixt);
	    rj.cross(t, rjxt); // G = [-t -rixt t rjxt]
	    // And remember, this is a pure velocity constraint, g is always zero!

	    const GA = this.jacobianElementA;
	    const GB = this.jacobianElementB;
	    t.negate(GA.spatial);
	    rixt.negate(GA.rotational);
	    GB.spatial.copy(t);
	    GB.rotational.copy(rjxt);
	    const GW = this.computeGW();
	    const GiMf = this.computeGiMf();
	    const B = -GW * b - h * GiMf;
	    return B;
	  }

	}
	const FrictionEquation_computeB_temp1 = new Vec3();
	const FrictionEquation_computeB_temp2 = new Vec3();

	/**
	 * Defines what happens when two materials meet.
	 * @todo Refactor materials to materialA and materialB
	 */
	class ContactMaterial {
	  /**
	   * Identifier of this material.
	   */

	  /**
	   * Participating materials.
	   */

	  /**
	   * Friction coefficient.
	   * @default 0.3
	   */

	  /**
	   * Restitution coefficient.
	   * @default 0.3
	   */

	  /**
	   * Stiffness of the produced contact equations.
	   * @default 1e7
	   */

	  /**
	   * Relaxation time of the produced contact equations.
	   * @default 3
	   */

	  /**
	   * Stiffness of the produced friction equations.
	   * @default 1e7
	   */

	  /**
	   * Relaxation time of the produced friction equations
	   * @default 3
	   */
	  constructor(m1, m2, options) {
	    options = Utils.defaults(options, {
	      friction: 0.3,
	      restitution: 0.3,
	      contactEquationStiffness: 1e7,
	      contactEquationRelaxation: 3,
	      frictionEquationStiffness: 1e7,
	      frictionEquationRelaxation: 3
	    });
	    this.id = ContactMaterial.idCounter++;
	    this.materials = [m1, m2];
	    this.friction = options.friction;
	    this.restitution = options.restitution;
	    this.contactEquationStiffness = options.contactEquationStiffness;
	    this.contactEquationRelaxation = options.contactEquationRelaxation;
	    this.frictionEquationStiffness = options.frictionEquationStiffness;
	    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
	  }

	}
	ContactMaterial.idCounter = 0;

	/**
	 * Defines a physics material.
	 */
	class Material {
	  /**
	   * Material name.
	   * If options is a string, name will be set to that string.
	   * @todo Deprecate this
	   */

	  /** Material id. */

	  /**
	   * Friction for this material.
	   * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
	   */

	  /**
	   * Restitution for this material.
	   * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
	   */
	  constructor(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    let name = ''; // Backwards compatibility fix

	    if (typeof options === 'string') {
	      //console.warn(`Passing a string to MaterialOptions is deprecated, and has no effect`)
	      name = options;
	      options = {};
	    }

	    this.name = name;
	    this.id = Material.idCounter++;
	    this.friction = typeof options.friction !== 'undefined' ? options.friction : -1;
	    this.restitution = typeof options.restitution !== 'undefined' ? options.restitution : -1;
	  }

	}
	Material.idCounter = 0;
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Ray();
	new Vec3();
	new Vec3();
	new Vec3();
	[new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1)];
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();

	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();

	new Vec3();
	new Vec3();
	new Vec3(); // bilateral constraint between two dynamic objects

	/**
	 * Spherical shape
	 * @example
	 *     const radius = 1
	 *     const sphereShape = new CANNON.Sphere(radius)
	 *     const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape })
	 *     world.addBody(sphereBody)
	 */
	class PhysSphere extends Shape {
	  /**
	   * The radius of the sphere.
	   */

	  /**
	   *
	   * @param radius The radius of the sphere, a non-negative number.
	   */
	  constructor(radius) {
	    super({
	      type: Shape.types.SPHERE
	    });
	    this.radius = radius !== undefined ? radius : 1.0;

	    if (this.radius < 0) {
	      throw new Error('The sphere radius cannot be negative.');
	    }

	    this.updateBoundingSphereRadius();
	  }
	  /** calculateLocalInertia */


	  calculateLocalInertia(mass, target) {
	    if (target === void 0) {
	      target = new Vec3();
	    }

	    const I = 2.0 * mass * this.radius * this.radius / 5.0;
	    target.x = I;
	    target.y = I;
	    target.z = I;
	    return target;
	  }
	  /** volume */


	  volume() {
	    return 4.0 * Math.PI * Math.pow(this.radius, 3) / 3.0;
	  }

	  updateBoundingSphereRadius() {
	    this.boundingSphereRadius = this.radius;
	  }

	  calculateWorldAABB(pos, quat, min, max) {
	    const r = this.radius;
	    const axes = ['x', 'y', 'z'];

	    for (let i = 0; i < axes.length; i++) {
	      const ax = axes[i];
	      min[ax] = pos[ax] - r;
	      max[ax] = pos[ax] + r;
	    }
	  }

	}
	new Vec3();
	new Vec3();
	new Vec3(); // Temp vectors for calculation

	new Vec3(); // Relative velocity

	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();

	/**
	 * Cylinder class.
	 * @example
	 *     const radiusTop = 0.5
	 *     const radiusBottom = 0.5
	 *     const height = 2
	 *     const numSegments = 12
	 *     const cylinderShape = new CANNON.Cylinder(radiusTop, radiusBottom, height, numSegments)
	 *     const cylinderBody = new CANNON.Body({ mass: 1, shape: cylinderShape })
	 *     world.addBody(cylinderBody)
	 */

	class PhysCylinder extends ConvexPolyhedron {
	  /** The radius of the top of the Cylinder. */

	  /** The radius of the bottom of the Cylinder. */

	  /** The height of the Cylinder. */

	  /** The number of segments to build the cylinder out of. */

	  /**
	   * @param radiusTop The radius of the top of the Cylinder.
	   * @param radiusBottom The radius of the bottom of the Cylinder.
	   * @param height The height of the Cylinder.
	   * @param numSegments The number of segments to build the cylinder out of.
	   */
	  constructor(radiusTop, radiusBottom, height, numSegments) {
	    if (radiusTop === void 0) {
	      radiusTop = 1;
	    }

	    if (radiusBottom === void 0) {
	      radiusBottom = 1;
	    }

	    if (height === void 0) {
	      height = 1;
	    }

	    if (numSegments === void 0) {
	      numSegments = 8;
	    }

	    if (radiusTop < 0) {
	      throw new Error('The cylinder radiusTop cannot be negative.');
	    }

	    if (radiusBottom < 0) {
	      throw new Error('The cylinder radiusBottom cannot be negative.');
	    }

	    const N = numSegments;
	    const vertices = [];
	    const axes = [];
	    const faces = [];
	    const bottomface = [];
	    const topface = [];
	    const cos = Math.cos;
	    const sin = Math.sin; // First bottom point

	    vertices.push(new Vec3(-radiusBottom * sin(0), -height * 0.5, radiusBottom * cos(0)));
	    bottomface.push(0); // First top point

	    vertices.push(new Vec3(-radiusTop * sin(0), height * 0.5, radiusTop * cos(0)));
	    topface.push(1);

	    for (let i = 0; i < N; i++) {
	      const theta = 2 * Math.PI / N * (i + 1);
	      const thetaN = 2 * Math.PI / N * (i + 0.5);

	      if (i < N - 1) {
	        // Bottom
	        vertices.push(new Vec3(-radiusBottom * sin(theta), -height * 0.5, radiusBottom * cos(theta)));
	        bottomface.push(2 * i + 2); // Top

	        vertices.push(new Vec3(-radiusTop * sin(theta), height * 0.5, radiusTop * cos(theta)));
	        topface.push(2 * i + 3); // Face

	        faces.push([2 * i, 2 * i + 1, 2 * i + 3, 2 * i + 2]);
	      } else {
	        faces.push([2 * i, 2 * i + 1, 1, 0]); // Connect
	      } // Axis: we can cut off half of them if we have even number of segments


	      if (N % 2 === 1 || i < N / 2) {
	        axes.push(new Vec3(-sin(thetaN), 0, cos(thetaN)));
	      }
	    }

	    faces.push(bottomface);
	    axes.push(new Vec3(0, 1, 0)); // Reorder top face

	    const temp = [];

	    for (let i = 0; i < topface.length; i++) {
	      temp.push(topface[topface.length - i - 1]);
	    }

	    faces.push(temp);
	    super({
	      vertices,
	      faces,
	      axes
	    });
	    this.type = Shape.types.CYLINDER;
	    this.radiusTop = radiusTop;
	    this.radiusBottom = radiusBottom;
	    this.height = height;
	    this.numSegments = numSegments;
	  }

	}
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3(); // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system
	new Vec3();
	new AABB();
	new Vec3();
	new AABB();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new Vec3();
	new AABB();
	new Vec3();
	new Transform();
	new AABB();

	/**
	 * Constraint equation solver base class.
	 */
	class Solver {
	  /**
	   * All equations to be solved
	   */

	  /**
	   * @todo remove useless constructor
	   */
	  constructor() {
	    this.equations = [];
	  }
	  /**
	   * Should be implemented in subclasses!
	   * @todo use abstract
	   * @return number of iterations performed
	   */


	  solve(dt, world) {
	    return (// Should return the number of iterations done!
	      0
	    );
	  }
	  /**
	   * Add an equation
	   */


	  addEquation(eq) {
	    if (eq.enabled && !eq.bi.isTrigger && !eq.bj.isTrigger) {
	      this.equations.push(eq);
	    }
	  }
	  /**
	   * Remove an equation
	   */


	  removeEquation(eq) {
	    const eqs = this.equations;
	    const i = eqs.indexOf(eq);

	    if (i !== -1) {
	      eqs.splice(i, 1);
	    }
	  }
	  /**
	   * Add all equations
	   */


	  removeAllEquations() {
	    this.equations.length = 0;
	  }

	}

	/**
	 * Constraint equation Gauss-Seidel solver.
	 * @todo The spook parameters should be specified for each constraint, not globally.
	 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
	 */
	class GSSolver extends Solver {
	  /**
	   * The number of solver iterations determines quality of the constraints in the world.
	   * The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
	   */

	  /**
	   * When tolerance is reached, the system is assumed to be converged.
	   */

	  /**
	   * @todo remove useless constructor
	   */
	  constructor() {
	    super();
	    this.iterations = 10;
	    this.tolerance = 1e-7;
	  }
	  /**
	   * Solve
	   * @return number of iterations performed
	   */


	  solve(dt, world) {
	    let iter = 0;
	    const maxIter = this.iterations;
	    const tolSquared = this.tolerance * this.tolerance;
	    const equations = this.equations;
	    const Neq = equations.length;
	    const bodies = world.bodies;
	    const Nbodies = bodies.length;
	    const h = dt;
	    let B;
	    let invC;
	    let deltalambda;
	    let deltalambdaTot;
	    let GWlambda;
	    let lambdaj; // Update solve mass

	    if (Neq !== 0) {
	      for (let i = 0; i !== Nbodies; i++) {
	        bodies[i].updateSolveMassProperties();
	      }
	    } // Things that do not change during iteration can be computed once


	    const invCs = GSSolver_solve_invCs;
	    const Bs = GSSolver_solve_Bs;
	    const lambda = GSSolver_solve_lambda;
	    invCs.length = Neq;
	    Bs.length = Neq;
	    lambda.length = Neq;

	    for (let i = 0; i !== Neq; i++) {
	      const c = equations[i];
	      lambda[i] = 0.0;
	      Bs[i] = c.computeB(h);
	      invCs[i] = 1.0 / c.computeC();
	    }

	    if (Neq !== 0) {
	      // Reset vlambda
	      for (let i = 0; i !== Nbodies; i++) {
	        const b = bodies[i];
	        const vlambda = b.vlambda;
	        const wlambda = b.wlambda;
	        vlambda.set(0, 0, 0);
	        wlambda.set(0, 0, 0);
	      } // Iterate over equations


	      for (iter = 0; iter !== maxIter; iter++) {
	        // Accumulate the total error for each iteration.
	        deltalambdaTot = 0.0;

	        for (let j = 0; j !== Neq; j++) {
	          const c = equations[j]; // Compute iteration

	          B = Bs[j];
	          invC = invCs[j];
	          lambdaj = lambda[j];
	          GWlambda = c.computeGWlambda();
	          deltalambda = invC * (B - GWlambda - c.eps * lambdaj); // Clamp if we are not within the min/max interval

	          if (lambdaj + deltalambda < c.minForce) {
	            deltalambda = c.minForce - lambdaj;
	          } else if (lambdaj + deltalambda > c.maxForce) {
	            deltalambda = c.maxForce - lambdaj;
	          }

	          lambda[j] += deltalambda;
	          deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

	          c.addToWlambda(deltalambda);
	        } // If the total error is small enough - stop iterate


	        if (deltalambdaTot * deltalambdaTot < tolSquared) {
	          break;
	        }
	      } // Add result to velocity


	      for (let i = 0; i !== Nbodies; i++) {
	        const b = bodies[i];
	        const v = b.velocity;
	        const w = b.angularVelocity;
	        b.vlambda.vmul(b.linearFactor, b.vlambda);
	        v.vadd(b.vlambda, v);
	        b.wlambda.vmul(b.angularFactor, b.wlambda);
	        w.vadd(b.wlambda, w);
	      } // Set the `.multiplier` property of each equation


	      let l = equations.length;
	      const invDt = 1 / h;

	      while (l--) {
	        equations[l].multiplier = lambda[l] * invDt;
	      }
	    }

	    return iter;
	  }

	} // Just temporary number holders that we want to reuse each iteration.

	const GSSolver_solve_lambda = [];
	const GSSolver_solve_invCs = [];
	const GSSolver_solve_Bs = [];

	/**
	 * For pooling objects that can be reused.
	 */
	class Pool {
	  constructor() {
	    this.objects = [];
	    this.type = Object;
	  }

	  /**
	   * Release an object after use
	   */
	  release() {
	    const Nargs = arguments.length;

	    for (let i = 0; i !== Nargs; i++) {
	      this.objects.push(i < 0 || arguments.length <= i ? undefined : arguments[i]);
	    }

	    return this;
	  }
	  /**
	   * Get an object
	   */


	  get() {
	    if (this.objects.length === 0) {
	      return this.constructObject();
	    } else {
	      return this.objects.pop();
	    }
	  }
	  /**
	   * Construct an object. Should be implemented in each subclass.
	   */


	  constructObject() {
	    throw new Error('constructObject() not implemented in this Pool subclass yet!');
	  }
	  /**
	   * @return Self, for chaining
	   */


	  resize(size) {
	    const objects = this.objects;

	    while (objects.length > size) {
	      objects.pop();
	    }

	    while (objects.length < size) {
	      objects.push(this.constructObject());
	    }

	    return this;
	  }

	}

	/**
	 * Vec3Pool
	 */

	class Vec3Pool extends Pool {
	  constructor() {
	    super(...arguments);
	    this.type = Vec3;
	  }

	  /**
	   * Construct a vector
	   */
	  constructObject() {
	    return new Vec3();
	  }

	}

	// Naming rule: based of the order in SHAPE_TYPES,
	// the first part of the method is formed by the
	// shape type that comes before, in the second part
	// there is the shape type that comes after in the SHAPE_TYPES list
	const COLLISION_TYPES = {
	  sphereSphere: Shape.types.SPHERE,
	  spherePlane: Shape.types.SPHERE | Shape.types.PLANE,
	  boxBox: Shape.types.BOX | Shape.types.BOX,
	  sphereBox: Shape.types.SPHERE | Shape.types.BOX,
	  planeBox: Shape.types.PLANE | Shape.types.BOX,
	  convexConvex: Shape.types.CONVEXPOLYHEDRON,
	  sphereConvex: Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON,
	  planeConvex: Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON,
	  boxConvex: Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON,
	  sphereHeightfield: Shape.types.SPHERE | Shape.types.HEIGHTFIELD,
	  boxHeightfield: Shape.types.BOX | Shape.types.HEIGHTFIELD,
	  convexHeightfield: Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD,
	  sphereParticle: Shape.types.PARTICLE | Shape.types.SPHERE,
	  planeParticle: Shape.types.PLANE | Shape.types.PARTICLE,
	  boxParticle: Shape.types.BOX | Shape.types.PARTICLE,
	  convexParticle: Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON,
	  cylinderCylinder: Shape.types.CYLINDER,
	  sphereCylinder: Shape.types.SPHERE | Shape.types.CYLINDER,
	  planeCylinder: Shape.types.PLANE | Shape.types.CYLINDER,
	  boxCylinder: Shape.types.BOX | Shape.types.CYLINDER,
	  convexCylinder: Shape.types.CONVEXPOLYHEDRON | Shape.types.CYLINDER,
	  heightfieldCylinder: Shape.types.HEIGHTFIELD | Shape.types.CYLINDER,
	  particleCylinder: Shape.types.PARTICLE | Shape.types.CYLINDER,
	  sphereTrimesh: Shape.types.SPHERE | Shape.types.TRIMESH,
	  planeTrimesh: Shape.types.PLANE | Shape.types.TRIMESH
	};

	/**
	 * Helper class for the World. Generates ContactEquations.
	 * @todo Sphere-ConvexPolyhedron contacts
	 * @todo Contact reduction
	 * @todo should move methods to prototype
	 */
	class Narrowphase {
	  /**
	   * Internal storage of pooled contact points.
	   */

	  /**
	   * Pooled vectors.
	   */
	  get [COLLISION_TYPES.sphereSphere]() {
	    return this.sphereSphere;
	  }

	  get [COLLISION_TYPES.spherePlane]() {
	    return this.spherePlane;
	  }

	  get [COLLISION_TYPES.boxBox]() {
	    return this.boxBox;
	  }

	  get [COLLISION_TYPES.sphereBox]() {
	    return this.sphereBox;
	  }

	  get [COLLISION_TYPES.planeBox]() {
	    return this.planeBox;
	  }

	  get [COLLISION_TYPES.convexConvex]() {
	    return this.convexConvex;
	  }

	  get [COLLISION_TYPES.sphereConvex]() {
	    return this.sphereConvex;
	  }

	  get [COLLISION_TYPES.planeConvex]() {
	    return this.planeConvex;
	  }

	  get [COLLISION_TYPES.boxConvex]() {
	    return this.boxConvex;
	  }

	  get [COLLISION_TYPES.sphereHeightfield]() {
	    return this.sphereHeightfield;
	  }

	  get [COLLISION_TYPES.boxHeightfield]() {
	    return this.boxHeightfield;
	  }

	  get [COLLISION_TYPES.convexHeightfield]() {
	    return this.convexHeightfield;
	  }

	  get [COLLISION_TYPES.sphereParticle]() {
	    return this.sphereParticle;
	  }

	  get [COLLISION_TYPES.planeParticle]() {
	    return this.planeParticle;
	  }

	  get [COLLISION_TYPES.boxParticle]() {
	    return this.boxParticle;
	  }

	  get [COLLISION_TYPES.convexParticle]() {
	    return this.convexParticle;
	  }

	  get [COLLISION_TYPES.cylinderCylinder]() {
	    return this.convexConvex;
	  }

	  get [COLLISION_TYPES.sphereCylinder]() {
	    return this.sphereConvex;
	  }

	  get [COLLISION_TYPES.planeCylinder]() {
	    return this.planeConvex;
	  }

	  get [COLLISION_TYPES.boxCylinder]() {
	    return this.boxConvex;
	  }

	  get [COLLISION_TYPES.convexCylinder]() {
	    return this.convexConvex;
	  }

	  get [COLLISION_TYPES.heightfieldCylinder]() {
	    return this.heightfieldCylinder;
	  }

	  get [COLLISION_TYPES.particleCylinder]() {
	    return this.particleCylinder;
	  }

	  get [COLLISION_TYPES.sphereTrimesh]() {
	    return this.sphereTrimesh;
	  }

	  get [COLLISION_TYPES.planeTrimesh]() {
	    return this.planeTrimesh;
	  } // get [COLLISION_TYPES.convexTrimesh]() {
	  //   return this.convexTrimesh
	  // }


	  constructor(world) {
	    this.contactPointPool = [];
	    this.frictionEquationPool = [];
	    this.result = [];
	    this.frictionResult = [];
	    this.v3pool = new Vec3Pool();
	    this.world = world;
	    this.currentContactMaterial = world.defaultContactMaterial;
	    this.enableFrictionReduction = false;
	  }
	  /**
	   * Make a contact object, by using the internal pool or creating a new one.
	   */


	  createContactEquation(bi, bj, si, sj, overrideShapeA, overrideShapeB) {
	    let c;

	    if (this.contactPointPool.length) {
	      c = this.contactPointPool.pop();
	      c.bi = bi;
	      c.bj = bj;
	    } else {
	      c = new ContactEquation(bi, bj);
	    }

	    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
	    const cm = this.currentContactMaterial;
	    c.restitution = cm.restitution;
	    c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
	    const matA = si.material || bi.material;
	    const matB = sj.material || bj.material;

	    if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {
	      c.restitution = matA.restitution * matB.restitution;
	    }

	    c.si = overrideShapeA || si;
	    c.sj = overrideShapeB || sj;
	    return c;
	  }

	  createFrictionEquationsFromContact(contactEquation, outArray) {
	    const bodyA = contactEquation.bi;
	    const bodyB = contactEquation.bj;
	    const shapeA = contactEquation.si;
	    const shapeB = contactEquation.sj;
	    const world = this.world;
	    const cm = this.currentContactMaterial; // If friction or restitution were specified in the material, use them

	    let friction = cm.friction;
	    const matA = shapeA.material || bodyA.material;
	    const matB = shapeB.material || bodyB.material;

	    if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
	      friction = matA.friction * matB.friction;
	    }

	    if (friction > 0) {
	      // Create 2 tangent equations
	      // Users may provide a force different from global gravity to use when computing contact friction.
	      const mug = friction * (world.frictionGravity || world.gravity).length();
	      let reducedMass = bodyA.invMass + bodyB.invMass;

	      if (reducedMass > 0) {
	        reducedMass = 1 / reducedMass;
	      }

	      const pool = this.frictionEquationPool;
	      const c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
	      const c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
	      c1.bi = c2.bi = bodyA;
	      c1.bj = c2.bj = bodyB;
	      c1.minForce = c2.minForce = -mug * reducedMass;
	      c1.maxForce = c2.maxForce = mug * reducedMass; // Copy over the relative vectors

	      c1.ri.copy(contactEquation.ri);
	      c1.rj.copy(contactEquation.rj);
	      c2.ri.copy(contactEquation.ri);
	      c2.rj.copy(contactEquation.rj); // Construct tangents

	      contactEquation.ni.tangents(c1.t, c2.t); // Set spook params

	      c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
	      c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
	      c1.enabled = c2.enabled = contactEquation.enabled;
	      outArray.push(c1, c2);
	      return true;
	    }

	    return false;
	  }
	  /**
	   * Take the average N latest contact point on the plane.
	   */


	  createFrictionFromAverage(numContacts) {
	    // The last contactEquation
	    let c = this.result[this.result.length - 1]; // Create the result: two "average" friction equations

	    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
	      return;
	    }

	    const f1 = this.frictionResult[this.frictionResult.length - 2];
	    const f2 = this.frictionResult[this.frictionResult.length - 1];
	    averageNormal.setZero();
	    averageContactPointA.setZero();
	    averageContactPointB.setZero();
	    const bodyA = c.bi;
	    c.bj;

	    for (let i = 0; i !== numContacts; i++) {
	      c = this.result[this.result.length - 1 - i];

	      if (c.bi !== bodyA) {
	        averageNormal.vadd(c.ni, averageNormal);
	        averageContactPointA.vadd(c.ri, averageContactPointA);
	        averageContactPointB.vadd(c.rj, averageContactPointB);
	      } else {
	        averageNormal.vsub(c.ni, averageNormal);
	        averageContactPointA.vadd(c.rj, averageContactPointA);
	        averageContactPointB.vadd(c.ri, averageContactPointB);
	      }
	    }

	    const invNumContacts = 1 / numContacts;
	    averageContactPointA.scale(invNumContacts, f1.ri);
	    averageContactPointB.scale(invNumContacts, f1.rj);
	    f2.ri.copy(f1.ri); // Should be the same

	    f2.rj.copy(f1.rj);
	    averageNormal.normalize();
	    averageNormal.tangents(f1.t, f2.t); // return eq;
	  }
	  /**
	   * Generate all contacts between a list of body pairs
	   * @param p1 Array of body indices
	   * @param p2 Array of body indices
	   * @param result Array to store generated contacts
	   * @param oldcontacts Optional. Array of reusable contact objects
	   */


	  getContacts(p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
	    // Save old contact objects
	    this.contactPointPool = oldcontacts;
	    this.frictionEquationPool = frictionPool;
	    this.result = result;
	    this.frictionResult = frictionResult;
	    const qi = tmpQuat1;
	    const qj = tmpQuat2;
	    const xi = tmpVec1;
	    const xj = tmpVec2;

	    for (let k = 0, N = p1.length; k !== N; k++) {
	      // Get current collision bodies
	      const bi = p1[k];
	      const bj = p2[k]; // Get contact material

	      let bodyContactMaterial = null;

	      if (bi.material && bj.material) {
	        bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null;
	      }

	      const justTest = bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;

	      for (let i = 0; i < bi.shapes.length; i++) {
	        bi.quaternion.mult(bi.shapeOrientations[i], qi);
	        bi.quaternion.vmult(bi.shapeOffsets[i], xi);
	        xi.vadd(bi.position, xi);
	        const si = bi.shapes[i];

	        for (let j = 0; j < bj.shapes.length; j++) {
	          // Compute world transform of shapes
	          bj.quaternion.mult(bj.shapeOrientations[j], qj);
	          bj.quaternion.vmult(bj.shapeOffsets[j], xj);
	          xj.vadd(bj.position, xj);
	          const sj = bj.shapes[j];

	          if (!(si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup)) {
	            continue;
	          }

	          if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
	            continue;
	          } // Get collision material


	          let shapeContactMaterial = null;

	          if (si.material && sj.material) {
	            shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null;
	          }

	          this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial; // Get contacts

	          const resolverIndex = si.type | sj.type;
	          const resolver = this[resolverIndex];

	          if (resolver) {
	            let retval = false; // TO DO: investigate why sphereParticle and convexParticle
	            // resolvers expect si and sj shapes to be in reverse order
	            // (i.e. larger integer value type first instead of smaller first)

	            if (si.type < sj.type) {
	              retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
	            } else {
	              retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
	            }

	            if (retval && justTest) {
	              // Register overlap
	              world.shapeOverlapKeeper.set(si.id, sj.id);
	              world.bodyOverlapKeeper.set(bi.id, bj.id);
	            }
	          }
	        }
	      }
	    }
	  }

	  sphereSphere(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    if (justTest) {
	      return xi.distanceSquared(xj) < (si.radius + sj.radius) ** 2;
	    } // We will have only one contact in this case


	    const contactEq = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

	    xj.vsub(xi, contactEq.ni);
	    contactEq.ni.normalize(); // Contact point locations

	    contactEq.ri.copy(contactEq.ni);
	    contactEq.rj.copy(contactEq.ni);
	    contactEq.ri.scale(si.radius, contactEq.ri);
	    contactEq.rj.scale(-sj.radius, contactEq.rj);
	    contactEq.ri.vadd(xi, contactEq.ri);
	    contactEq.ri.vsub(bi.position, contactEq.ri);
	    contactEq.rj.vadd(xj, contactEq.rj);
	    contactEq.rj.vsub(bj.position, contactEq.rj);
	    this.result.push(contactEq);
	    this.createFrictionEquationsFromContact(contactEq, this.frictionResult);
	  }

	  spherePlane(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    // We will have one contact in this case
	    const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

	    r.ni.set(0, 0, 1);
	    qj.vmult(r.ni, r.ni);
	    r.ni.negate(r.ni); // body i is the sphere, flip normal

	    r.ni.normalize(); // Needed?
	    // Vector from sphere center to contact point

	    r.ni.scale(si.radius, r.ri); // Project down sphere on plane

	    xi.vsub(xj, point_on_plane_to_sphere);
	    r.ni.scale(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
	    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj); // The sphere position projected to plane

	    if (-point_on_plane_to_sphere.dot(r.ni) <= si.radius) {
	      if (justTest) {
	        return true;
	      } // Make it relative to the body


	      const ri = r.ri;
	      const rj = r.rj;
	      ri.vadd(xi, ri);
	      ri.vsub(bi.position, ri);
	      rj.vadd(xj, rj);
	      rj.vsub(bj.position, rj);
	      this.result.push(r);
	      this.createFrictionEquationsFromContact(r, this.frictionResult);
	    }
	  }

	  boxBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    si.convexPolyhedronRepresentation.material = si.material;
	    sj.convexPolyhedronRepresentation.material = sj.material;
	    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
	    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
	    return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
	  }

	  sphereBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    const v3pool = this.v3pool; // we refer to the box as body j

	    const sides = sphereBox_sides;
	    xi.vsub(xj, box_to_sphere);
	    sj.getSideNormals(sides, qj);
	    const R = si.radius;

	    let found = false; // Store the resulting side penetration info

	    const side_ns = sphereBox_side_ns;
	    const side_ns1 = sphereBox_side_ns1;
	    const side_ns2 = sphereBox_side_ns2;
	    let side_h = null;
	    let side_penetrations = 0;
	    let side_dot1 = 0;
	    let side_dot2 = 0;
	    let side_distance = null;

	    for (let idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {
	      // Get the plane side normal (ns)
	      const ns = sphereBox_ns;
	      ns.copy(sides[idx]);
	      const h = ns.length();
	      ns.normalize(); // The normal/distance dot product tells which side of the plane we are

	      const dot = box_to_sphere.dot(ns);

	      if (dot < h + R && dot > 0) {
	        // Intersects plane. Now check the other two dimensions
	        const ns1 = sphereBox_ns1;
	        const ns2 = sphereBox_ns2;
	        ns1.copy(sides[(idx + 1) % 3]);
	        ns2.copy(sides[(idx + 2) % 3]);
	        const h1 = ns1.length();
	        const h2 = ns2.length();
	        ns1.normalize();
	        ns2.normalize();
	        const dot1 = box_to_sphere.dot(ns1);
	        const dot2 = box_to_sphere.dot(ns2);

	        if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
	          const dist = Math.abs(dot - h - R);

	          if (side_distance === null || dist < side_distance) {
	            side_distance = dist;
	            side_dot1 = dot1;
	            side_dot2 = dot2;
	            side_h = h;
	            side_ns.copy(ns);
	            side_ns1.copy(ns1);
	            side_ns2.copy(ns2);
	            side_penetrations++;

	            if (justTest) {
	              return true;
	            }
	          }
	        }
	      }
	    }

	    if (side_penetrations) {
	      found = true;
	      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	      side_ns.scale(-R, r.ri); // Sphere r

	      r.ni.copy(side_ns);
	      r.ni.negate(r.ni); // Normal should be out of sphere

	      side_ns.scale(side_h, side_ns);
	      side_ns1.scale(side_dot1, side_ns1);
	      side_ns.vadd(side_ns1, side_ns);
	      side_ns2.scale(side_dot2, side_ns2);
	      side_ns.vadd(side_ns2, r.rj); // Make relative to bodies

	      r.ri.vadd(xi, r.ri);
	      r.ri.vsub(bi.position, r.ri);
	      r.rj.vadd(xj, r.rj);
	      r.rj.vsub(bj.position, r.rj);
	      this.result.push(r);
	      this.createFrictionEquationsFromContact(r, this.frictionResult);
	    } // Check corners


	    let rj = v3pool.get();
	    const sphere_to_corner = sphereBox_sphere_to_corner;

	    for (let j = 0; j !== 2 && !found; j++) {
	      for (let k = 0; k !== 2 && !found; k++) {
	        for (let l = 0; l !== 2 && !found; l++) {
	          rj.set(0, 0, 0);

	          if (j) {
	            rj.vadd(sides[0], rj);
	          } else {
	            rj.vsub(sides[0], rj);
	          }

	          if (k) {
	            rj.vadd(sides[1], rj);
	          } else {
	            rj.vsub(sides[1], rj);
	          }

	          if (l) {
	            rj.vadd(sides[2], rj);
	          } else {
	            rj.vsub(sides[2], rj);
	          } // World position of corner


	          xj.vadd(rj, sphere_to_corner);
	          sphere_to_corner.vsub(xi, sphere_to_corner);

	          if (sphere_to_corner.lengthSquared() < R * R) {
	            if (justTest) {
	              return true;
	            }

	            found = true;
	            const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	            r.ri.copy(sphere_to_corner);
	            r.ri.normalize();
	            r.ni.copy(r.ri);
	            r.ri.scale(R, r.ri);
	            r.rj.copy(rj); // Make relative to bodies

	            r.ri.vadd(xi, r.ri);
	            r.ri.vsub(bi.position, r.ri);
	            r.rj.vadd(xj, r.rj);
	            r.rj.vsub(bj.position, r.rj);
	            this.result.push(r);
	            this.createFrictionEquationsFromContact(r, this.frictionResult);
	          }
	        }
	      }
	    }

	    v3pool.release(rj);
	    rj = null; // Check edges

	    const edgeTangent = v3pool.get();
	    const edgeCenter = v3pool.get();
	    const r = v3pool.get(); // r = edge center to sphere center

	    const orthogonal = v3pool.get();
	    const dist = v3pool.get();
	    const Nsides = sides.length;

	    for (let j = 0; j !== Nsides && !found; j++) {
	      for (let k = 0; k !== Nsides && !found; k++) {
	        if (j % 3 !== k % 3) {
	          // Get edge tangent
	          sides[k].cross(sides[j], edgeTangent);
	          edgeTangent.normalize();
	          sides[j].vadd(sides[k], edgeCenter);
	          r.copy(xi);
	          r.vsub(edgeCenter, r);
	          r.vsub(xj, r);
	          const orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction

	          edgeTangent.scale(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction
	          // Find the third side orthogonal to this one

	          let l = 0;

	          while (l === j % 3 || l === k % 3) {
	            l++;
	          } // vec from edge center to sphere projected to the plane orthogonal to the edge tangent


	          dist.copy(xi);
	          dist.vsub(orthogonal, dist);
	          dist.vsub(edgeCenter, dist);
	          dist.vsub(xj, dist); // Distances in tangent direction and distance in the plane orthogonal to it

	          const tdist = Math.abs(orthonorm);
	          const ndist = dist.length();

	          if (tdist < sides[l].length() && ndist < R) {
	            if (justTest) {
	              return true;
	            }

	            found = true;
	            const res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	            edgeCenter.vadd(orthogonal, res.rj); // box rj

	            res.rj.copy(res.rj);
	            dist.negate(res.ni);
	            res.ni.normalize();
	            res.ri.copy(res.rj);
	            res.ri.vadd(xj, res.ri);
	            res.ri.vsub(xi, res.ri);
	            res.ri.normalize();
	            res.ri.scale(R, res.ri); // Make relative to bodies

	            res.ri.vadd(xi, res.ri);
	            res.ri.vsub(bi.position, res.ri);
	            res.rj.vadd(xj, res.rj);
	            res.rj.vsub(bj.position, res.rj);
	            this.result.push(res);
	            this.createFrictionEquationsFromContact(res, this.frictionResult);
	          }
	        }
	      }
	    }

	    v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
	  }

	  planeBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    sj.convexPolyhedronRepresentation.material = sj.material;
	    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
	    sj.convexPolyhedronRepresentation.id = sj.id;
	    return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
	  }

	  convexConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {
	    const sepAxis = convexConvex_sepAxis;

	    if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
	      return;
	    }

	    if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
	      const res = [];
	      const q = convexConvex_q;
	      si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
	      let numContacts = 0;

	      for (let j = 0; j !== res.length; j++) {
	        if (justTest) {
	          return true;
	        }

	        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	        const ri = r.ri;
	        const rj = r.rj;
	        sepAxis.negate(r.ni);
	        res[j].normal.negate(q);
	        q.scale(res[j].depth, q);
	        res[j].point.vadd(q, ri);
	        rj.copy(res[j].point); // Contact points are in world coordinates. Transform back to relative

	        ri.vsub(xi, ri);
	        rj.vsub(xj, rj); // Make relative to bodies

	        ri.vadd(xi, ri);
	        ri.vsub(bi.position, ri);
	        rj.vadd(xj, rj);
	        rj.vsub(bj.position, rj);
	        this.result.push(r);
	        numContacts++;

	        if (!this.enableFrictionReduction) {
	          this.createFrictionEquationsFromContact(r, this.frictionResult);
	        }
	      }

	      if (this.enableFrictionReduction && numContacts) {
	        this.createFrictionFromAverage(numContacts);
	      }
	    }
	  }

	  sphereConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    const v3pool = this.v3pool;
	    xi.vsub(xj, convex_to_sphere);
	    const normals = sj.faceNormals;
	    const faces = sj.faces;
	    const verts = sj.vertices;
	    const R = si.radius;
	    //     return;
	    // }

	    let found = false; // Check corners

	    for (let i = 0; i !== verts.length; i++) {
	      const v = verts[i]; // World position of corner

	      const worldCorner = sphereConvex_worldCorner;
	      qj.vmult(v, worldCorner);
	      xj.vadd(worldCorner, worldCorner);
	      const sphere_to_corner = sphereConvex_sphereToCorner;
	      worldCorner.vsub(xi, sphere_to_corner);

	      if (sphere_to_corner.lengthSquared() < R * R) {
	        if (justTest) {
	          return true;
	        }

	        found = true;
	        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	        r.ri.copy(sphere_to_corner);
	        r.ri.normalize();
	        r.ni.copy(r.ri);
	        r.ri.scale(R, r.ri);
	        worldCorner.vsub(xj, r.rj); // Should be relative to the body.

	        r.ri.vadd(xi, r.ri);
	        r.ri.vsub(bi.position, r.ri); // Should be relative to the body.

	        r.rj.vadd(xj, r.rj);
	        r.rj.vsub(bj.position, r.rj);
	        this.result.push(r);
	        this.createFrictionEquationsFromContact(r, this.frictionResult);
	        return;
	      }
	    } // Check side (plane) intersections


	    for (let i = 0, nfaces = faces.length; i !== nfaces && found === false; i++) {
	      const normal = normals[i];
	      const face = faces[i]; // Get world-transformed normal of the face

	      const worldNormal = sphereConvex_worldNormal;
	      qj.vmult(normal, worldNormal); // Get a world vertex from the face

	      const worldPoint = sphereConvex_worldPoint;
	      qj.vmult(verts[face[0]], worldPoint);
	      worldPoint.vadd(xj, worldPoint); // Get a point on the sphere, closest to the face normal

	      const worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
	      worldNormal.scale(-R, worldSpherePointClosestToPlane);
	      xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane); // Vector from a face point to the closest point on the sphere

	      const penetrationVec = sphereConvex_penetrationVec;
	      worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec); // The penetration. Negative value means overlap.

	      const penetration = penetrationVec.dot(worldNormal);
	      const worldPointToSphere = sphereConvex_sphereToWorldPoint;
	      xi.vsub(worldPoint, worldPointToSphere);

	      if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
	        // Intersects plane. Now check if the sphere is inside the face polygon
	        const faceVerts = []; // Face vertices, in world coords

	        for (let j = 0, Nverts = face.length; j !== Nverts; j++) {
	          const worldVertex = v3pool.get();
	          qj.vmult(verts[face[j]], worldVertex);
	          xj.vadd(worldVertex, worldVertex);
	          faceVerts.push(worldVertex);
	        }

	        if (pointInPolygon(faceVerts, worldNormal, xi)) {
	          // Is the sphere center in the face polygon?
	          if (justTest) {
	            return true;
	          }

	          found = true;
	          const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	          worldNormal.scale(-R, r.ri); // Contact offset, from sphere center to contact

	          worldNormal.negate(r.ni); // Normal pointing out of sphere

	          const penetrationVec2 = v3pool.get();
	          worldNormal.scale(-penetration, penetrationVec2);
	          const penetrationSpherePoint = v3pool.get();
	          worldNormal.scale(-R, penetrationSpherePoint); //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);

	          xi.vsub(xj, r.rj);
	          r.rj.vadd(penetrationSpherePoint, r.rj);
	          r.rj.vadd(penetrationVec2, r.rj); // Should be relative to the body.

	          r.rj.vadd(xj, r.rj);
	          r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

	          r.ri.vadd(xi, r.ri);
	          r.ri.vsub(bi.position, r.ri);
	          v3pool.release(penetrationVec2);
	          v3pool.release(penetrationSpherePoint);
	          this.result.push(r);
	          this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

	          for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
	            v3pool.release(faceVerts[j]);
	          }

	          return; // We only expect *one* face contact
	        } else {
	          // Edge?
	          for (let j = 0; j !== face.length; j++) {
	            // Get two world transformed vertices
	            const v1 = v3pool.get();
	            const v2 = v3pool.get();
	            qj.vmult(verts[face[(j + 1) % face.length]], v1);
	            qj.vmult(verts[face[(j + 2) % face.length]], v2);
	            xj.vadd(v1, v1);
	            xj.vadd(v2, v2); // Construct edge vector

	            const edge = sphereConvex_edge;
	            v2.vsub(v1, edge); // Construct the same vector, but normalized

	            const edgeUnit = sphereConvex_edgeUnit;
	            edge.unit(edgeUnit); // p is xi projected onto the edge

	            const p = v3pool.get();
	            const v1_to_xi = v3pool.get();
	            xi.vsub(v1, v1_to_xi);
	            const dot = v1_to_xi.dot(edgeUnit);
	            edgeUnit.scale(dot, p);
	            p.vadd(v1, p); // Compute a vector from p to the center of the sphere

	            const xi_to_p = v3pool.get();
	            p.vsub(xi, xi_to_p); // Collision if the edge-sphere distance is less than the radius
	            // AND if p is in between v1 and v2

	            if (dot > 0 && dot * dot < edge.lengthSquared() && xi_to_p.lengthSquared() < R * R) {
	              // Collision if the edge-sphere distance is less than the radius
	              // Edge contact!
	              if (justTest) {
	                return true;
	              }

	              const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	              p.vsub(xj, r.rj);
	              p.vsub(xi, r.ni);
	              r.ni.normalize();
	              r.ni.scale(R, r.ri); // Should be relative to the body.

	              r.rj.vadd(xj, r.rj);
	              r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

	              r.ri.vadd(xi, r.ri);
	              r.ri.vsub(bi.position, r.ri);
	              this.result.push(r);
	              this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

	              for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
	                v3pool.release(faceVerts[j]);
	              }

	              v3pool.release(v1);
	              v3pool.release(v2);
	              v3pool.release(p);
	              v3pool.release(xi_to_p);
	              v3pool.release(v1_to_xi);
	              return;
	            }

	            v3pool.release(v1);
	            v3pool.release(v2);
	            v3pool.release(p);
	            v3pool.release(xi_to_p);
	            v3pool.release(v1_to_xi);
	          }
	        } // Release world vertices


	        for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
	          v3pool.release(faceVerts[j]);
	        }
	      }
	    }
	  }

	  planeConvex(planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {
	    // Simply return the points behind the plane.
	    const worldVertex = planeConvex_v;
	    const worldNormal = planeConvex_normal;
	    worldNormal.set(0, 0, 1);
	    planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation

	    let numContacts = 0;
	    const relpos = planeConvex_relpos;

	    for (let i = 0; i !== convexShape.vertices.length; i++) {
	      // Get world convex vertex
	      worldVertex.copy(convexShape.vertices[i]);
	      convexQuat.vmult(worldVertex, worldVertex);
	      convexPosition.vadd(worldVertex, worldVertex);
	      worldVertex.vsub(planePosition, relpos);
	      const dot = worldNormal.dot(relpos);

	      if (dot <= 0.0) {
	        if (justTest) {
	          return true;
	        }

	        const r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj); // Get vertex position projected on plane

	        const projected = planeConvex_projected;
	        worldNormal.scale(worldNormal.dot(relpos), projected);
	        worldVertex.vsub(projected, projected);
	        projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

	        r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane
	        // rj is now just the vector from the convex center to the vertex

	        worldVertex.vsub(convexPosition, r.rj); // Make it relative to the body

	        r.ri.vadd(planePosition, r.ri);
	        r.ri.vsub(planeBody.position, r.ri);
	        r.rj.vadd(convexPosition, r.rj);
	        r.rj.vsub(convexBody.position, r.rj);
	        this.result.push(r);
	        numContacts++;

	        if (!this.enableFrictionReduction) {
	          this.createFrictionEquationsFromContact(r, this.frictionResult);
	        }
	      }
	    }

	    if (this.enableFrictionReduction && numContacts) {
	      this.createFrictionFromAverage(numContacts);
	    }
	  }

	  boxConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    si.convexPolyhedronRepresentation.material = si.material;
	    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
	    return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
	  }

	  sphereHeightfield(sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {
	    const data = hfShape.data;
	    const radius = sphereShape.radius;
	    const w = hfShape.elementSize;
	    const worldPillarOffset = sphereHeightfield_tmp2; // Get sphere position to heightfield local!

	    const localSpherePos = sphereHeightfield_tmp1;
	    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos); // Get the index of the data points to test against

	    let iMinX = Math.floor((localSpherePos.x - radius) / w) - 1;
	    let iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1;
	    let iMinY = Math.floor((localSpherePos.y - radius) / w) - 1;
	    let iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1; // Bail out if we are out of the terrain

	    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
	      return;
	    } // Clamp index to edges


	    if (iMinX < 0) {
	      iMinX = 0;
	    }

	    if (iMaxX < 0) {
	      iMaxX = 0;
	    }

	    if (iMinY < 0) {
	      iMinY = 0;
	    }

	    if (iMaxY < 0) {
	      iMaxY = 0;
	    }

	    if (iMinX >= data.length) {
	      iMinX = data.length - 1;
	    }

	    if (iMaxX >= data.length) {
	      iMaxX = data.length - 1;
	    }

	    if (iMaxY >= data[0].length) {
	      iMaxY = data[0].length - 1;
	    }

	    if (iMinY >= data[0].length) {
	      iMinY = data[0].length - 1;
	    }

	    const minMax = [];
	    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
	    const min = minMax[0];
	    const max = minMax[1]; // Bail out if we can't touch the bounding height box

	    if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) {
	      return;
	    }

	    const result = this.result;

	    for (let i = iMinX; i < iMaxX; i++) {
	      for (let j = iMinY; j < iMaxY; j++) {
	        const numContactsBefore = result.length;
	        let intersecting = false; // Lower triangle

	        hfShape.getConvexTrianglePillar(i, j, false);
	        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

	        if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
	          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
	        }

	        if (justTest && intersecting) {
	          return true;
	        } // Upper triangle


	        hfShape.getConvexTrianglePillar(i, j, true);
	        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

	        if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
	          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
	        }

	        if (justTest && intersecting) {
	          return true;
	        }

	        const numContacts = result.length - numContactsBefore;

	        if (numContacts > 2) {
	          return;
	        }
	        /*
	          // Skip all but 1
	          for (let k = 0; k < numContacts - 1; k++) {
	              result.pop();
	          }
	        */

	      }
	    }
	  }

	  boxHeightfield(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    si.convexPolyhedronRepresentation.material = si.material;
	    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
	    return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
	  }

	  convexHeightfield(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {
	    const data = hfShape.data;
	    const w = hfShape.elementSize;
	    const radius = convexShape.boundingSphereRadius;
	    const worldPillarOffset = convexHeightfield_tmp2;
	    const faceList = convexHeightfield_faceList; // Get sphere position to heightfield local!

	    const localConvexPos = convexHeightfield_tmp1;
	    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos); // Get the index of the data points to test against

	    let iMinX = Math.floor((localConvexPos.x - radius) / w) - 1;
	    let iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1;
	    let iMinY = Math.floor((localConvexPos.y - radius) / w) - 1;
	    let iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1; // Bail out if we are out of the terrain

	    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
	      return;
	    } // Clamp index to edges


	    if (iMinX < 0) {
	      iMinX = 0;
	    }

	    if (iMaxX < 0) {
	      iMaxX = 0;
	    }

	    if (iMinY < 0) {
	      iMinY = 0;
	    }

	    if (iMaxY < 0) {
	      iMaxY = 0;
	    }

	    if (iMinX >= data.length) {
	      iMinX = data.length - 1;
	    }

	    if (iMaxX >= data.length) {
	      iMaxX = data.length - 1;
	    }

	    if (iMaxY >= data[0].length) {
	      iMaxY = data[0].length - 1;
	    }

	    if (iMinY >= data[0].length) {
	      iMinY = data[0].length - 1;
	    }

	    const minMax = [];
	    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
	    const min = minMax[0];
	    const max = minMax[1]; // Bail out if we're cant touch the bounding height box

	    if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) {
	      return;
	    }

	    for (let i = iMinX; i < iMaxX; i++) {
	      for (let j = iMinY; j < iMaxY; j++) {
	        let intersecting = false; // Lower triangle

	        hfShape.getConvexTrianglePillar(i, j, false);
	        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

	        if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
	          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
	        }

	        if (justTest && intersecting) {
	          return true;
	        } // Upper triangle


	        hfShape.getConvexTrianglePillar(i, j, true);
	        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

	        if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
	          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
	        }

	        if (justTest && intersecting) {
	          return true;
	        }
	      }
	    }
	  }

	  sphereParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
	    // The normal is the unit vector from sphere center to particle center
	    const normal = particleSphere_normal;
	    normal.set(0, 0, 1);
	    xi.vsub(xj, normal);
	    const lengthSquared = normal.lengthSquared();

	    if (lengthSquared <= sj.radius * sj.radius) {
	      if (justTest) {
	        return true;
	      }

	      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	      normal.normalize();
	      r.rj.copy(normal);
	      r.rj.scale(sj.radius, r.rj);
	      r.ni.copy(normal); // Contact normal

	      r.ni.negate(r.ni);
	      r.ri.set(0, 0, 0); // Center of particle

	      this.result.push(r);
	      this.createFrictionEquationsFromContact(r, this.frictionResult);
	    }
	  }

	  planeParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
	    const normal = particlePlane_normal;
	    normal.set(0, 0, 1);
	    bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation

	    const relpos = particlePlane_relpos;
	    xi.vsub(bj.position, relpos);
	    const dot = normal.dot(relpos);

	    if (dot <= 0.0) {
	      if (justTest) {
	        return true;
	      }

	      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	      r.ni.copy(normal); // Contact normal is the plane normal

	      r.ni.negate(r.ni);
	      r.ri.set(0, 0, 0); // Center of particle
	      // Get particle position projected on plane

	      const projected = particlePlane_projected;
	      normal.scale(normal.dot(xi), projected);
	      xi.vsub(projected, projected); //projected.vadd(bj.position,projected);
	      // rj is now the projected world position minus plane position

	      r.rj.copy(projected);
	      this.result.push(r);
	      this.createFrictionEquationsFromContact(r, this.frictionResult);
	    }
	  }

	  boxParticle(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    si.convexPolyhedronRepresentation.material = si.material;
	    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
	    return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
	  }

	  convexParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
	    let penetratedFaceIndex = -1;
	    const penetratedFaceNormal = convexParticle_penetratedFaceNormal;
	    const worldPenetrationVec = convexParticle_worldPenetrationVec;
	    let minPenetration = null;

	    const local = convexParticle_local;
	    local.copy(xi);
	    local.vsub(xj, local); // Convert position to relative the convex origin

	    qj.conjugate(cqj);
	    cqj.vmult(local, local);

	    if (sj.pointIsInside(local)) {
	      if (sj.worldVerticesNeedsUpdate) {
	        sj.computeWorldVertices(xj, qj);
	      }

	      if (sj.worldFaceNormalsNeedsUpdate) {
	        sj.computeWorldFaceNormals(qj);
	      } // For each world polygon in the polyhedra


	      for (let i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
	        // Construct world face vertices
	        const verts = [sj.worldVertices[sj.faces[i][0]]];
	        const normal = sj.worldFaceNormals[i]; // Check how much the particle penetrates the polygon plane.

	        xi.vsub(verts[0], convexParticle_vertexToParticle);
	        const penetration = -normal.dot(convexParticle_vertexToParticle);

	        if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {
	          if (justTest) {
	            return true;
	          }

	          minPenetration = penetration;
	          penetratedFaceIndex = i;
	          penetratedFaceNormal.copy(normal);
	        }
	      }

	      if (penetratedFaceIndex !== -1) {
	        // Setup contact
	        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
	        penetratedFaceNormal.scale(minPenetration, worldPenetrationVec); // rj is the particle position projected to the face

	        worldPenetrationVec.vadd(xi, worldPenetrationVec);
	        worldPenetrationVec.vsub(xj, worldPenetrationVec);
	        r.rj.copy(worldPenetrationVec); //const projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
	        //projectedToFace.copy(r.rj);
	        //qj.vmult(r.rj,r.rj);

	        penetratedFaceNormal.negate(r.ni); // Contact normal

	        r.ri.set(0, 0, 0); // Center of particle

	        const ri = r.ri;
	        const rj = r.rj; // Make relative to bodies

	        ri.vadd(xi, ri);
	        ri.vsub(bi.position, ri);
	        rj.vadd(xj, rj);
	        rj.vsub(bj.position, rj);
	        this.result.push(r);
	        this.createFrictionEquationsFromContact(r, this.frictionResult);
	      } else {
	        console.warn('Point found inside convex, but did not find penetrating face!');
	      }
	    }
	  }

	  heightfieldCylinder(hfShape, convexShape, hfPos, convexPos, hfQuat, convexQuat, hfBody, convexBody, rsi, rsj, justTest) {
	    return this.convexHeightfield(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest);
	  }

	  particleCylinder(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
	    return this.convexParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest);
	  }

	  sphereTrimesh(sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {
	    const edgeVertexA = sphereTrimesh_edgeVertexA;
	    const edgeVertexB = sphereTrimesh_edgeVertexB;
	    const edgeVector = sphereTrimesh_edgeVector;
	    const edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
	    const localSpherePos = sphereTrimesh_localSpherePos;
	    const tmp = sphereTrimesh_tmp;
	    const localSphereAABB = sphereTrimesh_localSphereAABB;
	    const v2 = sphereTrimesh_v2;
	    const relpos = sphereTrimesh_relpos;
	    const triangles = sphereTrimesh_triangles; // Convert sphere position to local in the trimesh

	    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos); // Get the aabb of the sphere locally in the trimesh

	    const sphereRadius = sphereShape.radius;
	    localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);
	    localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);
	    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles); //for (let i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All
	    // Vertices

	    const v = sphereTrimesh_v;
	    const radiusSquared = sphereShape.radius * sphereShape.radius;

	    for (let i = 0; i < triangles.length; i++) {
	      for (let j = 0; j < 3; j++) {
	        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v); // Check vertex overlap in sphere

	        v.vsub(localSpherePos, relpos);

	        if (relpos.lengthSquared() <= radiusSquared) {
	          // Safe up
	          v2.copy(v);
	          Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
	          v.vsub(spherePos, relpos);

	          if (justTest) {
	            return true;
	          }

	          let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
	          r.ni.copy(relpos);
	          r.ni.normalize(); // ri is the vector from sphere center to the sphere surface

	          r.ri.copy(r.ni);
	          r.ri.scale(sphereShape.radius, r.ri);
	          r.ri.vadd(spherePos, r.ri);
	          r.ri.vsub(sphereBody.position, r.ri);
	          r.rj.copy(v);
	          r.rj.vsub(trimeshBody.position, r.rj); // Store result

	          this.result.push(r);
	          this.createFrictionEquationsFromContact(r, this.frictionResult);
	        }
	      }
	    } // Check all edges


	    for (let i = 0; i < triangles.length; i++) {
	      for (let j = 0; j < 3; j++) {
	        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
	        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + (j + 1) % 3], edgeVertexB);
	        edgeVertexB.vsub(edgeVertexA, edgeVector); // Project sphere position to the edge

	        localSpherePos.vsub(edgeVertexB, tmp);
	        const positionAlongEdgeB = tmp.dot(edgeVector);
	        localSpherePos.vsub(edgeVertexA, tmp);
	        let positionAlongEdgeA = tmp.dot(edgeVector);

	        if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
	          // Now check the orthogonal distance from edge to sphere center
	          localSpherePos.vsub(edgeVertexA, tmp);
	          edgeVectorUnit.copy(edgeVector);
	          edgeVectorUnit.normalize();
	          positionAlongEdgeA = tmp.dot(edgeVectorUnit);
	          edgeVectorUnit.scale(positionAlongEdgeA, tmp);
	          tmp.vadd(edgeVertexA, tmp); // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame

	          const dist = tmp.distanceTo(localSpherePos);

	          if (dist < sphereShape.radius) {
	            if (justTest) {
	              return true;
	            }

	            const r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
	            tmp.vsub(localSpherePos, r.ni);
	            r.ni.normalize();
	            r.ni.scale(sphereShape.radius, r.ri);
	            r.ri.vadd(spherePos, r.ri);
	            r.ri.vsub(sphereBody.position, r.ri);
	            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
	            tmp.vsub(trimeshBody.position, r.rj);
	            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
	            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
	            this.result.push(r);
	            this.createFrictionEquationsFromContact(r, this.frictionResult);
	          }
	        }
	      }
	    } // Triangle faces


	    const va = sphereTrimesh_va;
	    const vb = sphereTrimesh_vb;
	    const vc = sphereTrimesh_vc;
	    const normal = sphereTrimesh_normal;

	    for (let i = 0, N = triangles.length; i !== N; i++) {
	      trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
	      trimeshShape.getNormal(triangles[i], normal);
	      localSpherePos.vsub(va, tmp);
	      let dist = tmp.dot(normal);
	      normal.scale(dist, tmp);
	      localSpherePos.vsub(tmp, tmp); // tmp is now the sphere position projected to the triangle plane

	      dist = tmp.distanceTo(localSpherePos);

	      if (Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
	        if (justTest) {
	          return true;
	        }

	        let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
	        tmp.vsub(localSpherePos, r.ni);
	        r.ni.normalize();
	        r.ni.scale(sphereShape.radius, r.ri);
	        r.ri.vadd(spherePos, r.ri);
	        r.ri.vsub(sphereBody.position, r.ri);
	        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
	        tmp.vsub(trimeshBody.position, r.rj);
	        Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
	        Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
	        this.result.push(r);
	        this.createFrictionEquationsFromContact(r, this.frictionResult);
	      }
	    }

	    triangles.length = 0;
	  }

	  planeTrimesh(planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {
	    // Make contacts!
	    const v = new Vec3();
	    const normal = planeTrimesh_normal;
	    normal.set(0, 0, 1);
	    planeQuat.vmult(normal, normal); // Turn normal according to plane

	    for (let i = 0; i < trimeshShape.vertices.length / 3; i++) {
	      // Get world vertex from trimesh
	      trimeshShape.getVertex(i, v); // Safe up

	      const v2 = new Vec3();
	      v2.copy(v);
	      Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v); // Check plane side

	      const relpos = planeTrimesh_relpos;
	      v.vsub(planePos, relpos);
	      const dot = normal.dot(relpos);

	      if (dot <= 0.0) {
	        if (justTest) {
	          return true;
	        }

	        const r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);
	        r.ni.copy(normal); // Contact normal is the plane normal
	        // Get vertex position projected on plane

	        const projected = planeTrimesh_projected;
	        normal.scale(relpos.dot(normal), projected);
	        v.vsub(projected, projected); // ri is the projected world position minus plane position

	        r.ri.copy(projected);
	        r.ri.vsub(planeBody.position, r.ri);
	        r.rj.copy(v);
	        r.rj.vsub(trimeshBody.position, r.rj); // Store result

	        this.result.push(r);
	        this.createFrictionEquationsFromContact(r, this.frictionResult);
	      }
	    }
	  } // convexTrimesh(
	  //   si: ConvexPolyhedron, sj: Trimesh, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion,
	  //   bi: Body, bj: Body, rsi?: Shape | null, rsj?: Shape | null,
	  //   faceListA?: number[] | null, faceListB?: number[] | null,
	  // ) {
	  //   const sepAxis = convexConvex_sepAxis;
	  //   if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
	  //       return;
	  //   }
	  //   // Construct a temp hull for each triangle
	  //   const hullB = new ConvexPolyhedron();
	  //   hullB.faces = [[0,1,2]];
	  //   const va = new Vec3();
	  //   const vb = new Vec3();
	  //   const vc = new Vec3();
	  //   hullB.vertices = [
	  //       va,
	  //       vb,
	  //       vc
	  //   ];
	  //   for (let i = 0; i < sj.indices.length / 3; i++) {
	  //       const triangleNormal = new Vec3();
	  //       sj.getNormal(i, triangleNormal);
	  //       hullB.faceNormals = [triangleNormal];
	  //       sj.getTriangleVertices(i, va, vb, vc);
	  //       let d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
	  //       if(!d){
	  //           triangleNormal.scale(-1, triangleNormal);
	  //           d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
	  //           if(!d){
	  //               continue;
	  //           }
	  //       }
	  //       const res: ConvexPolyhedronContactPoint[] = [];
	  //       const q = convexConvex_q;
	  //       si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
	  //       for(let j = 0; j !== res.length; j++){
	  //           const r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
	  //               ri = r.ri,
	  //               rj = r.rj;
	  //           r.ni.copy(triangleNormal);
	  //           r.ni.negate(r.ni);
	  //           res[j].normal.negate(q);
	  //           q.mult(res[j].depth, q);
	  //           res[j].point.vadd(q, ri);
	  //           rj.copy(res[j].point);
	  //           // Contact points are in world coordinates. Transform back to relative
	  //           ri.vsub(xi,ri);
	  //           rj.vsub(xj,rj);
	  //           // Make relative to bodies
	  //           ri.vadd(xi, ri);
	  //           ri.vsub(bi.position, ri);
	  //           rj.vadd(xj, rj);
	  //           rj.vsub(bj.position, rj);
	  //           result.push(r);
	  //       }
	  //   }
	  // }


	}
	const averageNormal = new Vec3();
	const averageContactPointA = new Vec3();
	const averageContactPointB = new Vec3();
	const tmpVec1 = new Vec3();
	const tmpVec2 = new Vec3();
	const tmpQuat1 = new Quaternion();
	const tmpQuat2 = new Quaternion();

	const planeTrimesh_normal = new Vec3();
	const planeTrimesh_relpos = new Vec3();
	const planeTrimesh_projected = new Vec3();
	const sphereTrimesh_normal = new Vec3();
	const sphereTrimesh_relpos = new Vec3();
	new Vec3();
	const sphereTrimesh_v = new Vec3();
	const sphereTrimesh_v2 = new Vec3();
	const sphereTrimesh_edgeVertexA = new Vec3();
	const sphereTrimesh_edgeVertexB = new Vec3();
	const sphereTrimesh_edgeVector = new Vec3();
	const sphereTrimesh_edgeVectorUnit = new Vec3();
	const sphereTrimesh_localSpherePos = new Vec3();
	const sphereTrimesh_tmp = new Vec3();
	const sphereTrimesh_va = new Vec3();
	const sphereTrimesh_vb = new Vec3();
	const sphereTrimesh_vc = new Vec3();
	const sphereTrimesh_localSphereAABB = new AABB();
	const sphereTrimesh_triangles = [];
	const point_on_plane_to_sphere = new Vec3();
	const plane_to_sphere_ortho = new Vec3(); // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html

	const pointInPolygon_edge = new Vec3();
	const pointInPolygon_edge_x_normal = new Vec3();
	const pointInPolygon_vtp = new Vec3();

	function pointInPolygon(verts, normal, p) {
	  let positiveResult = null;
	  const N = verts.length;

	  for (let i = 0; i !== N; i++) {
	    const v = verts[i]; // Get edge to the next vertex

	    const edge = pointInPolygon_edge;
	    verts[(i + 1) % N].vsub(v, edge); // Get cross product between polygon normal and the edge

	    const edge_x_normal = pointInPolygon_edge_x_normal; //const edge_x_normal = new Vec3();

	    edge.cross(normal, edge_x_normal); // Get vector between point and current vertex

	    const vertex_to_p = pointInPolygon_vtp;
	    p.vsub(v, vertex_to_p); // This dot product determines which side of the edge the point is

	    const r = edge_x_normal.dot(vertex_to_p); // If all such dot products have same sign, we are inside the polygon.

	    if (positiveResult === null || r > 0 && positiveResult === true || r <= 0 && positiveResult === false) {
	      if (positiveResult === null) {
	        positiveResult = r > 0;
	      }

	      continue;
	    } else {
	      return false; // Encountered some other sign. Exit.
	    }
	  } // If we got here, all dot products were of the same sign.


	  return true;
	}

	const box_to_sphere = new Vec3();
	const sphereBox_ns = new Vec3();
	const sphereBox_ns1 = new Vec3();
	const sphereBox_ns2 = new Vec3();
	const sphereBox_sides = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
	const sphereBox_sphere_to_corner = new Vec3();
	const sphereBox_side_ns = new Vec3();
	const sphereBox_side_ns1 = new Vec3();
	const sphereBox_side_ns2 = new Vec3();
	const convex_to_sphere = new Vec3();
	const sphereConvex_edge = new Vec3();
	const sphereConvex_edgeUnit = new Vec3();
	const sphereConvex_sphereToCorner = new Vec3();
	const sphereConvex_worldCorner = new Vec3();
	const sphereConvex_worldNormal = new Vec3();
	const sphereConvex_worldPoint = new Vec3();
	const sphereConvex_worldSpherePointClosestToPlane = new Vec3();
	const sphereConvex_penetrationVec = new Vec3();
	const sphereConvex_sphereToWorldPoint = new Vec3();
	new Vec3();
	new Vec3();
	const planeConvex_v = new Vec3();
	const planeConvex_normal = new Vec3();
	const planeConvex_relpos = new Vec3();
	const planeConvex_projected = new Vec3();
	const convexConvex_sepAxis = new Vec3();
	const convexConvex_q = new Vec3();
	const particlePlane_normal = new Vec3();
	const particlePlane_relpos = new Vec3();
	const particlePlane_projected = new Vec3();
	const particleSphere_normal = new Vec3(); // WIP

	const cqj = new Quaternion();
	const convexParticle_local = new Vec3();
	new Vec3();
	const convexParticle_penetratedFaceNormal = new Vec3();
	const convexParticle_vertexToParticle = new Vec3();
	const convexParticle_worldPenetrationVec = new Vec3();
	const convexHeightfield_tmp1 = new Vec3();
	const convexHeightfield_tmp2 = new Vec3();
	const convexHeightfield_faceList = [0];
	const sphereHeightfield_tmp1 = new Vec3();
	const sphereHeightfield_tmp2 = new Vec3();

	class OverlapKeeper {
	  /**
	   * @todo Remove useless constructor
	   */
	  constructor() {
	    this.current = [];
	    this.previous = [];
	  }
	  /**
	   * getKey
	   */


	  getKey(i, j) {
	    if (j < i) {
	      const temp = j;
	      j = i;
	      i = temp;
	    }

	    return i << 16 | j;
	  }
	  /**
	   * set
	   */


	  set(i, j) {
	    // Insertion sort. This way the diff will have linear complexity.
	    const key = this.getKey(i, j);
	    const current = this.current;
	    let index = 0;

	    while (key > current[index]) {
	      index++;
	    }

	    if (key === current[index]) {
	      return; // Pair was already added
	    }

	    for (let j = current.length - 1; j >= index; j--) {
	      current[j + 1] = current[j];
	    }

	    current[index] = key;
	  }
	  /**
	   * tick
	   */


	  tick() {
	    const tmp = this.current;
	    this.current = this.previous;
	    this.previous = tmp;
	    this.current.length = 0;
	  }
	  /**
	   * getDiff
	   */


	  getDiff(additions, removals) {
	    const a = this.current;
	    const b = this.previous;
	    const al = a.length;
	    const bl = b.length;
	    let j = 0;

	    for (let i = 0; i < al; i++) {
	      let found = false;
	      const keyA = a[i];

	      while (keyA > b[j]) {
	        j++;
	      }

	      found = keyA === b[j];

	      if (!found) {
	        unpackAndPush(additions, keyA);
	      }
	    }

	    j = 0;

	    for (let i = 0; i < bl; i++) {
	      let found = false;
	      const keyB = b[i];

	      while (keyB > a[j]) {
	        j++;
	      }

	      found = a[j] === keyB;

	      if (!found) {
	        unpackAndPush(removals, keyB);
	      }
	    }
	  }

	}

	function unpackAndPush(array, key) {
	  array.push((key & 0xffff0000) >> 16, key & 0x0000ffff);
	}

	const getKey = (i, j) => i < j ? `${i}-${j}` : `${j}-${i}`;
	/**
	 * TupleDictionary
	 */


	class TupleDictionary {
	  constructor() {
	    this.data = {
	      keys: []
	    };
	  }

	  /** get */
	  get(i, j) {
	    const key = getKey(i, j);
	    return this.data[key];
	  }
	  /** set */


	  set(i, j, value) {
	    const key = getKey(i, j); // Check if key already exists

	    if (!this.get(i, j)) {
	      this.data.keys.push(key);
	    }

	    this.data[key] = value;
	  }
	  /** delete */


	  delete(i, j) {
	    const key = getKey(i, j);
	    const index = this.data.keys.indexOf(key);

	    if (index !== -1) {
	      this.data.keys.splice(index, 1);
	    }

	    delete this.data[key];
	  }
	  /** reset */


	  reset() {
	    const data = this.data;
	    const keys = data.keys;

	    while (keys.length > 0) {
	      const key = keys.pop();
	      delete data[key];
	    }
	  }

	}

	/**
	 * The physics world
	 */
	class World extends EventTarget {
	  /**
	   * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
	   */

	  /**
	   * Makes bodies go to sleep when they've been inactive.
	   * @default false
	   */

	  /**
	   * All the current contacts (instances of ContactEquation) in the world.
	   */

	  /**
	   * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
	   * @default 0
	   */

	  /**
	   * Set to true to use fast quaternion normalization. It is often enough accurate to use.
	   * If bodies tend to explode, set to false.
	   * @default false
	   */

	  /**
	   * The wall-clock time since simulation start.
	   */

	  /**
	   * Number of timesteps taken since start.
	   */

	  /**
	   * Default and last timestep sizes.
	   */

	  /**
	   * The gravity of the world.
	   */

	  /**
	   * Gravity to use when approximating the friction max force (mu*mass*gravity).
	   * If undefined, global gravity will be used.
	   * Use to enable friction in a World with a null gravity vector (no gravity).
	   */

	  /**
	   * The broadphase algorithm to use.
	   * @default NaiveBroadphase
	   */

	  /**
	   * All bodies in this world
	   */

	  /**
	   * True if any bodies are not sleeping, false if every body is sleeping.
	   */

	  /**
	   * The solver algorithm to use.
	   * @default GSSolver
	   */

	  /**
	   * collisionMatrix
	   */

	  /**
	   * CollisionMatrix from the previous step.
	   */

	  /**
	   * All added contactmaterials.
	   */

	  /**
	   * Used to look up a ContactMaterial given two instances of Material.
	   */

	  /**
	   * The default material of the bodies.
	   */

	  /**
	   * This contact material is used if no suitable contactmaterial is found for a contact.
	   */

	  /**
	   * Time accumulator for interpolation.
	   * @see https://gafferongames.com/game-physics/fix-your-timestep/
	   */

	  /**
	   * Dispatched after a body has been added to the world.
	   */

	  /**
	   * Dispatched after a body has been removed from the world.
	   */
	  constructor(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    super();
	    this.dt = -1;
	    this.allowSleep = !!options.allowSleep;
	    this.contacts = [];
	    this.frictionEquations = [];
	    this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;
	    this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;
	    this.time = 0.0;
	    this.stepnumber = 0;
	    this.default_dt = 1 / 60;
	    this.nextId = 0;
	    this.gravity = new Vec3();

	    if (options.gravity) {
	      this.gravity.copy(options.gravity);
	    }

	    if (options.frictionGravity) {
	      this.frictionGravity = new Vec3();
	      this.frictionGravity.copy(options.frictionGravity);
	    }

	    this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();
	    this.bodies = [];
	    this.hasActiveBodies = false;
	    this.solver = options.solver !== undefined ? options.solver : new GSSolver();
	    this.constraints = [];
	    this.narrowphase = new Narrowphase(this);
	    this.collisionMatrix = new ArrayCollisionMatrix();
	    this.collisionMatrixPrevious = new ArrayCollisionMatrix();
	    this.bodyOverlapKeeper = new OverlapKeeper();
	    this.shapeOverlapKeeper = new OverlapKeeper();
	    this.contactmaterials = [];
	    this.contactMaterialTable = new TupleDictionary();
	    this.defaultMaterial = new Material('default');
	    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {
	      friction: 0.3,
	      restitution: 0.0
	    });
	    this.doProfiling = false;
	    this.profile = {
	      solve: 0,
	      makeContactConstraints: 0,
	      broadphase: 0,
	      integrate: 0,
	      narrowphase: 0
	    };
	    this.accumulator = 0;
	    this.subsystems = [];
	    this.addBodyEvent = {
	      type: 'addBody',
	      body: null
	    };
	    this.removeBodyEvent = {
	      type: 'removeBody',
	      body: null
	    };
	    this.idToBodyMap = {};
	    this.broadphase.setWorld(this);
	  }
	  /**
	   * Get the contact material between materials m1 and m2
	   * @return The contact material if it was found.
	   */


	  getContactMaterial(m1, m2) {
	    return this.contactMaterialTable.get(m1.id, m2.id);
	  }
	  /**
	   * Store old collision state info
	   */


	  collisionMatrixTick() {
	    const temp = this.collisionMatrixPrevious;
	    this.collisionMatrixPrevious = this.collisionMatrix;
	    this.collisionMatrix = temp;
	    this.collisionMatrix.reset();
	    this.bodyOverlapKeeper.tick();
	    this.shapeOverlapKeeper.tick();
	  }
	  /**
	   * Add a constraint to the simulation.
	   */


	  addConstraint(c) {
	    this.constraints.push(c);
	  }
	  /**
	   * Removes a constraint
	   */


	  removeConstraint(c) {
	    const idx = this.constraints.indexOf(c);

	    if (idx !== -1) {
	      this.constraints.splice(idx, 1);
	    }
	  }
	  /**
	   * Raycast test
	   * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
	   */


	  rayTest(from, to, result) {
	    if (result instanceof RaycastResult) {
	      // Do raycastClosest
	      this.raycastClosest(from, to, {
	        skipBackfaces: true
	      }, result);
	    } else {
	      // Do raycastAll
	      this.raycastAll(from, to, {
	        skipBackfaces: true
	      }, result);
	    }
	  }
	  /**
	   * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
	   * @return True if any body was hit.
	   */


	  raycastAll(from, to, options, callback) {
	    if (options === void 0) {
	      options = {};
	    }

	    options.mode = Ray.ALL;
	    options.from = from;
	    options.to = to;
	    options.callback = callback;
	    return tmpRay.intersectWorld(this, options);
	  }
	  /**
	   * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
	   * @return True if any body was hit.
	   */


	  raycastAny(from, to, options, result) {
	    if (options === void 0) {
	      options = {};
	    }

	    options.mode = Ray.ANY;
	    options.from = from;
	    options.to = to;
	    options.result = result;
	    return tmpRay.intersectWorld(this, options);
	  }
	  /**
	   * Ray cast, and return information of the closest hit.
	   * @return True if any body was hit.
	   */


	  raycastClosest(from, to, options, result) {
	    if (options === void 0) {
	      options = {};
	    }

	    options.mode = Ray.CLOSEST;
	    options.from = from;
	    options.to = to;
	    options.result = result;
	    return tmpRay.intersectWorld(this, options);
	  }
	  /**
	   * Add a rigid body to the simulation.
	   * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
	   * @todo Adding an array of bodies should be possible. This would save some loops too
	   */


	  addBody(body) {
	    if (this.bodies.includes(body)) {
	      return;
	    }

	    body.index = this.bodies.length;
	    this.bodies.push(body);
	    body.world = this;
	    body.initPosition.copy(body.position);
	    body.initVelocity.copy(body.velocity);
	    body.timeLastSleepy = this.time;

	    if (body instanceof Body) {
	      body.initAngularVelocity.copy(body.angularVelocity);
	      body.initQuaternion.copy(body.quaternion);
	    }

	    this.collisionMatrix.setNumObjects(this.bodies.length);
	    this.addBodyEvent.body = body;
	    this.idToBodyMap[body.id] = body;
	    this.dispatchEvent(this.addBodyEvent);
	  }
	  /**
	   * Remove a rigid body from the simulation.
	   */


	  removeBody(body) {
	    body.world = null;
	    const n = this.bodies.length - 1;
	    const bodies = this.bodies;
	    const idx = bodies.indexOf(body);

	    if (idx !== -1) {
	      bodies.splice(idx, 1); // Todo: should use a garbage free method
	      // Recompute index

	      for (let i = 0; i !== bodies.length; i++) {
	        bodies[i].index = i;
	      }

	      this.collisionMatrix.setNumObjects(n);
	      this.removeBodyEvent.body = body;
	      delete this.idToBodyMap[body.id];
	      this.dispatchEvent(this.removeBodyEvent);
	    }
	  }

	  getBodyById(id) {
	    return this.idToBodyMap[id];
	  }
	  /**
	   * @todo Make a faster map
	   */


	  getShapeById(id) {
	    const bodies = this.bodies;

	    for (let i = 0; i < bodies.length; i++) {
	      const shapes = bodies[i].shapes;

	      for (let j = 0; j < shapes.length; j++) {
	        const shape = shapes[j];

	        if (shape.id === id) {
	          return shape;
	        }
	      }
	    }

	    return null;
	  }
	  /**
	   * Adds a contact material to the World
	   */


	  addContactMaterial(cmat) {
	    // Add contact material
	    this.contactmaterials.push(cmat); // Add current contact material to the material table

	    this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
	  }
	  /**
	   * Removes a contact material from the World.
	   */


	  removeContactMaterial(cmat) {
	    const idx = this.contactmaterials.indexOf(cmat);

	    if (idx === -1) {
	      return;
	    }

	    this.contactmaterials.splice(idx, 1);
	    this.contactMaterialTable.delete(cmat.materials[0].id, cmat.materials[1].id);
	  }
	  /**
	   * Step the simulation forward keeping track of last called time
	   * to be able to step the world at a fixed rate, independently of framerate.
	   *
	   * @param dt The fixed time step size to use (default: 1 / 60).
	   * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
	   * @see https://gafferongames.com/post/fix_your_timestep/
	   * @example
	   *     // Run the simulation independently of framerate every 1 / 60 ms
	   *     world.fixedStep()
	   */


	  fixedStep(dt, maxSubSteps) {
	    if (dt === void 0) {
	      dt = 1 / 60;
	    }

	    if (maxSubSteps === void 0) {
	      maxSubSteps = 10;
	    }

	    const time = performance.now() / 1000; // seconds

	    if (!this.lastCallTime) {
	      this.step(dt, undefined, maxSubSteps);
	    } else {
	      const timeSinceLastCalled = time - this.lastCallTime;
	      this.step(dt, timeSinceLastCalled, maxSubSteps);
	    }

	    this.lastCallTime = time;
	  }
	  /**
	   * Step the physics world forward in time.
	   *
	   * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
	   *
	   * @param dt The fixed time step size to use.
	   * @param timeSinceLastCalled The time elapsed since the function was last called.
	   * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
	   * @see https://web.archive.org/web/20180426154531/http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World#What_do_the_parameters_to_btDynamicsWorld::stepSimulation_mean.3F
	   * @example
	   *     // fixed timestepping without interpolation
	   *     world.step(1 / 60)
	   */


	  step(dt, timeSinceLastCalled, maxSubSteps) {
	    if (maxSubSteps === void 0) {
	      maxSubSteps = 10;
	    }

	    if (timeSinceLastCalled === undefined) {
	      // Fixed, simple stepping
	      this.internalStep(dt); // Increment time

	      this.time += dt;
	    } else {
	      this.accumulator += timeSinceLastCalled;
	      const t0 = performance.now();
	      let substeps = 0;

	      while (this.accumulator >= dt && substeps < maxSubSteps) {
	        // Do fixed steps to catch up
	        this.internalStep(dt);
	        this.accumulator -= dt;
	        substeps++;

	        if (performance.now() - t0 > dt * 1000) {
	          // The framerate is not interactive anymore.
	          // We are below the target framerate.
	          // Better bail out.
	          break;
	        }
	      } // Remove the excess accumulator, since we may not
	      // have had enough substeps available to catch up


	      this.accumulator = this.accumulator % dt;
	      const t = this.accumulator / dt;

	      for (let j = 0; j !== this.bodies.length; j++) {
	        const b = this.bodies[j];
	        b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
	        b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
	        b.previousQuaternion.normalize();
	      }

	      this.time += timeSinceLastCalled;
	    }
	  }

	  internalStep(dt) {
	    this.dt = dt;
	    const contacts = this.contacts;
	    const p1 = World_step_p1;
	    const p2 = World_step_p2;
	    const N = this.bodies.length;
	    const bodies = this.bodies;
	    const solver = this.solver;
	    const gravity = this.gravity;
	    const doProfiling = this.doProfiling;
	    const profile = this.profile;
	    const DYNAMIC = Body.DYNAMIC;
	    let profilingStart = -Infinity;
	    const constraints = this.constraints;
	    const frictionEquationPool = World_step_frictionEquationPool;
	    gravity.length();
	    const gx = gravity.x;
	    const gy = gravity.y;
	    const gz = gravity.z;
	    let i = 0;

	    if (doProfiling) {
	      profilingStart = performance.now();
	    } // Add gravity to all objects


	    for (i = 0; i !== N; i++) {
	      const bi = bodies[i];

	      if (bi.type === DYNAMIC) {
	        // Only for dynamic bodies
	        const f = bi.force;
	        const m = bi.mass;
	        f.x += m * gx;
	        f.y += m * gy;
	        f.z += m * gz;
	      }
	    } // Update subsystems


	    for (let i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) {
	      this.subsystems[i].update();
	    } // Collision detection


	    if (doProfiling) {
	      profilingStart = performance.now();
	    }

	    p1.length = 0; // Clean up pair arrays from last step

	    p2.length = 0;
	    this.broadphase.collisionPairs(this, p1, p2);

	    if (doProfiling) {
	      profile.broadphase = performance.now() - profilingStart;
	    } // Remove constrained pairs with collideConnected == false


	    let Nconstraints = constraints.length;

	    for (i = 0; i !== Nconstraints; i++) {
	      const c = constraints[i];

	      if (!c.collideConnected) {
	        for (let j = p1.length - 1; j >= 0; j -= 1) {
	          if (c.bodyA === p1[j] && c.bodyB === p2[j] || c.bodyB === p1[j] && c.bodyA === p2[j]) {
	            p1.splice(j, 1);
	            p2.splice(j, 1);
	          }
	        }
	      }
	    }

	    this.collisionMatrixTick(); // Generate contacts

	    if (doProfiling) {
	      profilingStart = performance.now();
	    }

	    const oldcontacts = World_step_oldContacts;
	    const NoldContacts = contacts.length;

	    for (i = 0; i !== NoldContacts; i++) {
	      oldcontacts.push(contacts[i]);
	    }

	    contacts.length = 0; // Transfer FrictionEquation from current list to the pool for reuse

	    const NoldFrictionEquations = this.frictionEquations.length;

	    for (i = 0; i !== NoldFrictionEquations; i++) {
	      frictionEquationPool.push(this.frictionEquations[i]);
	    }

	    this.frictionEquations.length = 0;
	    this.narrowphase.getContacts(p1, p2, this, contacts, oldcontacts, // To be reused
	    this.frictionEquations, frictionEquationPool);

	    if (doProfiling) {
	      profile.narrowphase = performance.now() - profilingStart;
	    } // Loop over all collisions


	    if (doProfiling) {
	      profilingStart = performance.now();
	    } // Add all friction eqs


	    for (i = 0; i < this.frictionEquations.length; i++) {
	      solver.addEquation(this.frictionEquations[i]);
	    }

	    const ncontacts = contacts.length;

	    for (let k = 0; k !== ncontacts; k++) {
	      // Current contact
	      const c = contacts[k]; // Get current collision indeces

	      const bi = c.bi;
	      const bj = c.bj;
	      const si = c.si;
	      const sj = c.sj; // Get collision properties

	      let cm;

	      if (bi.material && bj.material) {
	        cm = this.getContactMaterial(bi.material, bj.material) || this.defaultContactMaterial;
	      } else {
	        cm = this.defaultContactMaterial;
	      } // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;


	      cm.friction; // c.restitution = cm.restitution;
	      // If friction or restitution were specified in the material, use them

	      if (bi.material && bj.material) {
	        if (bi.material.friction >= 0 && bj.material.friction >= 0) {
	          bi.material.friction * bj.material.friction;
	        }

	        if (bi.material.restitution >= 0 && bj.material.restitution >= 0) {
	          c.restitution = bi.material.restitution * bj.material.restitution;
	        }
	      } // c.setSpookParams(
	      //           cm.contactEquationStiffness,
	      //           cm.contactEquationRelaxation,
	      //           dt
	      //       );


	      solver.addEquation(c); // // Add friction constraint equation
	      // if(mu > 0){
	      // 	// Create 2 tangent equations
	      // 	const mug = mu * gnorm;
	      // 	const reducedMass = (bi.invMass + bj.invMass);
	      // 	if(reducedMass > 0){
	      // 		reducedMass = 1/reducedMass;
	      // 	}
	      // 	const pool = frictionEquationPool;
	      // 	const c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
	      // 	const c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
	      // 	this.frictionEquations.push(c1, c2);
	      // 	c1.bi = c2.bi = bi;
	      // 	c1.bj = c2.bj = bj;
	      // 	c1.minForce = c2.minForce = -mug*reducedMass;
	      // 	c1.maxForce = c2.maxForce = mug*reducedMass;
	      // 	// Copy over the relative vectors
	      // 	c1.ri.copy(c.ri);
	      // 	c1.rj.copy(c.rj);
	      // 	c2.ri.copy(c.ri);
	      // 	c2.rj.copy(c.rj);
	      // 	// Construct tangents
	      // 	c.ni.tangents(c1.t, c2.t);
	      //           // Set spook params
	      //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
	      //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
	      //           c1.enabled = c2.enabled = c.enabled;
	      // 	// Add equations to solver
	      // 	solver.addEquation(c1);
	      // 	solver.addEquation(c2);
	      // }

	      if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
	        const speedSquaredB = bj.velocity.lengthSquared() + bj.angularVelocity.lengthSquared();
	        const speedLimitSquaredB = bj.sleepSpeedLimit ** 2;

	        if (speedSquaredB >= speedLimitSquaredB * 2) {
	          bi.wakeUpAfterNarrowphase = true;
	        }
	      }

	      if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
	        const speedSquaredA = bi.velocity.lengthSquared() + bi.angularVelocity.lengthSquared();
	        const speedLimitSquaredA = bi.sleepSpeedLimit ** 2;

	        if (speedSquaredA >= speedLimitSquaredA * 2) {
	          bj.wakeUpAfterNarrowphase = true;
	        }
	      } // Now we know that i and j are in contact. Set collision matrix state


	      this.collisionMatrix.set(bi, bj, true);

	      if (!this.collisionMatrixPrevious.get(bi, bj)) {
	        // First contact!
	        // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
	        World_step_collideEvent.body = bj;
	        World_step_collideEvent.contact = c;
	        bi.dispatchEvent(World_step_collideEvent);
	        World_step_collideEvent.body = bi;
	        bj.dispatchEvent(World_step_collideEvent);
	      }

	      this.bodyOverlapKeeper.set(bi.id, bj.id);
	      this.shapeOverlapKeeper.set(si.id, sj.id);
	    }

	    this.emitContactEvents();

	    if (doProfiling) {
	      profile.makeContactConstraints = performance.now() - profilingStart;
	      profilingStart = performance.now();
	    } // Wake up bodies


	    for (i = 0; i !== N; i++) {
	      const bi = bodies[i];

	      if (bi.wakeUpAfterNarrowphase) {
	        bi.wakeUp();
	        bi.wakeUpAfterNarrowphase = false;
	      }
	    } // Add user-added constraints


	    Nconstraints = constraints.length;

	    for (i = 0; i !== Nconstraints; i++) {
	      const c = constraints[i];
	      c.update();

	      for (let j = 0, Neq = c.equations.length; j !== Neq; j++) {
	        const eq = c.equations[j];
	        solver.addEquation(eq);
	      }
	    } // Solve the constrained system


	    solver.solve(dt, this);

	    if (doProfiling) {
	      profile.solve = performance.now() - profilingStart;
	    } // Remove all contacts from solver


	    solver.removeAllEquations(); // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details

	    const pow = Math.pow;

	    for (i = 0; i !== N; i++) {
	      const bi = bodies[i];

	      if (bi.type & DYNAMIC) {
	        // Only for dynamic bodies
	        const ld = pow(1.0 - bi.linearDamping, dt);
	        const v = bi.velocity;
	        v.scale(ld, v);
	        const av = bi.angularVelocity;

	        if (av) {
	          const ad = pow(1.0 - bi.angularDamping, dt);
	          av.scale(ad, av);
	        }
	      }
	    }

	    this.dispatchEvent(World_step_preStepEvent); // Leap frog
	    // vnew = v + h*f/m
	    // xnew = x + h*vnew

	    if (doProfiling) {
	      profilingStart = performance.now();
	    }

	    const stepnumber = this.stepnumber;
	    const quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
	    const quatNormalizeFast = this.quatNormalizeFast;

	    for (i = 0; i !== N; i++) {
	      bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
	    }

	    this.clearForces();
	    this.broadphase.dirty = true;

	    if (doProfiling) {
	      profile.integrate = performance.now() - profilingStart;
	    } // Update step number


	    this.stepnumber += 1;
	    this.dispatchEvent(World_step_postStepEvent); // Sleeping update

	    let hasActiveBodies = true;

	    if (this.allowSleep) {
	      hasActiveBodies = false;

	      for (i = 0; i !== N; i++) {
	        const bi = bodies[i];
	        bi.sleepTick(this.time);

	        if (bi.sleepState !== Body.SLEEPING) {
	          hasActiveBodies = true;
	        }
	      }
	    }

	    this.hasActiveBodies = hasActiveBodies;
	  }

	  emitContactEvents() {
	    const hasBeginContact = this.hasAnyEventListener('beginContact');
	    const hasEndContact = this.hasAnyEventListener('endContact');

	    if (hasBeginContact || hasEndContact) {
	      this.bodyOverlapKeeper.getDiff(additions, removals);
	    }

	    if (hasBeginContact) {
	      for (let i = 0, l = additions.length; i < l; i += 2) {
	        beginContactEvent.bodyA = this.getBodyById(additions[i]);
	        beginContactEvent.bodyB = this.getBodyById(additions[i + 1]);
	        this.dispatchEvent(beginContactEvent);
	      }

	      beginContactEvent.bodyA = beginContactEvent.bodyB = null;
	    }

	    if (hasEndContact) {
	      for (let i = 0, l = removals.length; i < l; i += 2) {
	        endContactEvent.bodyA = this.getBodyById(removals[i]);
	        endContactEvent.bodyB = this.getBodyById(removals[i + 1]);
	        this.dispatchEvent(endContactEvent);
	      }

	      endContactEvent.bodyA = endContactEvent.bodyB = null;
	    }

	    additions.length = removals.length = 0;
	    const hasBeginShapeContact = this.hasAnyEventListener('beginShapeContact');
	    const hasEndShapeContact = this.hasAnyEventListener('endShapeContact');

	    if (hasBeginShapeContact || hasEndShapeContact) {
	      this.shapeOverlapKeeper.getDiff(additions, removals);
	    }

	    if (hasBeginShapeContact) {
	      for (let i = 0, l = additions.length; i < l; i += 2) {
	        const shapeA = this.getShapeById(additions[i]);
	        const shapeB = this.getShapeById(additions[i + 1]);
	        beginShapeContactEvent.shapeA = shapeA;
	        beginShapeContactEvent.shapeB = shapeB;
	        if (shapeA) beginShapeContactEvent.bodyA = shapeA.body;
	        if (shapeB) beginShapeContactEvent.bodyB = shapeB.body;
	        this.dispatchEvent(beginShapeContactEvent);
	      }

	      beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
	    }

	    if (hasEndShapeContact) {
	      for (let i = 0, l = removals.length; i < l; i += 2) {
	        const shapeA = this.getShapeById(removals[i]);
	        const shapeB = this.getShapeById(removals[i + 1]);
	        endShapeContactEvent.shapeA = shapeA;
	        endShapeContactEvent.shapeB = shapeB;
	        if (shapeA) endShapeContactEvent.bodyA = shapeA.body;
	        if (shapeB) endShapeContactEvent.bodyB = shapeB.body;
	        this.dispatchEvent(endShapeContactEvent);
	      }

	      endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
	    }
	  }
	  /**
	   * Sets all body forces in the world to zero.
	   */


	  clearForces() {
	    const bodies = this.bodies;
	    const N = bodies.length;

	    for (let i = 0; i !== N; i++) {
	      const b = bodies[i];
	      b.force;
	      b.torque;
	      b.force.set(0, 0, 0);
	      b.torque.set(0, 0, 0);
	    }
	  }

	} // Temp stuff

	new AABB();
	const tmpRay = new Ray(); // performance.now() fallback on Date.now()

	const performance = globalThis.performance || {};

	if (!performance.now) {
	  let nowOffset = Date.now();

	  if (performance.timing && performance.timing.navigationStart) {
	    nowOffset = performance.timing.navigationStart;
	  }

	  performance.now = () => Date.now() - nowOffset;
	}

	new Vec3(); // Dispatched after the world has stepped forward in time.
	// Reusable event objects to save memory.

	const World_step_postStepEvent = {
	  type: 'postStep'
	}; // Dispatched before the world steps forward in time.

	const World_step_preStepEvent = {
	  type: 'preStep'
	};
	const World_step_collideEvent = {
	  type: Body.COLLIDE_EVENT_NAME,
	  body: null,
	  contact: null
	}; // Pools for unused objects

	const World_step_oldContacts = [];
	const World_step_frictionEquationPool = []; // Reusable arrays for collision pairs

	const World_step_p1 = [];
	const World_step_p2 = []; // Stuff for emitContactEvents

	const additions = [];
	const removals = [];
	const beginContactEvent = {
	  type: 'beginContact',
	  bodyA: null,
	  bodyB: null
	};
	const endContactEvent = {
	  type: 'endContact',
	  bodyA: null,
	  bodyB: null
	};
	const beginShapeContactEvent = {
	  type: 'beginShapeContact',
	  bodyA: null,
	  bodyB: null,
	  shapeA: null,
	  shapeB: null
	};
	const endShapeContactEvent = {
	  type: 'endShapeContact',
	  bodyA: null,
	  bodyB: null,
	  shapeA: null,
	  shapeB: null
	};

	exports.scene = void 0; exports.camera = void 0; exports.renderer = void 0; exports.world = void 0;

	function Init() {
	  if(window.parent !== undefined) cancelAnimationFrame(window.parent.raf);

	  document.body.style.setProperty("overflow", "hidden");
	  
	  exports.scene = new Scene();
	  exports.camera = new PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
	  exports.camera.position.z = 50;
	  exports.camera.lookAt(new Vector3(0,0,0));
	  
	  
	  exports.scene.add(exports.camera);
	  
	  exports.renderer = new WebGLRenderer({
	    antialias: true,
	    preserveDrawingBuffer: true
	  });

	  exports.renderer.setSize(window.innerWidth, window.innerHeight);
	  
	  document.body.appendChild( exports.renderer.domElement );

	  var canvas = document.getElementsByTagName("canvas")[0];
	  canvas.style.position = "absolute";
	  canvas.style.left = "0px";
	    canvas.style.top = "0px";

	  exports.world = new World();
	}

	function EnablePhysics(gravityVector = new Vec3(0, -9.81, 0)) {
	    exports.world.gravity = gravityVector;
	}

	let physMeshes = [], threeMeshes = [];

	function Render() {
	  if(window.parent !== undefined) window.parent.raf = requestAnimationFrame(Render);
	  else requestAnimationFrame(Render);

	  exports.world.step( 1 / 60 );

	  exports.renderer.render(exports.scene, exports.camera);
	  
	  for(var i = 0; i < threeMeshes.length; i++) {
	    threeMeshes[i].position.copy(physMeshes[i].position);
	    threeMeshes[i].quaternion.copy(physMeshes[i].quaternion);
	  }
	}

	/**
	 * A material that maps the normal vectors to RGB colors.
	 *
	 * @augments Material
	 */
	class MeshNormalMaterial extends Material$1 {

		/**
		 * Constructs a new mesh normal material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */
		constructor( parameters ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMeshNormalMaterial = true;

			this.type = 'MeshNormalMaterial';

			/**
			 * The texture to create a bump map. The black and white values map to the
			 * perceived depth in relation to the lights. Bump doesn't actually affect
			 * the geometry of the object, only the lighting. If a normal map is defined
			 * this will be ignored.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.bumpMap = null;

			/**
			 * How much the bump map affects the material. Typical range is `[0,1]`.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.bumpScale = 1;

			/**
			 * The texture to create a normal map. The RGB values affect the surface
			 * normal for each pixel fragment and change the way the color is lit. Normal
			 * maps do not change the actual shape of the surface, only the lighting. In
			 * case the material has a normal map authored using the left handed
			 * convention, the `y` component of `normalScale` should be negated to compensate
			 * for the different handedness.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.normalMap = null;

			/**
			 * The type of normal map.
			 *
			 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
			 * @default TangentSpaceNormalMap
			 */
			this.normalMapType = TangentSpaceNormalMap;

			/**
			 * How much the normal map affects the material. Typical value range is `[0,1]`.
			 *
			 * @type {Vector2}
			 * @default (1,1)
			 */
			this.normalScale = new Vector2( 1, 1 );

			/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.displacementMap = null;

			/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementScale = 1;

			/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementBias = 0;

			/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.wireframe = false;

			/**
			 * Controls the thickness of the wireframe.
			 *
			 * WebGL and WebGPU ignore this property and always render
			 * 1 pixel wide lines.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.wireframeLinewidth = 1;

			/**
			 * Whether the material is rendered with flat shading or not.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.flatShading = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	/**
	 * A material for shiny surfaces with specular highlights.
	 *
	 * The material uses a non-physically based [Blinn-Phong]{@link https://en.wikipedia.org/wiki/Blinn-Phong_shading_model}
	 * model for calculating reflectance. Unlike the Lambertian model used in the
	 * {@link MeshLambertMaterial} this can simulate shiny surfaces with specular
	 * highlights (such as varnished wood). `MeshPhongMaterial` uses per-fragment shading.
	 *
	 * Performance will generally be greater when using this material over the
	 * {@link MeshStandardMaterial} or {@link MeshPhysicalMaterial}, at the cost of
	 * some graphical accuracy.
	 *
	 * @augments Material
	 */
	class MeshPhongMaterial extends Material$1 {

		/**
		 * Constructs a new mesh phong material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */
		constructor( parameters ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMeshPhongMaterial = true;

			this.type = 'MeshPhongMaterial';

			/**
			 * Color of the material.
			 *
			 * @type {Color}
			 * @default (1,1,1)
			 */
			this.color = new Color( 0xffffff ); // diffuse

			/**
			 * Specular color of the material. The default color is set to `0x111111` (very dark grey)
			 *
			 * This defines how shiny the material is and the color of its shine.
			 *
			 * @type {Color}
			 */
			this.specular = new Color( 0x111111 );

			/**
			 * How shiny the specular highlight is; a higher value gives a sharper highlight.
			 *
			 * @type {number}
			 * @default 30
			 */
			this.shininess = 30;

			/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
			 * color is modulated by the diffuse `color`.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.map = null;

			/**
			 * The light map. Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.lightMap = null;

			/**
			 * Intensity of the baked light.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.lightMapIntensity = 1.0;

			/**
			 * The red channel of this texture is used as the ambient occlusion map.
			 * Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.aoMap = null;

			/**
			 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
			 * disables ambient occlusion. Where intensity is `1` and the AO map's
			 * red channel is also `1`, ambient light is fully occluded on a surface.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.aoMapIntensity = 1.0;

			/**
			 * Emissive (light) color of the material, essentially a solid color
			 * unaffected by other lighting.
			 *
			 * @type {Color}
			 * @default (0,0,0)
			 */
			this.emissive = new Color( 0x000000 );

			/**
			 * Intensity of the emissive light. Modulates the emissive color.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.emissiveIntensity = 1.0;

			/**
			 * Set emissive (glow) map. The emissive map color is modulated by the
			 * emissive color and the emissive intensity. If you have an emissive map,
			 * be sure to set the emissive color to something other than black.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.emissiveMap = null;

			/**
			 * The texture to create a bump map. The black and white values map to the
			 * perceived depth in relation to the lights. Bump doesn't actually affect
			 * the geometry of the object, only the lighting. If a normal map is defined
			 * this will be ignored.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.bumpMap = null;

			/**
			 * How much the bump map affects the material. Typical range is `[0,1]`.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.bumpScale = 1;

			/**
			 * The texture to create a normal map. The RGB values affect the surface
			 * normal for each pixel fragment and change the way the color is lit. Normal
			 * maps do not change the actual shape of the surface, only the lighting. In
			 * case the material has a normal map authored using the left handed
			 * convention, the `y` component of `normalScale` should be negated to compensate
			 * for the different handedness.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.normalMap = null;

			/**
			 * The type of normal map.
			 *
			 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
			 * @default TangentSpaceNormalMap
			 */
			this.normalMapType = TangentSpaceNormalMap;

			/**
			 * How much the normal map affects the material. Typical value range is `[0,1]`.
			 *
			 * @type {Vector2}
			 * @default (1,1)
			 */
			this.normalScale = new Vector2( 1, 1 );

			/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.displacementMap = null;

			/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementScale = 1;

			/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementBias = 0;

			/**
			 * The specular map value affects both how much the specular surface
			 * highlight contributes and how much of the environment map affects the
			 * surface.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.specularMap = null;

			/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.alphaMap = null;

			/**
			 * The environment map.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.envMap = null;

			/**
			 * The rotation of the environment map in radians.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */
			this.envMapRotation = new Euler();

			/**
			 * How to combine the result of the surface's color with the environment map, if any.
			 *
			 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
			 * blend between the two colors.
			 *
			 * @type {(MultiplyOperation|MixOperation|AddOperation)}
			 * @default MultiplyOperation
			 */
			this.combine = MultiplyOperation;

			/**
			 * How much the environment map affects the surface.
			 * The valid range is between `0` (no reflections) and `1` (full reflections).
			 *
			 * @type {number}
			 * @default 1
			 */
			this.reflectivity = 1;

			/**
			 * The index of refraction (IOR) of air (approximately 1) divided by the
			 * index of refraction of the material. It is used with environment mapping
			 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
			 * The refraction ratio should not exceed `1`.
			 *
			 * @type {number}
			 * @default 0.98
			 */
			this.refractionRatio = 0.98;

			/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.wireframe = false;

			/**
			 * Controls the thickness of the wireframe.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.wireframeLinewidth = 1;

			/**
			 * Defines appearance of wireframe ends.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */
			this.wireframeLinecap = 'round';

			/**
			 * Defines appearance of wireframe joints.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */
			this.wireframeLinejoin = 'round';

			/**
			 * Whether the material is rendered with flat shading or not.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.flatShading = false;

			/**
			 * Whether the material is affected by fog or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.envMapRotation.copy( source.envMapRotation );
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	/**
	 * A standard physically based material, using Metallic-Roughness workflow.
	 *
	 * Physically based rendering (PBR) has recently become the standard in many
	 * 3D applications, such as [Unity]{@link https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/},
	 * [Unreal]{@link https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/} and
	 * [3D Studio Max]{@link http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017}.
	 *
	 * This approach differs from older approaches in that instead of using
	 * approximations for the way in which light interacts with a surface, a
	 * physically correct model is used. The idea is that, instead of tweaking
	 * materials to look good under specific lighting, a material can be created
	 * that will react 'correctly' under all lighting scenarios.
	 *
	 * In practice this gives a more accurate and realistic looking result than
	 * the {@link MeshLambertMaterial} or {@link MeshPhongMaterial}, at the cost of
	 * being somewhat more computationally expensive. `MeshStandardMaterial` uses per-fragment
	 * shading.
	 *
	 * Note that for best results you should always specify an environment map when using this material.
	 *
	 * For a non-technical introduction to the concept of PBR and how to set up a
	 * PBR material, check out these articles by the people at [marmoset]{@link https://www.marmoset.co}:
	 *
	 * - [Basic Theory of Physically Based Rendering]{@link https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/}
	 * - [Physically Based Rendering and You Can Too]{@link https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/}
	 *
	 * Technical details of the approach used in three.js (and most other PBR systems) can be found is this
	 * [paper from Disney]{@link https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf}
	 * (pdf), by Brent Burley.
	 *
	 * @augments Material
	 */
	class MeshStandardMaterial extends Material$1 {

		/**
		 * Constructs a new mesh standard material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */
		constructor( parameters ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMeshStandardMaterial = true;

			this.type = 'MeshStandardMaterial';

			this.defines = { 'STANDARD': '' };

			/**
			 * Color of the material.
			 *
			 * @type {Color}
			 * @default (1,1,1)
			 */
			this.color = new Color( 0xffffff ); // diffuse

			/**
			 * How rough the material appears. `0.0` means a smooth mirror reflection, `1.0`
			 * means fully diffuse. If `roughnessMap` is also provided,
			 * both values are multiplied.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.roughness = 1.0;

			/**
			 * How much the material is like a metal. Non-metallic materials such as wood
			 * or stone use `0.0`, metallic use `1.0`, with nothing (usually) in between.
			 * A value between `0.0` and `1.0` could be used for a rusty metal look.
			 * If `metalnessMap` is also provided, both values are multiplied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.metalness = 0.0;

			/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
			 * color is modulated by the diffuse `color`.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.map = null;

			/**
			 * The light map. Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.lightMap = null;

			/**
			 * Intensity of the baked light.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.lightMapIntensity = 1.0;

			/**
			 * The red channel of this texture is used as the ambient occlusion map.
			 * Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.aoMap = null;

			/**
			 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
			 * disables ambient occlusion. Where intensity is `1` and the AO map's
			 * red channel is also `1`, ambient light is fully occluded on a surface.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.aoMapIntensity = 1.0;

			/**
			 * Emissive (light) color of the material, essentially a solid color
			 * unaffected by other lighting.
			 *
			 * @type {Color}
			 * @default (0,0,0)
			 */
			this.emissive = new Color( 0x000000 );

			/**
			 * Intensity of the emissive light. Modulates the emissive color.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.emissiveIntensity = 1.0;

			/**
			 * Set emissive (glow) map. The emissive map color is modulated by the
			 * emissive color and the emissive intensity. If you have an emissive map,
			 * be sure to set the emissive color to something other than black.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.emissiveMap = null;

			/**
			 * The texture to create a bump map. The black and white values map to the
			 * perceived depth in relation to the lights. Bump doesn't actually affect
			 * the geometry of the object, only the lighting. If a normal map is defined
			 * this will be ignored.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.bumpMap = null;

			/**
			 * How much the bump map affects the material. Typical range is `[0,1]`.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.bumpScale = 1;

			/**
			 * The texture to create a normal map. The RGB values affect the surface
			 * normal for each pixel fragment and change the way the color is lit. Normal
			 * maps do not change the actual shape of the surface, only the lighting. In
			 * case the material has a normal map authored using the left handed
			 * convention, the `y` component of `normalScale` should be negated to compensate
			 * for the different handedness.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.normalMap = null;

			/**
			 * The type of normal map.
			 *
			 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
			 * @default TangentSpaceNormalMap
			 */
			this.normalMapType = TangentSpaceNormalMap;

			/**
			 * How much the normal map affects the material. Typical value range is `[0,1]`.
			 *
			 * @type {Vector2}
			 * @default (1,1)
			 */
			this.normalScale = new Vector2( 1, 1 );

			/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.displacementMap = null;

			/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementScale = 1;

			/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementBias = 0;

			/**
			 * The green channel of this texture is used to alter the roughness of the
			 * material.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.roughnessMap = null;

			/**
			 * The blue channel of this texture is used to alter the metalness of the
			 * material.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.metalnessMap = null;

			/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.alphaMap = null;

			/**
			 * The environment map. To ensure a physically correct rendering, environment maps
			 * are internally pre-processed with {@link PMREMGenerator}.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.envMap = null;

			/**
			 * The rotation of the environment map in radians.
			 *
			 * @type {Euler}
			 * @default (0,0,0)
			 */
			this.envMapRotation = new Euler();

			/**
			 * Scales the effect of the environment map by multiplying its color.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.envMapIntensity = 1.0;

			/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.wireframe = false;

			/**
			 * Controls the thickness of the wireframe.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.wireframeLinewidth = 1;

			/**
			 * Defines appearance of wireframe ends.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */
			this.wireframeLinecap = 'round';

			/**
			 * Defines appearance of wireframe joints.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */
			this.wireframeLinejoin = 'round';

			/**
			 * Whether the material is rendered with flat shading or not.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.flatShading = false;

			/**
			 * Whether the material is affected by fog or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.defines = { 'STANDARD': '' };

			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.roughnessMap = source.roughnessMap;

			this.metalnessMap = source.metalnessMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.envMapRotation.copy( source.envMapRotation );
			this.envMapIntensity = source.envMapIntensity;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	/**
	 * An extension of the {@link MeshStandardMaterial}, providing more advanced
	 * physically-based rendering properties:
	 *
	 * - Anisotropy: Ability to represent the anisotropic property of materials
	 * as observable with brushed metals.
	 * - Clearcoat: Some materials  like car paints, carbon fiber, and wet surfaces  require
	 * a clear, reflective layer on top of another layer that may be irregular or rough.
	 * Clearcoat approximates this effect, without the need for a separate transparent surface.
	 * - Iridescence: Allows to render the effect where hue varies  depending on the viewing
	 * angle and illumination angle. This can be seen on soap bubbles, oil films, or on the
	 * wings of many insects.
	 * - Physically-based transparency: One limitation of {@link Material#opacity} is that highly
	 * transparent materials are less reflective. Physically-based transmission provides a more
	 * realistic option for thin, transparent surfaces like glass.
	 * - Advanced reflectivity: More flexible reflectivity for non-metallic materials.
	 * - Sheen: Can be used for representing cloth and fabric materials.
	 *
	 * As a result of these complex shading features, `MeshPhysicalMaterial` has a
	 * higher performance cost, per pixel, than other three.js materials. Most
	 * effects are disabled by default, and add cost as they are enabled. For
	 * best results, always specify an environment map when using this material.
	 *
	 * @augments MeshStandardMaterial
	 */
	class MeshPhysicalMaterial extends MeshStandardMaterial {

		/**
		 * Constructs a new mesh physical material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */
		constructor( parameters ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMeshPhysicalMaterial = true;

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.type = 'MeshPhysicalMaterial';

			/**
			 * The rotation of the anisotropy in tangent, bitangent space, measured in radians
			 * counter-clockwise from the tangent. When `anisotropyMap` is present, this
			 * property provides additional rotation to the vectors in the texture.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.anisotropyRotation = 0;

			/**
			 * Red and green channels represent the anisotropy direction in `[-1, 1]` tangent,
			 * bitangent space, to be rotated by `anisotropyRotation`. The blue channel
			 * contains strength as `[0, 1]` to be multiplied by `anisotropy`.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.anisotropyMap = null;

			/**
			 * The red channel of this texture is multiplied against `clearcoat`,
			 * for per-pixel control over a coating's intensity.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.clearcoatMap = null;

			/**
			 * Roughness of the clear coat layer, from `0.0` to `1.0`.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.clearcoatRoughness = 0.0;

			/**
			 * The green channel of this texture is multiplied against
			 * `clearcoatRoughness`, for per-pixel control over a coating's roughness.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.clearcoatRoughnessMap = null;

			/**
			 * How much `clearcoatNormalMap` affects the clear coat layer, from
			 * `(0,0)` to `(1,1)`.
			 *
			 * @type {Vector2}
			 * @default (1,1)
			 */
			this.clearcoatNormalScale = new Vector2( 1, 1 );

			/**
			 * Can be used to enable independent normals for the clear coat layer.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.clearcoatNormalMap = null;

			/**
			 * Index-of-refraction for non-metallic materials, from `1.0` to `2.333`.
			 *
			 * @type {number}
			 * @default 1.5
			 */
			this.ior = 1.5;

			/**
			 * Degree of reflectivity, from `0.0` to `1.0`. Default is `0.5`, which
			 * corresponds to an index-of-refraction of `1.5`.
			 *
			 * This models the reflectivity of non-metallic materials. It has no effect
			 * when `metalness` is `1.0`
			 *
			 * @name MeshPhysicalMaterial#reflectivity
			 * @type {number}
			 * @default 0.5
			 */
			Object.defineProperty( this, 'reflectivity', {
				get: function () {

					return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

				},
				set: function ( reflectivity ) {

					this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

				}
			} );

			/**
			 * The red channel of this texture is multiplied against `iridescence`, for per-pixel
			 * control over iridescence.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.iridescenceMap = null;

			/**
			 * Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
			 * Between `1.0` to `2.333`.
			 *
			 * @type {number}
			 * @default 1.3
			 */
			this.iridescenceIOR = 1.3;

			/**
			 *Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer.
			 Thickness of iridescence layer has an equivalent effect of the one `thickness` has on `ior`.
			 *
			 * @type {Array<number,number>}
			 * @default [100,400]
			 */
			this.iridescenceThicknessRange = [ 100, 400 ];

			/**
			 * A texture that defines the thickness of the iridescence layer, stored in the green channel.
			 * Minimum and maximum values of thickness are defined by `iridescenceThicknessRange` array:
			 * - `0.0` in the green channel will result in thickness equal to first element of the array.
			 * - `1.0` in the green channel will result in thickness equal to second element of the array.
			 * - Values in-between will linearly interpolate between the elements of the array.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.iridescenceThicknessMap = null;

			/**
			 * The sheen tint.
			 *
			 * @type {Color}
			 * @default (0,0,0)
			 */
			this.sheenColor = new Color( 0x000000 );

			/**
			 * The RGB channels of this texture are multiplied against  `sheenColor`, for per-pixel control
			 * over sheen tint.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.sheenColorMap = null;

			/**
			 * Roughness of the sheen layer, from `0.0` to `1.0`.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.sheenRoughness = 1.0;

			/**
			 * The alpha channel of this texture is multiplied against `sheenRoughness`, for per-pixel control
			 * over sheen roughness.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.sheenRoughnessMap = null;

			/**
			 * The red channel of this texture is multiplied against `transmission`, for per-pixel control over
			 * optical transparency.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.transmissionMap = null;

			/**
			 * The thickness of the volume beneath the surface. The value is given in the
			 * coordinate space of the mesh. If the value is `0` the material is
			 * thin-walled. Otherwise the material is a volume boundary.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.thickness = 0;

			/**
			 * A texture that defines the thickness, stored in the green channel. This will
			 * be multiplied by `thickness`.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.thicknessMap = null;

			/**
			 * Density of the medium given as the average distance that light travels in
			 * the medium before interacting with a particle. The value is given in world
			 * space units, and must be greater than zero.
			 *
			 * @type {number}
			 * @default Infinity
			 */
			this.attenuationDistance = Infinity;

			/**
			 * The color that white light turns into due to absorption when reaching the
			 * attenuation distance.
			 *
			 * @type {Color}
			 * @default (1,1,1)
			 */
			this.attenuationColor = new Color( 1, 1, 1 );

			/**
			 * A float that scales the amount of specular reflection for non-metals only.
			 * When set to zero, the model is effectively Lambertian. From `0.0` to `1.0`.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.specularIntensity = 1.0;

			/**
			 * The alpha channel of this texture is multiplied against `specularIntensity`,
			 * for per-pixel control over specular intensity.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.specularIntensityMap = null;

			/**
			 * Tints the specular reflection at normal incidence for non-metals only.
			 *
			 * @type {Color}
			 * @default (1,1,1)
			 */
			this.specularColor = new Color( 1, 1, 1 );

			/**
			 * The RGB channels of this texture are multiplied against `specularColor`,
			 * for per-pixel control over specular color.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.specularColorMap = null;

			this._anisotropy = 0;
			this._clearcoat = 0;
			this._dispersion = 0;
			this._iridescence = 0;
			this._sheen = 0.0;
			this._transmission = 0;

			this.setValues( parameters );

		}

		/**
		 * The anisotropy strength, from `0.0` to `1.0`.
		 *
		 * @type {number}
		 * @default 0
		 */
		get anisotropy() {

			return this._anisotropy;

		}

		set anisotropy( value ) {

			if ( this._anisotropy > 0 !== value > 0 ) {

				this.version ++;

			}

			this._anisotropy = value;

		}

		/**
		 * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
		 * clear coat related properties to enable multilayer materials that have a
		 * thin translucent layer over the base layer.
		 *
		 * @type {number}
		 * @default 0
		 */
		get clearcoat() {

			return this._clearcoat;

		}

		set clearcoat( value ) {

			if ( this._clearcoat > 0 !== value > 0 ) {

				this.version ++;

			}

			this._clearcoat = value;

		}
		/**
		 * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
		 * the surface and the viewer, from `0.0` to `1.0`.
		 *
		 * @type {number}
		 * @default 0
		 */
		get iridescence() {

			return this._iridescence;

		}

		set iridescence( value ) {

			if ( this._iridescence > 0 !== value > 0 ) {

				this.version ++;

			}

			this._iridescence = value;

		}

		/**
		 * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
		 * through a relatively clear volume. Any value zero or larger is valid, the typical range of
		 * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
		 *
		 * @type {number}
		 * @default 0
		 */
		get dispersion() {

			return this._dispersion;

		}

		set dispersion( value ) {

			if ( this._dispersion > 0 !== value > 0 ) {

				this.version ++;

			}

			this._dispersion = value;

		}

		/**
		 * The intensity of the sheen layer, from `0.0` to `1.0`.
		 *
		 * @type {number}
		 * @default 0
		 */
		get sheen() {

			return this._sheen;

		}

		set sheen( value ) {

			if ( this._sheen > 0 !== value > 0 ) {

				this.version ++;

			}

			this._sheen = value;

		}

		/**
		 * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
		 *
		 * Thin, transparent or semitransparent, plastic or glass materials remain
		 * largely reflective even if they are fully transmissive. The transmission
		 * property can be used to model these materials.
		 *
		 * When transmission is non-zero, `opacity` should be  set to `1`.
		 *
		 * @type {number}
		 * @default 0
		 */
		get transmission() {

			return this._transmission;

		}

		set transmission( value ) {

			if ( this._transmission > 0 !== value > 0 ) {

				this.version ++;

			}

			this._transmission = value;

		}

		copy( source ) {

			super.copy( source );

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.anisotropy = source.anisotropy;
			this.anisotropyRotation = source.anisotropyRotation;
			this.anisotropyMap = source.anisotropyMap;

			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

			this.dispersion = source.dispersion;
			this.ior = source.ior;

			this.iridescence = source.iridescence;
			this.iridescenceMap = source.iridescenceMap;
			this.iridescenceIOR = source.iridescenceIOR;
			this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
			this.iridescenceThicknessMap = source.iridescenceThicknessMap;

			this.sheen = source.sheen;
			this.sheenColor.copy( source.sheenColor );
			this.sheenColorMap = source.sheenColorMap;
			this.sheenRoughness = source.sheenRoughness;
			this.sheenRoughnessMap = source.sheenRoughnessMap;

			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;

			this.thickness = source.thickness;
			this.thicknessMap = source.thicknessMap;
			this.attenuationDistance = source.attenuationDistance;
			this.attenuationColor.copy( source.attenuationColor );

			this.specularIntensity = source.specularIntensity;
			this.specularIntensityMap = source.specularIntensityMap;
			this.specularColor.copy( source.specularColor );
			this.specularColorMap = source.specularColorMap;

			return this;

		}

	}

	/**
	 * A material implementing toon shading.
	 *
	 * @augments Material
	 */
	class MeshToonMaterial extends Material$1 {

		/**
		 * Constructs a new mesh toon material.
		 *
		 * @param {Object} [parameters] - An object with one or more properties
		 * defining the material's appearance. Any property of the material
		 * (including any property from inherited materials) can be passed
		 * in here. Color values can be passed any type of value accepted
		 * by {@link Color#set}.
		 */
		constructor( parameters ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isMeshToonMaterial = true;

			this.defines = { 'TOON': '' };

			this.type = 'MeshToonMaterial';

			/**
			 * Color of the material.
			 *
			 * @type {Color}
			 * @default (1,1,1)
			 */
			this.color = new Color( 0xffffff );

			/**
			 * The color map. May optionally include an alpha channel, typically combined
			 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
			 * color is modulated by the diffuse `color`.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.map = null;

			/**
			 * Gradient map for toon shading. It's required to set
			 * {@link Texture#minFilter} and {@link Texture#magFilter} to {@linkNearestFilter}
			 * when using this type of texture.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.gradientMap = null;

			/**
			 * The light map. Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.lightMap = null;

			/**
			 * Intensity of the baked light.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.lightMapIntensity = 1.0;

			/**
			 * The red channel of this texture is used as the ambient occlusion map.
			 * Requires a second set of UVs.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.aoMap = null;

			/**
			 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
			 * disables ambient occlusion. Where intensity is `1` and the AO map's
			 * red channel is also `1`, ambient light is fully occluded on a surface.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.aoMapIntensity = 1.0;

			/**
			 * Emissive (light) color of the material, essentially a solid color
			 * unaffected by other lighting.
			 *
			 * @type {Color}
			 * @default (0,0,0)
			 */
			this.emissive = new Color( 0x000000 );

			/**
			 * Intensity of the emissive light. Modulates the emissive color.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.emissiveIntensity = 1.0;

			/**
			 * Set emissive (glow) map. The emissive map color is modulated by the
			 * emissive color and the emissive intensity. If you have an emissive map,
			 * be sure to set the emissive color to something other than black.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.emissiveMap = null;

			/**
			 * The texture to create a bump map. The black and white values map to the
			 * perceived depth in relation to the lights. Bump doesn't actually affect
			 * the geometry of the object, only the lighting. If a normal map is defined
			 * this will be ignored.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.bumpMap = null;

			/**
			 * How much the bump map affects the material. Typical range is `[0,1]`.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.bumpScale = 1;

			/**
			 * The texture to create a normal map. The RGB values affect the surface
			 * normal for each pixel fragment and change the way the color is lit. Normal
			 * maps do not change the actual shape of the surface, only the lighting. In
			 * case the material has a normal map authored using the left handed
			 * convention, the `y` component of `normalScale` should be negated to compensate
			 * for the different handedness.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.normalMap = null;

			/**
			 * The type of normal map.
			 *
			 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
			 * @default TangentSpaceNormalMap
			 */
			this.normalMapType = TangentSpaceNormalMap;

			/**
			 * How much the normal map affects the material. Typical value range is `[0,1]`.
			 *
			 * @type {Vector2}
			 * @default (1,1)
			 */
			this.normalScale = new Vector2( 1, 1 );

			/**
			 * The displacement map affects the position of the mesh's vertices. Unlike
			 * other maps which only affect the light and shade of the material the
			 * displaced vertices can cast shadows, block other objects, and otherwise
			 * act as real geometry. The displacement texture is an image where the value
			 * of each pixel (white being the highest) is mapped against, and
			 * repositions, the vertices of the mesh.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.displacementMap = null;

			/**
			 * How much the displacement map affects the mesh (where black is no
			 * displacement, and white is maximum displacement). Without a displacement
			 * map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementScale = 1;

			/**
			 * The offset of the displacement map's values on the mesh's vertices.
			 * The bias is added to the scaled sample of the displacement map.
			 * Without a displacement map set, this value is not applied.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.displacementBias = 0;

			/**
			 * The alpha map is a grayscale texture that controls the opacity across the
			 * surface (black: fully transparent; white: fully opaque).
			 *
			 * Only the color of the texture is used, ignoring the alpha channel if one
			 * exists. For RGB and RGBA textures, the renderer will use the green channel
			 * when sampling this texture due to the extra bit of precision provided for
			 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
			 * luminance/alpha textures will also still work as expected.
			 *
			 * @type {?Texture}
			 * @default null
			 */
			this.alphaMap = null;

			/**
			 * Renders the geometry as a wireframe.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.wireframe = false;

			/**
			 * Controls the thickness of the wireframe.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.wireframeLinewidth = 1;

			/**
			 * Defines appearance of wireframe ends.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */
			this.wireframeLinecap = 'round';

			/**
			 * Defines appearance of wireframe joints.
			 *
			 * Can only be used with {@link SVGRenderer}.
			 *
			 * @type {('round'|'bevel'|'miter')}
			 * @default 'round'
			 */
			this.wireframeLinejoin = 'round';

			/**
			 * Whether the material is affected by fog or not.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;
			this.gradientMap = source.gradientMap;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.fog = source.fog;

			return this;

		}

	}

	exports.material = new MeshNormalMaterial();

	const NORMAL = "Normal",
	  BASIC = "Basic",
	  PHONG = "Phong",
	  PHYSICAL = "Physical",
	  TOON = "Toon";

	function SetMaterial(materialType = "Normal", attributes = {}) {
	  switch(materialType) {
	    case NORMAL:
	      exports.material = new MeshNormalMaterial(attributes);
	      break;
	    case BASIC:
	      exports.material = new MeshBasicMaterial(attributes);
	      break;
	    case PHONG:
	      exports.material = new MeshPhongMaterial(attributes);
	      break;
	    case PHYSICAL:
	      exports.material = new MeshPhysicalMaterial(attributes);
	      break;
	    case TOON:
	      exports.material = new MeshToonMaterial(attributes);
	      break;
	    default:
	      error(materialType, "is not a valid material type or currently supported in KA3D");
	  }
	}

	let Box$1 = class Box {
	    constructor(w = 100, h = 100, d = 100, mass = 1) {
	        this.shape = new Mesh(new BoxGeometry(w, h, d), exports.material);
	        exports.scene.add(this.shape);

	        threeMeshes.push(this.shape);
	    
	        this._physShape = new PhysBox(new Vec3(w/2, h/2, d/2));
	        this.physShape = new Body({ mass: mass });

	        this.physShape.addShape(this._physShape);
	        exports.world.addBody(this.physShape);

	        physMeshes.push(this.physShape);
	  }


	    add(mesh) {
	        const pos = mesh.physShape.position;
	        const rot = mesh.physShape.quaternion;

	        exports.world.removeBody(mesh.physShape);
	        this.shape.add(mesh.shape);
	        this.physShape.addShape(mesh._physShape, pos, rot);
	        return this;
	    }

	    setPosition(x = 0, y = 0, z = 0) {
	        this.physShape.position.set(x, y, z);
	        return this;
	    }

	    setRotation(x = 0, y = 0, z = 0) {
	        var euler = new Euler(x, y, z, "YXZ");
	        var quat = new Quaternion$1().setFromEuler(euler);
	        this.physShape.quaternion.copy(quat);
	        return this;
	    }
	};

	/**
	 * Abstract base class for lights - all other light types inherit the
	 * properties and methods described here.
	 *
	 * @abstract
	 * @augments Object3D
	 */
	class Light extends Object3D {

		/**
		 * Constructs a new light.
		 *
		 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
		 * @param {number} [intensity=1] - The light's strength/intensity.
		 */
		constructor( color, intensity = 1 ) {

			super();

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isLight = true;

			this.type = 'Light';

			/**
			 * The light's color.
			 *
			 * @type {Color}
			 */
			this.color = new Color( color );

			/**
			 * The light's intensity.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.intensity = intensity;

		}

		/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 */
		dispose() {

			// Empty here in base class; some subclasses override.

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
			if ( this.target !== undefined ) data.object.target = this.target.uuid;

			return data;

		}

	}

	/**
	 * This light globally illuminates all objects in the scene equally.
	 *
	 * It cannot be used to cast shadows as it does not have a direction.
	 *
	 * ```js
	 * const light = new THREE.AmbientLight( 0x404040 ); // soft white light
	 * scene.add( light );
	 * ```
	 *
	 * @augments Light
	 */
	class AmbientLight extends Light {

		/**
		 * Constructs a new ambient light.
		 *
		 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
		 * @param {number} [intensity=1] - The light's strength/intensity.
		 */
		constructor( color, intensity ) {

			super( color, intensity );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isAmbientLight = true;

			this.type = 'AmbientLight';

		}

	}

	const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
	const _lookTarget$1 = /*@__PURE__*/ new Vector3();

	/**
	 * Abstract base class for light shadow classes. These classes
	 * represent the shadow configuration for different light types.
	 *
	 * @abstract
	 */
	class LightShadow {

		/**
		 * Constructs a new light shadow.
		 *
		 * @param {Camera} camera - The light's view of the world.
		 */
		constructor( camera ) {

			/**
			 * The light's view of the world.
			 *
			 * @type {Camera}
			 */
			this.camera = camera;

			/**
			 * The intensity of the shadow. The default is `1`.
			 * Valid values are in the range `[0, 1]`.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.intensity = 1;

			/**
			 * Shadow map bias, how much to add or subtract from the normalized depth
			 * when deciding whether a surface is in shadow.
			 *
			 * The default is `0`. Very tiny adjustments here (in the order of `0.0001`)
			 * may help reduce artifacts in shadows.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.bias = 0;

			/**
			 * Defines how much the position used to query the shadow map is offset along
			 * the object normal. The default is `0`. Increasing this value can be used to
			 * reduce shadow acne especially in large scenes where light shines onto
			 * geometry at a shallow angle. The cost is that shadows may appear distorted.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.normalBias = 0;

			/**
			 * Setting this to values greater than 1 will blur the edges of the shadow.
			 * High values will cause unwanted banding effects in the shadows - a greater
			 * map size will allow for a higher value to be used here before these effects
			 * become visible.
			 *
			 * The property has no effect when the shadow map type is `PCFSoftShadowMap` and
			 * and it is recommended to increase softness by decreasing the shadow map size instead.
			 *
			 * The property has no effect when the shadow map type is `BasicShadowMap`.
			 *
			 * @type {number}
			 * @default 1
			 */
			this.radius = 1;

			/**
			 * The amount of samples to use when blurring a VSM shadow map.
			 *
			 * @type {number}
			 * @default 8
			 */
			this.blurSamples = 8;

			/**
			 * Defines the width and height of the shadow map. Higher values give better quality
			 * shadows at the cost of computation time. Values must be powers of two.
			 *
			 * @type {Vector2}
			 * @default (512,512)
			 */
			this.mapSize = new Vector2( 512, 512 );

			/**
			 * The type of shadow texture. The default is `UnsignedByteType`.
			 *
			 * @type {number}
			 * @default UnsignedByteType
			 */
			this.mapType = UnsignedByteType;

			/**
			 * The depth map generated using the internal camera; a location beyond a
			 * pixel's depth is in shadow. Computed internally during rendering.
			 *
			 * @type {?RenderTarget}
			 * @default null
			 */
			this.map = null;

			/**
			 * The distribution map generated using the internal camera; an occlusion is
			 * calculated based on the distribution of depths. Computed internally during
			 * rendering.
			 *
			 * @type {?RenderTarget}
			 * @default null
			 */
			this.mapPass = null;

			/**
			 * Model to shadow camera space, to compute location and depth in shadow map.
			 * This is computed internally during rendering.
			 *
			 * @type {Matrix4}
			 */
			this.matrix = new Matrix4();

			/**
			 * Enables automatic updates of the light's shadow. If you do not require dynamic
			 * lighting / shadows, you may set this to `false`.
			 *
			 * @type {boolean}
			 * @default true
			 */
			this.autoUpdate = true;

			/**
			 * When set to `true`, shadow maps will be updated in the next `render` call.
			 * If you have set {@link LightShadow#autoUpdate} to `false`, you will need to
			 * set this property to `true` and then make a render call to update the light's shadow.
			 *
			 * @type {boolean}
			 * @default false
			 */
			this.needsUpdate = false;

			this._frustum = new Frustum();
			this._frameExtents = new Vector2( 1, 1 );

			this._viewportCount = 1;

			this._viewports = [

				new Vector4( 0, 0, 1, 1 )

			];

		}

		/**
		 * Used internally by the renderer to get the number of viewports that need
		 * to be rendered for this shadow.
		 *
		 * @return {number} The viewport count.
		 */
		getViewportCount() {

			return this._viewportCount;

		}

		/**
		 * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
		 *
		 * @return {Frustum} The shadow camera frustum.
		 */
		getFrustum() {

			return this._frustum;

		}

		/**
		 * Update the matrices for the camera and shadow, used internally by the renderer.
		 *
		 * @param {Light} light - The light for which the shadow is being rendered.
		 */
		updateMatrices( light ) {

			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld$1 );

			_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _lookTarget$1 );
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix$1, shadowCamera.coordinateSystem, shadowCamera.reversedDepth );

			if ( shadowCamera.reversedDepth ) {

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 1.0, 0.0,
					0.0, 0.0, 0.0, 1.0
				);

			} else {

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

			}

			shadowMatrix.multiply( _projScreenMatrix$1 );

		}

		/**
		 * Returns a viewport definition for the given viewport index.
		 *
		 * @param {number} viewportIndex - The viewport index.
		 * @return {Vector4} The viewport.
		 */
		getViewport( viewportIndex ) {

			return this._viewports[ viewportIndex ];

		}

		/**
		 * Returns the frame extends.
		 *
		 * @return {Vector2} The frame extends.
		 */
		getFrameExtents() {

			return this._frameExtents;

		}

		/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 */
		dispose() {

			if ( this.map ) {

				this.map.dispose();

			}

			if ( this.mapPass ) {

				this.mapPass.dispose();

			}

		}

		/**
		 * Copies the values of the given light shadow instance to this instance.
		 *
		 * @param {LightShadow} source - The light shadow to copy.
		 * @return {LightShadow} A reference to this light shadow instance.
		 */
		copy( source ) {

			this.camera = source.camera.clone();

			this.intensity = source.intensity;

			this.bias = source.bias;
			this.radius = source.radius;

			this.autoUpdate = source.autoUpdate;
			this.needsUpdate = source.needsUpdate;
			this.normalBias = source.normalBias;
			this.blurSamples = source.blurSamples;

			this.mapSize.copy( source.mapSize );

			return this;

		}

		/**
		 * Returns a new light shadow instance with copied values from this instance.
		 *
		 * @return {LightShadow} A clone of this instance.
		 */
		clone() {

			return new this.constructor().copy( this );

		}

		/**
		 * Serializes the light shadow into JSON.
		 *
		 * @return {Object} A JSON object representing the serialized light shadow.
		 * @see {@link ObjectLoader#parse}
		 */
		toJSON() {

			const object = {};

			if ( this.intensity !== 1 ) object.intensity = this.intensity;
			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	}

	const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld = /*@__PURE__*/ new Vector3();
	const _lookTarget = /*@__PURE__*/ new Vector3();

	/**
	 * Represents the shadow configuration of point lights.
	 *
	 * @augments LightShadow
	 */
	class PointLightShadow extends LightShadow {

		/**
		 * Constructs a new point light shadow.
		 */
		constructor() {

			super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isPointLightShadow = true;

			this._frameExtents = new Vector2( 4, 2 );

			this._viewportCount = 6;

			this._viewports = [
				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				new Vector4( 2, 1, 1, 1 ),
				// negative X
				new Vector4( 0, 1, 1, 1 ),
				// positive Z
				new Vector4( 3, 1, 1, 1 ),
				// negative Z
				new Vector4( 1, 1, 1, 1 ),
				// positive Y
				new Vector4( 3, 0, 1, 1 ),
				// negative Y
				new Vector4( 1, 0, 1, 1 )
			];

			this._cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( -1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, -1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, -1, 0 )
			];

			this._cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, -1 )
			];

		}

		/**
		 * Update the matrices for the camera and shadow, used internally by the renderer.
		 *
		 * @param {Light} light - The light for which the shadow is being rendered.
		 * @param {number} [viewportIndex=0] - The viewport index.
		 */
		updateMatrices( light, viewportIndex = 0 ) {

			const camera = this.camera;
			const shadowMatrix = this.matrix;

			const far = light.distance || camera.far;

			if ( far !== camera.far ) {

				camera.far = far;
				camera.updateProjectionMatrix();

			}

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			camera.position.copy( _lightPositionWorld );

			_lookTarget.copy( camera.position );
			_lookTarget.add( this._cubeDirections[ viewportIndex ] );
			camera.up.copy( this._cubeUps[ viewportIndex ] );
			camera.lookAt( _lookTarget );
			camera.updateMatrixWorld();

			shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix, camera.coordinateSystem, camera.reversedDepth );

		}

	}

	/**
	 * A light that gets emitted from a single point in all directions. A common
	 * use case for this is to replicate the light emitted from a bare
	 * lightbulb.
	 *
	 * This light can cast shadows - see the {@link PointLightShadow} for details.
	 *
	 * ```js
	 * const light = new THREE.PointLight( 0xff0000, 1, 100 );
	 * light.position.set( 50, 50, 50 );
	 * scene.add( light );
	 * ```
	 *
	 * @augments Light
	 */
	class PointLight extends Light {

		/**
		 * Constructs a new point light.
		 *
		 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
		 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
		 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
		 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
		 */
		constructor( color, intensity, distance = 0, decay = 2 ) {

			super( color, intensity );

			/**
			 * This flag can be used for type testing.
			 *
			 * @type {boolean}
			 * @readonly
			 * @default true
			 */
			this.isPointLight = true;

			this.type = 'PointLight';

			/**
			 * When distance is zero, light will attenuate according to inverse-square
			 * law to infinite distance. When distance is non-zero, light will attenuate
			 * according to inverse-square law until near the distance cutoff, where it
			 * will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not
			 * physically correct.
			 *
			 * @type {number}
			 * @default 0
			 */
			this.distance = distance;

			/**
			 * The amount the light dims along the distance of the light. In context of
			 * physically-correct rendering the default value should not be changed.
			 *
			 * @type {number}
			 * @default 2
			 */
			this.decay = decay;

			/**
			 * This property holds the light's shadow configuration.
			 *
			 * @type {PointLightShadow}
			 */
			this.shadow = new PointLightShadow();

		}

		/**
		 * The light's power. Power is the luminous power of the light measured in lumens (lm).
		 * Changing the power will also change the light's intensity.
		 *
		 * @type {number}
		 */
		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
			return this.intensity * 4 * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / ( 4 * Math.PI );

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	}

	//Note: Point Lights use accurate units, where 1 = 1 meter.  Updated from r155 on

	const AMBIENT = 0,
	    POINT = 1,
	    SPOT = 2,
	    DIRECTIONAL = 3;

	function AddLight(type = AMBIENT, color = "white", brightness = 100) {
	    var l;
	    console.log(type, color, brightness);
	    switch (type) {
	        case AMBIENT:
	            l = new AmbientLight(color, brightness);
	            exports.scene.add(l);
	            break;
	        case POINT:
	            l = new PointLight(color, brightness);
	            exports.scene.add(l);
	            break;
	        default:
	            console.error("KA3D: Light is not a valid type");
	    }
	    return l;
	}

	/**
	 * A geometry class for representing a cylinder.
	 *
	 * ```js
	 * const geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
	 * const cylinder = new THREE.Mesh( geometry, material );
	 * scene.add( cylinder );
	 * ```
	 *
	 * @augments BufferGeometry
	 */
	class CylinderGeometry extends BufferGeometry {

		/**
		 * Constructs a new cylinder geometry.
		 *
		 * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
		 * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
		 * @param {number} [height=1] - Height of the cylinder.
		 * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
		 * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
		 * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
		 * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
		 * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
		 * The default value results in a complete cylinder.
		 */
		constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'CylinderGeometry';

			/**
			 * Holds the constructor parameters that have been
			 * used to generate the geometry. Any modification
			 * after instantiation does not change the geometry.
			 *
			 * @type {Object}
			 */
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			const scope = this;

			radialSegments = Math.floor( radialSegments );
			heightSegments = Math.floor( heightSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function generateTorso() {

				const normal = new Vector3();
				const vertex = new Vector3();

				let groupCount = 0;

				// this will be used to calculate the normal
				const slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( let y = 0; y <= heightSegments; y ++ ) {

					const indexRow = [];

					const v = y / heightSegments;

					// calculate the radius of the current row

					const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( let x = 0; x <= radialSegments; x ++ ) {

						const u = x / radialSegments;

						const theta = u * thetaLength + thetaStart;

						const sinTheta = Math.sin( theta );
						const cosTheta = Math.cos( theta );

						// vertex

						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );

						// normal

						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );

						// uv

						uvs.push( u, 1 - v );

						// save index of vertex in respective row

						indexRow.push( index ++ );

					}

					// now save vertices of the row in our index array

					indexArray.push( indexRow );

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					for ( let y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices

						const a = indexArray[ y ][ x ];
						const b = indexArray[ y + 1 ][ x ];
						const c = indexArray[ y + 1 ][ x + 1 ];
						const d = indexArray[ y ][ x + 1 ];

						// faces

						if ( radiusTop > 0 || y !== 0 ) {

							indices.push( a, b, d );
							groupCount += 3;

						}

						if ( radiusBottom > 0 || y !== heightSegments - 1 ) {

							indices.push( b, c, d );
							groupCount += 3;

						}

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

			function generateCap( top ) {

				// save the index of the first center vertex
				const centerIndexStart = index;

				const uv = new Vector2();
				const vertex = new Vector3();

				let groupCount = 0;

				const radius = ( top === true ) ? radiusTop : radiusBottom;
				const sign = ( top === true ) ? 1 : -1;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( let x = 1; x <= radialSegments; x ++ ) {

					// vertex

					vertices.push( 0, halfHeight * sign, 0 );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uvs.push( 0.5, 0.5 );

					// increase index

					index ++;

				}

				// save the index of the last center vertex
				const centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;

					const cosTheta = Math.cos( theta );
					const sinTheta = Math.sin( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );

					// increase index

					index ++;

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if ( top === true ) {

						// face top

						indices.push( i, i + 1, c );

					} else {

						// face bottom

						indices.push( i + 1, i, c );

					}

					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		/**
		 * Factory method for creating an instance of this class from the given
		 * JSON object.
		 *
		 * @param {Object} data - A JSON object representing the serialized geometry.
		 * @return {CylinderGeometry} A new instance.
		 */
		static fromJSON( data ) {

			return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

		}

	}

	class Cylinder {
	    constructor(radiusTop = 1, radiusBottom = 1, height = 2, segments = 8, mass = 1) {
	        this.shape = new Mesh(new CylinderGeometry(radiusTop, radiusBottom, height, segments), exports.material);
	        exports.scene.add(this.shape);

	        threeMeshes.push(this.shape);

	        this._physShape = new PhysCylinder(radiusTop, radiusBottom, height, segments);
	        this.physShape = new Body({ mass: mass });

	        this.physShape.addShape(this._physShape);
	        exports.world.addBody(this.physShape);

	        physMeshes.push(this.physShape);
	    }

	    add(mesh) {
	        const pos = mesh.physShape.position;
	        const rot = mesh.physShape.quaternion;

	        exports.world.removeBody(mesh.physShape);
	        this.shape.add(mesh.shape);
	        this.physShape.addShape(mesh._physShape, pos, rot);
	        return this;
	    }

	    setPosition(x = 0, y = 0, z = 0) {
	        this.physShape.position.set(x, y, z);
	        return this;
	    }

	    setRotation(x = 0, y = 0, z = 0) {
	        var euler = new Euler(x, y, z, "YXZ");
	        var quat = new Quaternion$1().setFromEuler(euler);
	        this.physShape.quaternion.copy(quat);
	        return this;
	    }
	}

	/**
	 * A class for generating a sphere geometry.
	 *
	 * ```js
	 * const geometry = new THREE.SphereGeometry( 15, 32, 16 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
	 * const sphere = new THREE.Mesh( geometry, material );
	 * scene.add( sphere );
	 * ```
	 *
	 * @augments BufferGeometry
	 */
	class SphereGeometry extends BufferGeometry {

		/**
		 * Constructs a new sphere geometry.
		 *
		 * @param {number} [radius=1] - The sphere radius.
		 * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
		 * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
		 * @param {number} [phiStart=0] - The horizontal starting angle in radians.
		 * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
		 * @param {number} [thetaStart=0] - The vertical starting angle in radians.
		 * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
		 */
		constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

			super();

			this.type = 'SphereGeometry';

			/**
			 * Holds the constructor parameters that have been
			 * used to generate the geometry. Any modification
			 * after instantiation does not change the geometry.
			 *
			 * @type {Object}
			 */
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			widthSegments = Math.max( 3, Math.floor( widthSegments ) );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) );

			const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

			let index = 0;
			const grid = [];

			const vertex = new Vector3();
			const normal = new Vector3();

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// generate vertices, normals and uvs

			for ( let iy = 0; iy <= heightSegments; iy ++ ) {

				const verticesRow = [];

				const v = iy / heightSegments;

				// special case for the poles

				let uOffset = 0;

				if ( iy === 0 && thetaStart === 0 ) {

					uOffset = 0.5 / widthSegments;

				} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

					uOffset = -0.5 / widthSegments;

				}

				for ( let ix = 0; ix <= widthSegments; ix ++ ) {

					const u = ix / widthSegments;

					// vertex

					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.copy( vertex ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u + uOffset, 1 - v );

					verticesRow.push( index ++ );

				}

				grid.push( verticesRow );

			}

			// indices

			for ( let iy = 0; iy < heightSegments; iy ++ ) {

				for ( let ix = 0; ix < widthSegments; ix ++ ) {

					const a = grid[ iy ][ ix + 1 ];
					const b = grid[ iy ][ ix ];
					const c = grid[ iy + 1 ][ ix ];
					const d = grid[ iy + 1 ][ ix + 1 ];

					if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		/**
		 * Factory method for creating an instance of this class from the given
		 * JSON object.
		 *
		 * @param {Object} data - A JSON object representing the serialized geometry.
		 * @return {SphereGeometry} A new instance.
		 */
		static fromJSON( data ) {

			return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

		}

	}

	class Sphere {
	    constructor(radius = 1, mass = 1) {
	        this.shape = new Mesh(new SphereGeometry(radius), exports.material);
	        exports.scene.add(this.shape);

	        threeMeshes.push(this.shape);

	        this._physShape = new PhysSphere(radius);
	        this.physShape = new Body({ mass: mass });

	        this.physShape.addShape(this._physShape);
	        exports.world.addBody(this.physShape);

	        physMeshes.push(this.physShape);
	    }


	    add(mesh) {
	        const pos = mesh.physShape.position;
	        const rot = mesh.physShape.quaternion;

	        exports.world.removeBody(mesh.physShape);
	        this.shape.add(mesh.shape);
	        this.physShape.addShape(mesh._physShape, pos, rot);
	        return this;
	    }

	    setPosition(x = 0, y = 0, z = 0) {
	        this.physShape.position.set(x, y, z);
	        return this;
	    }

	    setRotation(x = 0, y = 0, z = 0) {
	        var euler = new Euler(x, y, z, "YXZ");
	        var quat = new Quaternion$1().setFromEuler(euler);
	        this.physShape.quaternion.copy(quat);
	        return this;
	    }
	}

	class Plane {
	    constructor(w = 100, h = 100, mass = 1) {
	        /*if (infinite) {
	            this.shape = new Mesh(new PlaneGeometry(camera.far, camera.far), material);
	            this.shape.position.x = camera.position.x;
	            this.shape.position.y = camera.position.z;
	            scene.add(this.shape);

	            threeMeshes.push(this.shape);

	            this._physShape = new PhysPlane();
	            this.physShape = new Body({ mass: mass });

	            this.physShape.addShape(this._physShape);
	            world.addBody(this.physShape);

	            this.setRotation(Math.PI / 2, 0, 0);

	            physMeshes.push(this.physShape);
	        }
	        else {*/
	            this.shape = new Mesh(new PlaneGeometry(w, h), exports.material);
	            exports.scene.add(this.shape);

	            threeMeshes.push(this.shape);

	            this._physShape = new PhysBox(new Vec3(w/2, h/2, 0.001));
	            this.physShape = new Body({ mass: mass });

	            this.physShape.addShape(this._physShape);
	            exports.world.addBody(this.physShape);

	            this.setRotation(Math.PI / 2, 0, 0);

	            physMeshes.push(this.physShape);
	        //}
	    }

	    add(mesh) {
	        const pos = mesh.physShape.position;
	        const rot = mesh.physShape.quaternion;

	        exports.world.removeBody(mesh.physShape);
	        this.shape.add(mesh.shape);
	        this.physShape.addShape(mesh._physShape, pos, rot);
	        return this;
	    }

	    setPosition(x = 0, y = 0, z = 0) {
	        this.physShape.position.set(x, y, z);
	        return this;
	    }

	    setRotation(x = 0, y = 0, z = 0) {
	        var euler = new Euler(x, y, z, "YXZ");
	        var quat = new Quaternion$1().setFromEuler(euler);
	        this.physShape.quaternion.copy(quat);
	        return this;
	    }
	}

	/**
	 * A geometry class for representing a cone.
	 *
	 * ```js
	 * const geometry = new THREE.ConeGeometry( 5, 20, 32 );
	 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
	 * const cone = new THREE.Mesh(geometry, material );
	 * scene.add( cone );
	 * ```
	 *
	 * @augments CylinderGeometry
	 */
	class ConeGeometry extends CylinderGeometry {

		/**
		 * Constructs a new cone geometry.
		 *
		 * @param {number} [radius=1] - Radius of the cone base.
		 * @param {number} [height=1] - Height of the cone.
		 * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cone.
		 * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cone.
		 * @param {boolean} [openEnded=false] - Whether the base of the cone is open or capped.
		 * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
		 * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
		 * The default value results in a complete cone.
		 */
		constructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeGeometry';

			/**
			 * Holds the constructor parameters that have been
			 * used to generate the geometry. Any modification
			 * after instantiation does not change the geometry.
			 *
			 * @type {Object}
			 */
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		/**
		 * Factory method for creating an instance of this class from the given
		 * JSON object.
		 *
		 * @param {Object} data - A JSON object representing the serialized geometry.
		 * @return {ConeGeometry} A new instance.
		 */
		static fromJSON( data ) {

			return new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

		}

	}

	class Cone {
	    constructor(radius = 1, height = 2, segments = 8, mass = 1) {
	        this.shape = new Mesh(new ConeGeometry(radius, height, segments), exports.material);
	        exports.scene.add(this.shape);

	        threeMeshes.push(this.shape);

	        this._physShape = new PhysCylinder(0, radius, height, segments);
	        this.physShape = new Body({ mass: mass });

	        this.physShape.addShape(this._physShape);
	        exports.world.addBody(this.physShape);

	        physMeshes.push(this.physShape);
	    }

	    add(mesh) {
	        const pos = mesh.physShape.position;
	        const rot = mesh.physShape.quaternion;

	        exports.world.removeBody(mesh.physShape);
	        this.shape.add(mesh.shape);
	        this.physShape.addShape(mesh._physShape, pos, rot);
	        return this;
	    }

	    setPosition(x = 0, y = 0, z = 0) {
	        this.physShape.position.set(x, y, z);
	        return this;
	    }

	    setRotation(x = 0, y = 0, z = 0) {
	        var euler = new Euler(x, y, z, "YXZ");
	        var quat = new Quaternion$1().setFromEuler(euler);
	        this.physShape.quaternion.copy(quat);
	        return this;
	    }
	}

	exports.AMBIENT = AMBIENT;
	exports.AddLight = AddLight;
	exports.BASIC = BASIC;
	exports.BackSide = BackSide;
	exports.Box = Box$1;
	exports.Cone = Cone;
	exports.Cylinder = Cylinder;
	exports.DIRECTIONAL = DIRECTIONAL;
	exports.DoubleSide = DoubleSide;
	exports.EnablePhysics = EnablePhysics;
	exports.FrontSide = FrontSide;
	exports.Init = Init;
	exports.NORMAL = NORMAL;
	exports.PHONG = PHONG;
	exports.PHYSICAL = PHYSICAL;
	exports.POINT = POINT;
	exports.Plane = Plane;
	exports.Render = Render;
	exports.SPOT = SPOT;
	exports.SetMaterial = SetMaterial;
	exports.Sphere = Sphere;
	exports.TOON = TOON;
	exports.Vec3 = Vec3;
	exports.physMeshes = physMeshes;
	exports.threeMeshes = threeMeshes;

	return exports;

})({});
